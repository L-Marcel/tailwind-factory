"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js"(exports, module2) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  }
});

// node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js
var require_object_hash = __commonJS({
  "node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js"(exports, module2) {
    "use strict";
    var crypto = require("crypto");
    exports = module2.exports = objectHash;
    function objectHash(object, options) {
      options = applyDefaults(object, options);
      return hash(object, options);
    }
    exports.sha1 = function(object) {
      return objectHash(object);
    };
    exports.keys = function(object) {
      return objectHash(object, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
    };
    exports.MD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex" });
    };
    exports.keysMD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex", excludeValues: true });
    };
    var hashes = crypto.getHashes ? crypto.getHashes().slice() : ["sha1", "md5"];
    hashes.push("passthrough");
    var encodings = ["buffer", "hex", "binary", "base64"];
    function applyDefaults(object, sourceOptions) {
      sourceOptions = sourceOptions || {};
      var options = {};
      options.algorithm = sourceOptions.algorithm || "sha1";
      options.encoding = sourceOptions.encoding || "hex";
      options.excludeValues = sourceOptions.excludeValues ? true : false;
      options.algorithm = options.algorithm.toLowerCase();
      options.encoding = options.encoding.toLowerCase();
      options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true;
      options.respectType = sourceOptions.respectType === false ? false : true;
      options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
      options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
      options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true;
      options.unorderedSets = sourceOptions.unorderedSets === false ? false : true;
      options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true;
      options.replacer = sourceOptions.replacer || void 0;
      options.excludeKeys = sourceOptions.excludeKeys || void 0;
      if (typeof object === "undefined") {
        throw new Error("Object argument required.");
      }
      for (var i = 0; i < hashes.length; ++i) {
        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
          options.algorithm = hashes[i];
        }
      }
      if (hashes.indexOf(options.algorithm) === -1) {
        throw new Error('Algorithm "' + options.algorithm + '"  not supported. supported values: ' + hashes.join(", "));
      }
      if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough") {
        throw new Error('Encoding "' + options.encoding + '"  not supported. supported values: ' + encodings.join(", "));
      }
      return options;
    }
    function isNativeFunction(f) {
      if (typeof f !== "function") {
        return false;
      }
      var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
      return exp.exec(Function.prototype.toString.call(f)) != null;
    }
    function hash(object, options) {
      var hashingStream;
      if (options.algorithm !== "passthrough") {
        hashingStream = crypto.createHash(options.algorithm);
      } else {
        hashingStream = new PassThrough();
      }
      if (typeof hashingStream.write === "undefined") {
        hashingStream.write = hashingStream.update;
        hashingStream.end = hashingStream.update;
      }
      var hasher = typeHasher(options, hashingStream);
      hasher.dispatch(object);
      if (!hashingStream.update) {
        hashingStream.end("");
      }
      if (hashingStream.digest) {
        return hashingStream.digest(options.encoding === "buffer" ? void 0 : options.encoding);
      }
      var buf = hashingStream.read();
      if (options.encoding === "buffer") {
        return buf;
      }
      return buf.toString(options.encoding);
    }
    exports.writeToStream = function(object, options, stream) {
      if (typeof stream === "undefined") {
        stream = options;
        options = {};
      }
      options = applyDefaults(object, options);
      return typeHasher(options, stream).dispatch(object);
    };
    function typeHasher(options, writeTo, context) {
      context = context || [];
      var write = function(str) {
        if (writeTo.update) {
          return writeTo.update(str, "utf8");
        } else {
          return writeTo.write(str, "utf8");
        }
      };
      return {
        dispatch: function(value) {
          if (options.replacer) {
            value = options.replacer(value);
          }
          var type = typeof value;
          if (value === null) {
            type = "null";
          }
          return this["_" + type](value);
        },
        _object: function(object) {
          var pattern = /\[object (.*)\]/i;
          var objString = Object.prototype.toString.call(object);
          var objType = pattern.exec(objString);
          if (!objType) {
            objType = "unknown:[" + objString + "]";
          } else {
            objType = objType[1];
          }
          objType = objType.toLowerCase();
          var objectNumber = null;
          if ((objectNumber = context.indexOf(object)) >= 0) {
            return this.dispatch("[CIRCULAR:" + objectNumber + "]");
          } else {
            context.push(object);
          }
          if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
            write("buffer:");
            return write(object);
          }
          if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
            if (this["_" + objType]) {
              this["_" + objType](object);
            } else if (options.ignoreUnknown) {
              return write("[" + objType + "]");
            } else {
              throw new Error('Unknown object type "' + objType + '"');
            }
          } else {
            var keys = Object.keys(object);
            if (options.unorderedObjects) {
              keys = keys.sort();
            }
            if (options.respectType !== false && !isNativeFunction(object)) {
              keys.splice(0, 0, "prototype", "__proto__", "constructor");
            }
            if (options.excludeKeys) {
              keys = keys.filter(function(key) {
                return !options.excludeKeys(key);
              });
            }
            write("object:" + keys.length + ":");
            var self = this;
            return keys.forEach(function(key) {
              self.dispatch(key);
              write(":");
              if (!options.excludeValues) {
                self.dispatch(object[key]);
              }
              write(",");
            });
          }
        },
        _array: function(arr, unordered) {
          unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false;
          var self = this;
          write("array:" + arr.length + ":");
          if (!unordered || arr.length <= 1) {
            return arr.forEach(function(entry) {
              return self.dispatch(entry);
            });
          }
          var contextAdditions = [];
          var entries = arr.map(function(entry) {
            var strm = new PassThrough();
            var localContext = context.slice();
            var hasher = typeHasher(options, strm, localContext);
            hasher.dispatch(entry);
            contextAdditions = contextAdditions.concat(localContext.slice(context.length));
            return strm.read().toString();
          });
          context = context.concat(contextAdditions);
          entries.sort();
          return this._array(entries, false);
        },
        _date: function(date) {
          return write("date:" + date.toJSON());
        },
        _symbol: function(sym) {
          return write("symbol:" + sym.toString());
        },
        _error: function(err) {
          return write("error:" + err.toString());
        },
        _boolean: function(bool) {
          return write("bool:" + bool.toString());
        },
        _string: function(string) {
          write("string:" + string.length + ":");
          write(string.toString());
        },
        _function: function(fn) {
          write("fn:");
          if (isNativeFunction(fn)) {
            this.dispatch("[native]");
          } else {
            this.dispatch(fn.toString());
          }
          if (options.respectFunctionNames !== false) {
            this.dispatch("function-name:" + String(fn.name));
          }
          if (options.respectFunctionProperties) {
            this._object(fn);
          }
        },
        _number: function(number) {
          return write("number:" + number.toString());
        },
        _xml: function(xml) {
          return write("xml:" + xml.toString());
        },
        _null: function() {
          return write("Null");
        },
        _undefined: function() {
          return write("Undefined");
        },
        _regexp: function(regex) {
          return write("regex:" + regex.toString());
        },
        _uint8array: function(arr) {
          write("uint8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint8clampedarray: function(arr) {
          write("uint8clampedarray:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int8array: function(arr) {
          write("int8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint16array: function(arr) {
          write("uint16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int16array: function(arr) {
          write("int16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint32array: function(arr) {
          write("uint32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int32array: function(arr) {
          write("int32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float32array: function(arr) {
          write("float32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float64array: function(arr) {
          write("float64array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _arraybuffer: function(arr) {
          write("arraybuffer:");
          return this.dispatch(new Uint8Array(arr));
        },
        _url: function(url) {
          return write("url:" + url.toString(), "utf8");
        },
        _map: function(map) {
          write("map:");
          var arr = Array.from(map);
          return this._array(arr, options.unorderedSets !== false);
        },
        _set: function(set) {
          write("set:");
          var arr = Array.from(set);
          return this._array(arr, options.unorderedSets !== false);
        },
        _file: function(file) {
          write("file:");
          return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
        },
        _blob: function() {
          if (options.ignoreUnknown) {
            return write("[blob]");
          }
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        },
        _domwindow: function() {
          return write("domwindow");
        },
        _bigint: function(number) {
          return write("bigint:" + number.toString());
        },
        _process: function() {
          return write("process");
        },
        _timer: function() {
          return write("timer");
        },
        _pipe: function() {
          return write("pipe");
        },
        _tcp: function() {
          return write("tcp");
        },
        _udp: function() {
          return write("udp");
        },
        _tty: function() {
          return write("tty");
        },
        _statwatcher: function() {
          return write("statwatcher");
        },
        _securecontext: function() {
          return write("securecontext");
        },
        _connection: function() {
          return write("connection");
        },
        _zlib: function() {
          return write("zlib");
        },
        _context: function() {
          return write("context");
        },
        _nodescript: function() {
          return write("nodescript");
        },
        _httpparser: function() {
          return write("httpparser");
        },
        _dataview: function() {
          return write("dataview");
        },
        _signal: function() {
          return write("signal");
        },
        _fsevent: function() {
          return write("fsevent");
        },
        _tlswrap: function() {
          return write("tlswrap");
        }
      };
    }
    function PassThrough() {
      return {
        buf: "",
        write: function(b) {
          this.buf += b;
        },
        end: function(b) {
          this.buf += b;
        },
        read: function() {
          return this.buf;
        }
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/hashConfig.js
var require_hashConfig = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/hashConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => hashConfig
    });
    var _objectHash = /* @__PURE__ */ _interopRequireDefault(require_object_hash());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function hashConfig(config) {
      return (0, _objectHash.default)(config, {
        ignoreUnknown: true
      });
    }
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/homedir.js"(exports, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/caller.js"(exports, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js"(exports, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/node-modules-paths.js"(exports, module2) {
    var path3 = require("path");
    var parse4 = path3.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse4(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse4(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path3.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/normalize-options.js"(exports, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/.pnpm/is-core-module@2.11.0/node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/.pnpm/is-core-module@2.11.0/node_modules/is-core-module/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/.pnpm/is-core-module@2.11.0/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/.pnpm/is-core-module@2.11.0/node_modules/is-core-module/index.js"(exports, module2) {
    "use strict";
    var has2 = require_src();
    function specifierIncluded(current2, specifier) {
      var nodeParts = current2.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current2, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current2, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current2 = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current2 !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current2, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current2, specifierValue);
    }
    var data2 = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return has2(data2, x) && versionIncluded(nodeVersion, data2[x]);
    };
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/async.js"(exports, module2) {
    var fs = require("fs");
    var getHomedir = require_homedir();
    var path3 = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path3.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path3.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path3.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path3.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path3.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path3.dirname(dir), cb2);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path3.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path3.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path3.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path3.join(x2, "index"), pkg2, cb2);
                  var dir = path3.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path3.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path3.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path3.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": ">= 18",
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/core.js"(exports, module2) {
    var current2 = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current2[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data2 = require_core2();
    var core = {};
    for (mod in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, mod)) {
        core[mod] = versionIncluded(data2[mod]);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/is-core.js"(exports, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/lib/sync.js"(exports, module2) {
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path3 = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync2, pkgfile) {
      var body = readFileSync2(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync2 = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path3.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path3.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path3.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path3.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path3.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path3.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync2, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, dir);
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync2, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x2);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path3.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path3.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path3.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path3.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/.pnpm/resolve@1.22.1/node_modules/resolve/index.js"(exports, module2) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// node_modules/.pnpm/acorn@7.4.1/node_modules/acorn/dist/acorn.mjs
var acorn_exports = {};
__export(acorn_exports, {
  Node: () => Node,
  Parser: () => Parser,
  Position: () => Position,
  SourceLocation: () => SourceLocation,
  TokContext: () => TokContext,
  Token: () => Token,
  TokenType: () => TokenType,
  defaultOptions: () => defaultOptions,
  getLineInfo: () => getLineInfo,
  isIdentifierChar: () => isIdentifierChar,
  isIdentifierStart: () => isIdentifierStart,
  isNewLine: () => isNewLine,
  keywordTypes: () => keywords$1,
  lineBreak: () => lineBreak,
  lineBreakG: () => lineBreakG,
  nonASCIIwhitespace: () => nonASCIIwhitespace,
  parse: () => parse3,
  parseExpressionAt: () => parseExpressionAt2,
  tokContexts: () => types$1,
  tokTypes: () => types,
  tokenizer: () => tokenizer2,
  version: () => version
});
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) {
      return false;
    }
    pos += set[i + 1];
    if (pos >= code) {
      return true;
    }
  }
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
function kw(name, options) {
  if (options === void 0)
    options = {};
  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options);
}
function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || !ecma2019String && (code === 8232 || code === 8233);
}
function has(obj, propName) {
  return hasOwnProperty.call(obj, propName);
}
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset2) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset2 - cur);
    }
  }
}
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
function codePointToString(ch) {
  if (ch <= 65535) {
    return String.fromCharCode(ch);
  }
  ch -= 65536;
  return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
}
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
function codePointToString$1(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function parse3(input, options) {
  return Parser.parse(input, options);
}
function parseExpressionAt2(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
}
function tokenizer2(input, options) {
  return Parser.tokenizer(input, options);
}
var reservedWords, ecma5AndLessKeywords, keywords, keywordRelationalOperator, nonASCIIidentifierStartChars, nonASCIIidentifierChars, nonASCIIidentifierStart, nonASCIIidentifier, astralIdentifierStartCodes, astralIdentifierCodes, TokenType, beforeExpr, startsExpr, keywords$1, types, lineBreak, lineBreakG, nonASCIIwhitespace, skipWhiteSpace, ref, hasOwnProperty, toString, isArray, Position, SourceLocation, defaultOptions, SCOPE_TOP, SCOPE_FUNCTION, SCOPE_VAR, SCOPE_ASYNC, SCOPE_GENERATOR, SCOPE_ARROW, SCOPE_SIMPLE_CATCH, SCOPE_SUPER, SCOPE_DIRECT_SUPER, BIND_NONE, BIND_VAR, BIND_LEXICAL, BIND_FUNCTION, BIND_SIMPLE_CATCH, BIND_OUTSIDE, Parser, prototypeAccessors, pp, literal, pp$1, loopLabel, switchLabel, empty, FUNC_STATEMENT, FUNC_HANGING_STATEMENT, FUNC_NULLABLE_ID, pp$2, pp$3, empty$1, pp$4, pp$5, Scope, Node, pp$6, TokContext, types$1, pp$7, ecma9BinaryProperties, ecma10BinaryProperties, ecma11BinaryProperties, unicodeBinaryProperties, unicodeGeneralCategoryValues, ecma9ScriptValues, ecma10ScriptValues, ecma11ScriptValues, unicodeScriptValues, data, pp$8, RegExpValidationState, Token, pp$9, INVALID_TEMPLATE_ESCAPE_ERROR, version;
var init_acorn = __esm({
  "node_modules/.pnpm/acorn@7.4.1/node_modules/acorn/dist/acorn.mjs"() {
    reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    keywords = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    keywordRelationalOperator = /^in(stanceof)?$/;
    nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    TokenType = function TokenType2(label, conf) {
      if (conf === void 0)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    beforeExpr = { beforeExpr: true };
    startsExpr = { startsExpr: true };
    keywords$1 = {};
    types = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", { beforeExpr: true }),
      coalesce: binop("??", 1),
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", { isLoop: true, beforeExpr: true }),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", { isLoop: true }),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", { isLoop: true }),
      _with: kw("with"),
      _new: kw("new", { beforeExpr: true, startsExpr: true }),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    lineBreak = /\r\n?|\n|\u2028|\u2029/;
    lineBreakG = new RegExp(lineBreak.source, "g");
    nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    ref = Object.prototype;
    hasOwnProperty = ref.hasOwnProperty;
    toString = ref.toString;
    isArray = Array.isArray || function(obj) {
      return toString.call(obj) === "[object Array]";
    };
    Position = function Position2(line, col) {
      this.line = line;
      this.column = col;
    };
    Position.prototype.offset = function offset(n) {
      return new Position(this.line, this.column + n);
    };
    SourceLocation = function SourceLocation2(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) {
        this.source = p.sourceFile;
      }
    };
    defaultOptions = {
      ecmaVersion: 10,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowAwaitOutsideFunction: false,
      allowHashBang: false,
      locations: false,
      onToken: null,
      onComment: null,
      ranges: false,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: false
    };
    SCOPE_TOP = 1;
    SCOPE_FUNCTION = 2;
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;
    SCOPE_ASYNC = 4;
    SCOPE_GENERATOR = 8;
    SCOPE_ARROW = 16;
    SCOPE_SIMPLE_CATCH = 32;
    SCOPE_SUPER = 64;
    SCOPE_DIRECT_SUPER = 128;
    BIND_NONE = 0;
    BIND_VAR = 1;
    BIND_LEXICAL = 2;
    BIND_FUNCTION = 3;
    BIND_SIMPLE_CATCH = 4;
    BIND_OUTSIDE = 5;
    Parser = function Parser2(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        for (var v = options.ecmaVersion; ; v--) {
          if (reserved = reservedWords[v]) {
            break;
          }
        }
        if (options.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = {};
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);
      this.regexpState = null;
    };
    prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true } };
    Parser.prototype.parse = function parse() {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node);
    };
    prototypeAccessors.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
    };
    prototypeAccessors.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
    };
    prototypeAccessors.allowSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    Parser.prototype.inNonArrowFunction = function inNonArrowFunction() {
      return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
    };
    Parser.extend = function extend() {
      var plugins = [], len = arguments.length;
      while (len--)
        plugins[len] = arguments[len];
      var cls = this;
      for (var i = 0; i < plugins.length; i++) {
        cls = plugins[i](cls);
      }
      return cls;
    };
    Parser.parse = function parse2(input, options) {
      return new this(options, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression();
    };
    Parser.tokenizer = function tokenizer(input, options) {
      return new this(options, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    pp = Parser.prototype;
    literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp.strictDirective = function(start) {
      for (; ; ) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) {
          return false;
        }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp.isContextual = function(name) {
      return this.type === types.name && this.value === name && !this.containsEsc;
    };
    pp.eatContextual = function(name) {
      if (!this.isContextual(name)) {
        return false;
      }
      this.next();
      return true;
    };
    pp.expectContextual = function(name) {
      if (!this.eatContextual(name)) {
        this.unexpected();
      }
    };
    pp.canInsertSemicolon = function() {
      return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp.semicolon = function() {
      if (!this.eat(types.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, "Parenthesized pattern");
      }
    };
    pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    pp$1 = Parser.prototype;
    pp$1.parseTopLevel = function(node) {
      var exports = {};
      if (!node.body) {
        node.body = [];
      }
      while (this.type !== types.eof) {
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
      }
      if (this.inModule) {
        for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
          var name = list[i];
          this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node.body);
      this.next();
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program");
    };
    loopLabel = { kind: "loop" };
    switchLabel = { kind: "switch" };
    pp$1.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) {
        return true;
      }
      if (context) {
        return false;
      }
      if (nextCh === 123) {
        return true;
      }
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$1.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length;
      return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
    };
    pp$1.parseStatement = function(context, topLevel, exports) {
      var starttype = this.type, node = this.startNode(), kind;
      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }
      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types._debugger:
          return this.parseDebuggerStatement(node);
        case types._do:
          return this.parseDoStatement(node);
        case types._for:
          return this.parseForStatement(node);
        case types._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context);
        case types._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types._if:
          return this.parseIfStatement(node);
        case types._return:
          return this.parseReturnStatement(node);
        case types._switch:
          return this.parseSwitchStatement(node);
        case types._throw:
          return this.parseThrowStatement(node);
        case types._try:
          return this.parseTryStatement(node);
        case types._const:
        case types._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types._while:
          return this.parseWhileStatement(node);
        case types._with:
          return this.parseWithStatement(node);
        case types.braceL:
          return this.parseBlock(true, node);
        case types.semi:
          return this.parseEmptyStatement(node);
        case types._export:
        case types._import:
          if (this.options.ecmaVersion > 10 && starttype === types._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
      }
    };
    pp$1.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types.semi) || this.insertSemicolon()) {
        node.label = null;
      } else if (this.type !== types.name) {
        this.unexpected();
      } else {
        node.label = this.parseIdent();
        this.semicolon();
      }
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node.label && isBreak) {
            break;
          }
        }
      }
      if (i === this.labels.length) {
        this.raise(node.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$1.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    pp$1.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node, "DoWhileStatement");
    };
    pp$1.parseForStatement = function(node) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types.parenL);
      if (this.type === types.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, null);
      }
      var isLet = this.isLet();
      if (this.type === types._var || this.type === types._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init$1);
      }
      var refDestructuringErrors = new DestructuringErrors();
      var init = this.parseExpression(true, refDestructuringErrors);
      if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node.await = awaitAt > -1;
          }
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLVal(init);
        return this.parseForIn(node, init);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    };
    pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$1.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    };
    pp$1.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types.semi) || this.insertSemicolon()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    pp$1.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types.braceR; ) {
        if (this.type === types._case || this.type === types._default) {
          var isCase = this.type === types._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    pp$1.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    empty = [];
    pp$1.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple2 = clause.param.type === "Identifier";
          this.enterScope(simple2 ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(clause.param, simple2 ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types.parenR);
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(node.start, "Missing catch or finally clause");
      }
      return this.finishNode(node, "TryStatement");
    };
    pp$1.parseVarStatement = function(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    pp$1.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    pp$1.parseWithStatement = function(node) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement");
    };
    pp$1.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
        var label = list[i$1];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    pp$1.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
      if (createNewLexicalScope === void 0)
        createNewLexicalScope = true;
      if (node === void 0)
        node = this.startNode();
      node.body = [];
      this.expect(types.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node, "BlockStatement");
    };
    pp$1.parseFor = function(node, init) {
      node.init = init;
      this.expect(types.semi);
      node.test = this.type === types.semi ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.type === types.parenR ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    pp$1.parseForIn = function(node, init) {
      var isForIn = this.type === types._in;
      this.next();
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(
          init.start,
          (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        );
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, "Invalid left-hand side in for-loop");
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$1.parseVar = function(node, isFor, kind) {
      node.declarations = [];
      node.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) {
          break;
        }
      }
      return node;
    };
    pp$1.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    FUNC_STATEMENT = 1;
    FUNC_HANGING_STATEMENT = 2;
    FUNC_NULLABLE_ID = 4;
    pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {
          this.unexpected();
        }
        node.generator = this.eat(types.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT) {
        node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
          this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));
      if (!(statement & FUNC_STATEMENT)) {
        node.id = this.type === types.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$1.parseFunctionParams = function(node) {
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$1.parseClass = function(node, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types.braceL);
      while (this.type !== types.braceR) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raise(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node.body = this.finishNode(classBody, "ClassBody");
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$1.parseClassElement = function(constructorAllowsSuper) {
      var this$1 = this;
      if (this.eat(types.semi)) {
        return null;
      }
      var method = this.startNode();
      var tryContextual = function(k, noLineBreak) {
        if (noLineBreak === void 0)
          noLineBreak = false;
        var start = this$1.start, startLoc = this$1.startLoc;
        if (!this$1.eatContextual(k)) {
          return false;
        }
        if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {
          return true;
        }
        if (method.key) {
          this$1.unexpected();
        }
        method.computed = false;
        method.key = this$1.startNodeAt(start, startLoc);
        method.key.name = k;
        this$1.finishNode(method.key, "Identifier");
        return false;
      };
      method.kind = "method";
      method.static = tryContextual("static");
      var isGenerator = this.eat(types.star);
      var isAsync = false;
      if (!isGenerator) {
        if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        } else if (tryContextual("get")) {
          method.kind = "get";
        } else if (tryContextual("set")) {
          method.kind = "set";
        }
      }
      if (!method.key) {
        this.parsePropertyName(method);
      }
      var key = method.key;
      var allowsDirectSuper = false;
      if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (method.kind !== "method") {
          this.raise(key.start, "Constructor can't have get/set modifier");
        }
        if (isGenerator) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
        method.kind = "constructor";
        allowsDirectSuper = constructorAllowsSuper;
      } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && method.value.params.length !== 0) {
        this.raiseRecoverable(method.value.start, "getter should have no params");
      }
      if (method.kind === "set" && method.value.params.length !== 1) {
        this.raiseRecoverable(method.value.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") {
        this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
      }
      return method;
    };
    pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      return this.finishNode(method, "MethodDefinition");
    };
    pp$1.parseClassId = function(node, isStatement) {
      if (this.type === types.name) {
        node.id = this.parseIdent();
        if (isStatement) {
          this.checkLVal(node.id, BIND_LEXICAL, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node.id = null;
      }
    };
    pp$1.parseClassSuper = function(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };
    pp$1.parseExport = function(node, exports) {
      this.next();
      if (this.eat(types.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseIdent(true);
            this.checkExport(exports, node.exported.name, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      if (this.eat(types._default)) {
        this.checkExport(exports, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types._class) {
          var cNode = this.startNode();
          node.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(null);
        if (node.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports, node.declaration.declarations);
        } else {
          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
        }
        node.specifiers = [];
        node.source = null;
      } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
          if (this.type !== types.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
        } else {
          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
            var spec = list[i];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
          }
          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$1.checkExport = function(exports, name, pos) {
      if (!exports) {
        return;
      }
      if (has(exports, name)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
      }
      exports[name] = true;
    };
    pp$1.checkPatternExport = function(exports, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports, pat.name, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i = 0, list = pat.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.checkPatternExport(exports, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];
          if (elt) {
            this.checkPatternExport(exports, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports, pat.argument);
      } else if (type === "ParenthesizedExpression") {
        this.checkPatternExport(exports, pat.expression);
      }
    };
    pp$1.checkVariableExport = function(exports, decls) {
      if (!exports) {
        return;
      }
      for (var i = 0, list = decls; i < list.length; i += 1) {
        var decl = list[i];
        this.checkPatternExport(exports, decl.id);
      }
    };
    pp$1.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$1.parseExportSpecifiers = function(exports) {
      var nodes = [], first = true;
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var node = this.startNode();
        node.local = this.parseIdent(true);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        this.checkExport(exports, node.exported.name, node.exported.start);
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes;
    };
    pp$1.parseImport = function(node) {
      this.next();
      if (this.type === types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    pp$1.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types.name) {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types.comma)) {
          return nodes;
        }
      }
      if (this.type === types.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLVal(node$1.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var node$2 = this.startNode();
        node$2.imported = this.parseIdent(true);
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLVal(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes;
    };
    pp$1.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$1.isDirectiveCandidate = function(statement) {
      return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    pp$2 = Parser.prototype;
    pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
          case "AssignmentPattern":
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node;
    };
    pp$2.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$2.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement");
    };
    pp$2.parseRestBinding = function() {
      var node = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types.name) {
        this.unexpected();
      }
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    };
    pp$2.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }
        if (allowEmpty && this.type === types.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        } else if (this.type === types.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    pp$2.parseBindingListItem = function(param) {
      return param;
    };
    pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
        return left;
      }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };
    pp$2.checkLVal = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "Identifier":
          if (bindingType === BIND_LEXICAL && expr.name === "let") {
            this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
          }
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (checkClashes) {
            if (has(checkClashes, expr.name)) {
              this.raiseRecoverable(expr.start, "Argument name clash");
            }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) {
            this.declareName(expr.name, bindingType, expr.start);
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (bindingType) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLVal(prop, bindingType, checkClashes);
          }
          break;
        case "Property":
          this.checkLVal(expr.value, bindingType, checkClashes);
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLVal(elem, bindingType, checkClashes);
            }
          }
          break;
        case "AssignmentPattern":
          this.checkLVal(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLVal(expr.argument, bindingType, checkClashes);
          break;
        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, bindingType, checkClashes);
          break;
        default:
          this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$3 = Parser.prototype;
    pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name;
      switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$3.parseExpression = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
      if (this.type === types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
        }
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(noIn);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types.parenL || this.type === types.name) {
        this.potentialArrowAt = this.start;
      }
      var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= node.left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(noIn, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    };
    pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.type.binop;
      if (prec != null && (!noIn || this.type !== types._in)) {
        if (prec > minPrec) {
          var logical = this.type === types.logicalOR || this.type === types.logicalAND;
          var coalesce = this.type === types.coalesce;
          if (coalesce) {
            prec = types.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }
      return left;
    };
    pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
        expr = this.parseAwait();
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLVal(node.argument);
        } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
          this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLVal(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }
      if (!sawUnary && this.eat(types.starstar)) {
        return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
      } else {
        return expr;
      }
    };
    pp$3.parseExprSubscripts = function(refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result = this.parseSubscripts(expr, startPos, startLoc);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
      }
      return result;
    };
    pp$3.parseSubscripts = function(base2, startPos, startLoc, noCalls) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base2 || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base2 = element;
      }
    };
    pp$3.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types.bracketL);
      if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base2;
        node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
        node.computed = !!computed;
        if (computed) {
          this.expect(types.bracketR);
        }
        if (optionalSupported) {
          node.optional = optional;
        }
        base2 = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types.parenL)) {
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base2;
        node$1.arguments = exprList;
        if (optionalSupported) {
          node$1.optional = optional;
        }
        base2 = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base2;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base2 = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base2;
    };
    pp$3.parseExprAtom = function(refDestructuringErrors) {
      if (this.type === types.slash) {
        this.readRegexp();
      }
      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
            }
          }
          return id;
        case types.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = { pattern: value.pattern, flags: value.flags };
          return node;
        case types.num:
        case types.string:
          return this.parseLiteral(this.value);
        case types._null:
        case types._true:
        case types._false:
          node = this.startNode();
          node.value = this.type === types._null ? null : this.type === types._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types.braceL:
          return this.parseObj(false, refDestructuringErrors);
        case types._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types._class:
          return this.parseClass(this.startNode(), false);
        case types._new:
          return this.parseNew();
        case types.backQuote:
          return this.parseTemplate();
        case types._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
      }
    };
    pp$3.parseExprImport = function() {
      var node = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      var meta = this.parseIdent(true);
      switch (this.type) {
        case types.parenL:
          return this.parseDynamicImport(node);
        case types.dot:
          node.meta = meta;
          return this.parseImportMeta(node);
        default:
          this.unexpected();
      }
    };
    pp$3.parseDynamicImport = function(node) {
      this.next();
      node.source = this.parseMaybeAssign();
      if (!this.eat(types.parenR)) {
        var errorPos = this.start;
        if (this.eat(types.comma) && this.eat(types.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node, "ImportExpression");
    };
    pp$3.parseImportMeta = function(node) {
      this.next();
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "meta") {
        this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module") {
        this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node, "MetaProperty");
    };
    pp$3.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
        node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node, "Literal");
    };
    pp$3.parseParenExpression = function() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    };
    pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types.parenR) {
          first ? first = false : this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.start, innerEndLoc = this.startLoc;
        this.expect(types.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$3.parseParenItem = function(item) {
      return item;
    };
    pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
    };
    empty$1 = [];
    pp$3.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
        node.meta = meta;
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
        }
        if (!this.inNonArrowFunction()) {
          this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
        }
        return this.finishNode(node, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      if (isImport && node.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types.parenL)) {
        node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node.arguments = empty$1;
      }
      return this.finishNode(node, "NewExpression");
    };
    pp$3.parseTemplateElement = function(ref2) {
      var isTagged = ref2.isTagged;
      var elem = this.startNode();
      if (this.type === types.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$3.parseTemplate = function(ref2) {
      if (ref2 === void 0)
        ref2 = {};
      var isTagged = ref2.isTagged;
      if (isTagged === void 0)
        isTagged = false;
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };
    pp$3.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$3.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        if (this.type === types.parenL && refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0) {
            refDestructuringErrors.parenthesizedAssign = this.start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = this.start;
          }
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        this.parsePropertyName(prop, refDestructuringErrors);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types.colon) {
        this.unexpected();
      }
      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else if (this.type === types.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$3.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$3.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) {
        node.generator = node.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = false;
      }
    };
    pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) {
        node.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression");
    };
    pp$3.parseArrowExpression = function(node, params, isAsync) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
      var isExpression = isArrowFunction && this.type !== types.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        if (this.strict && node.id) {
          this.checkLVal(node.id, BIND_OUTSIDE);
        }
        node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$3.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1) {
        var param = list[i];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$3.checkParams = function(node, allowDuplicates) {
      var nameHash = {};
      for (var i = 0, list = node.params; i < list.length; i += 1) {
        var param = list[i];
        this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };
    pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          }
        } else {
          first = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types.comma) {
          elt = null;
        } else if (this.type === types.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$3.checkUnreserved = function(ref2) {
      var start = ref2.start;
      var end = ref2.end;
      var name = ref2.name;
      if (this.inGenerator && name === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.keywords.test(name)) {
        this.raise(start, "Unexpected keyword '" + name + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name)) {
        if (!this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
      }
    };
    pp$3.parseIdent = function(liberal, isBinding) {
      var node = this.startNode();
      if (this.type === types.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;
        if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next(!!liberal);
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node.start;
        }
      }
      return node;
    };
    pp$3.parseYield = function(noIn) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node = this.startNode();
      this.next();
      if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
      }
      return this.finishNode(node, "YieldExpression");
    };
    pp$3.parseAwait = function() {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, false);
      return this.finishNode(node, "AwaitExpression");
    };
    pp$4 = Parser.prototype;
    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
    };
    pp$5 = Parser.prototype;
    Scope = function Scope2(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
    };
    pp$5.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };
    pp$5.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$5.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$5.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) {
          delete this.undefinedExports[name];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        }
        scope$2.functions.push(name);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name);
          if (this.inModule && scope$3.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
          if (scope$3.flags & SCOPE_VAR) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
      }
    };
    pp$5.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$5.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$5.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };
    pp$5.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };
    Node = function Node2(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) {
        this.loc = new SourceLocation(parser, loc);
      }
      if (parser.options.directSourceFile) {
        this.sourceFile = parser.options.directSourceFile;
      }
      if (parser.options.ranges) {
        this.range = [pos, 0];
      }
    };
    pp$6 = Parser.prototype;
    pp$6.startNode = function() {
      return new Node(this, this.start, this.startLoc);
    };
    pp$6.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc);
    };
    pp$6.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$6.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc);
    };
    TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    types$1 = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function(p) {
        return p.tryReadTemplateToken();
      }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    pp$7 = Parser.prototype;
    pp$7.initialContext = function() {
      return [types$1.b_stat];
    };
    pp$7.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types$1.f_expr || parent === types$1.f_stat) {
        return true;
      }
      if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types._return || prevType === types.name && this.exprAllowed) {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
        return true;
      }
      if (prevType === types.braceL) {
        return parent === types$1.b_stat;
      }
      if (prevType === types._var || prevType === types._const || prevType === types.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$7.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function") {
          return context.generator;
        }
      }
      return false;
    };
    pp$7.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    types.parenR.updateContext = types.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types$1.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    types.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
      this.exprAllowed = true;
    };
    types.dollarBraceL.updateContext = function() {
      this.context.push(types$1.b_tmpl);
      this.exprAllowed = true;
    };
    types.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
      this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
      this.exprAllowed = true;
    };
    types.incDec.updateContext = function() {
    };
    types._function.updateContext = types._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
        this.context.push(types$1.f_expr);
      } else {
        this.context.push(types$1.f_stat);
      }
      this.exprAllowed = false;
    };
    types.backQuote.updateContext = function() {
      if (this.curContext() === types$1.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types$1.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types.star.updateContext = function(prevType) {
      if (prevType === types._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$1.f_expr) {
          this.context[index] = types$1.f_expr_gen;
        } else {
          this.context[index] = types$1.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    ecma11BinaryProperties = ecma10BinaryProperties;
    unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties
    };
    unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues
    };
    data = {};
    buildUnicodeData(9);
    buildUnicodeData(10);
    buildUnicodeData(11);
    pp$8 = Parser.prototype;
    RegExpValidationState = function RegExpValidationState2(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState.prototype.raise = function raise(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState.prototype.at = function at(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1;
      }
      var c = s.charCodeAt(i);
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
        return c;
      }
      var next = s.charCodeAt(i + 1);
      return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l;
      }
      var c = s.charCodeAt(i), next;
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
        return i + 1;
      }
      return i + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
      if (forceU === void 0)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
      if (forceU === void 0)
        forceU = false;
      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    pp$8.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };
    pp$8.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$8.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(41)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(93) || state.eat(125)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name = list[i];
        if (state.groupNames.indexOf(name) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$8.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(124)) {
        this.regexp_alternative(state);
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(123)) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$8.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$8.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$8.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(94) || state.eat(36)) {
        return true;
      }
      if (state.eat(92)) {
        if (state.eat(66) || state.eat(98)) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(40) && state.eat(63)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(60);
        }
        if (state.eat(61) || state.eat(33)) {
          this.regexp_disjunction(state);
          if (!state.eat(41)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$8.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(63);
        return true;
      }
      return false;
    };
    pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$8.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(123)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(125)) {
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(40)) {
        if (state.eat(63) && state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatCapturingGroup = function(state) {
      if (state.eat(40)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$8.regexp_eatExtendedAtom = function(state) {
      return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$8.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$8.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_groupSpecifier = function(state) {
      if (state.eat(63)) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return;
        }
        state.raise("Invalid group");
      }
    };
    pp$8.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$8.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$8.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$8.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$8.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$8.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
          if (n > state.maxBackReference) {
            state.maxBackReference = n;
          }
          return true;
        }
        if (n <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatKGroupName = function(state) {
      if (state.eat(107)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$8.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$8.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(99)) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(117)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(47)) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch = state.current();
      if (ch !== 99 && (!state.switchN || ch !== 107)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 49 && ch <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        } while ((ch = state.current()) >= 48 && ch <= 57);
        return true;
      }
      return false;
    };
    pp$8.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();
      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
      }
      if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
          return true;
        }
        state.raise("Invalid property name");
      }
      return false;
    };
    pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return true;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
      }
      return false;
    };
    pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!has(state.unicodeProperties.nonBinary, name)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name].test(value)) {
        state.raise("Invalid property value");
      }
    };
    pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue)) {
        state.raise("Invalid property name");
      }
    };
    pp$8.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$8.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$8.regexp_eatCharacterClass = function(state) {
      if (state.eat(91)) {
        state.eat(94);
        this.regexp_classRanges(state);
        if (state.eat(93)) {
          return true;
        }
        state.raise("Unterminated character class");
      }
      return false;
    };
    pp$8.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(45) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$8.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch = state.current();
      if (ch !== 93) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(45)) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(99)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$8.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 95) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(120)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$8.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$8.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    pp$8.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true;
    };
    Token = function Token2(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations) {
        this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
      }
      if (p.options.ranges) {
        this.range = [p.start, p.end];
      }
    };
    pp$9 = Parser.prototype;
    pp$9.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp$9.getToken = function() {
      this.next();
      return new Token(this);
    };
    if (typeof Symbol !== "undefined") {
      pp$9[Symbol.iterator] = function() {
        var this$1 = this;
        return {
          next: function() {
            var token = this$1.getToken();
            return {
              done: token.type === types.eof,
              value: token
            };
          }
        };
      };
    }
    pp$9.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$9.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp$9.readToken = function(code) {
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp$9.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 57344) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return (code << 10) + next - 56613888;
    };
    pp$9.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match;
        while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
          ++this.curLine;
          this.lineStart = match.index + match[0].length;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(
          true,
          this.input.slice(start + 2, end),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp$9.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(
          false,
          this.input.slice(start + startSkip, this.pos),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp$9.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp$9.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp$9.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types.dot);
      }
    };
    pp$9.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(types.slash, 1);
    };
    pp$9.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types.star : types.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp$9.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    };
    pp$9.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(types.bitwiseXOR, 1);
    };
    pp$9.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(types.plusMin, 1);
    };
    pp$9.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types.assign, size + 1);
        }
        return this.finishOp(types.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types.relational, size);
    };
    pp$9.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types.arrow);
      }
      return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
    };
    pp$9.readToken_question = function() {
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types.assign, 3);
            }
          }
          return this.finishOp(types.coalesce, 2);
        }
      }
      return this.finishOp(types.question, 1);
    };
    pp$9.getTokenFromCode = function(code) {
      switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types.prefix, 1);
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
    };
    pp$9.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp$9.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped) {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }
          escaped = ch === "\\";
        } else {
          escaped = false;
        }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e) {
      }
      return this.finishToken(types.regexp, { pattern, flags, value });
    };
    pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    pp$9.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types.num, val);
    };
    pp$9.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types.num, val);
    };
    pp$9.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    pp$9.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) {
          break;
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else {
          if (isNewLine(ch, this.options.ecmaVersion >= 10)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types.string, out);
    };
    INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp$9.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp$9.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR;
      } else {
        this.raise(position, message);
      }
    };
    pp$9.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types.template, out);
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp$9.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp$9.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString$1(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(
              codePos,
              "Invalid escape sequence in template string"
            );
            return null;
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(
                this.pos - 1 - octalStr.length,
                inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
              );
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
      }
    };
    pp$9.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n;
    };
    pp$9.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString$1(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp$9.readWord = function() {
      var word = this.readWord1();
      var type = types.name;
      if (this.keywords.test(word)) {
        type = keywords$1[word];
      }
      return this.finishToken(type, word);
    };
    version = "7.4.1";
    Parser.acorn = {
      Parser,
      version,
      defaultOptions,
      Position,
      SourceLocation,
      getLineInfo,
      Node,
      TokenType,
      tokTypes: types,
      keywordTypes: keywords$1,
      TokContext,
      tokContexts: types$1,
      isIdentifierChar,
      isIdentifierStart,
      Token,
      isNewLine,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace
    };
  }
});

// node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/immutable.js"(exports, module2) {
    module2.exports = extend2;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function extend2() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/bigint/index.js
var require_bigint = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/bigint/index.js"(exports, module2) {
    "use strict";
    var acorn = (init_acorn(), __toCommonJS(acorn_exports));
    var tt = acorn.tokTypes;
    var isIdentifierStart2 = acorn.isIdentifierStart;
    module2.exports = function(Parser3) {
      return /* @__PURE__ */ function(Parser4) {
        function anonymous() {
          Parser4.apply(this, arguments);
        }
        if (Parser4)
          anonymous.__proto__ = Parser4;
        anonymous.prototype = Object.create(Parser4 && Parser4.prototype);
        anonymous.prototype.constructor = anonymous;
        anonymous.prototype.parseLiteral = function parseLiteral(value) {
          var node = Parser4.prototype.parseLiteral.call(this, value);
          if (node.raw.charCodeAt(node.raw.length - 1) == 110) {
            node.bigint = this.getNumberInput(node.start, node.end);
          }
          return node;
        };
        anonymous.prototype.readRadixNumber = function readRadixNumber(radix) {
          var start = this.pos;
          this.pos += 2;
          var val = this.readInt(radix);
          if (val === null) {
            this.raise(this.start + 2, "Expected number in radix " + radix);
          }
          if (this.input.charCodeAt(this.pos) == 110) {
            var str = this.getNumberInput(start, this.pos);
            val = typeof BigInt !== "undefined" ? BigInt(str) : null;
            ++this.pos;
          } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(tt.num, val);
        };
        anonymous.prototype.readNumber = function readNumber(startsWithDot) {
          var start = this.pos;
          if (startsWithDot) {
            return Parser4.prototype.readNumber.call(this, startsWithDot);
          }
          if (this.input.charCodeAt(start) === 48 && this.input.charCodeAt(start + 1) !== 110) {
            return Parser4.prototype.readNumber.call(this, startsWithDot);
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
          if (this.input.charCodeAt(this.pos) != 110) {
            this.pos = start;
            return Parser4.prototype.readNumber.call(this, startsWithDot);
          }
          var str = this.getNumberInput(start, this.pos);
          var val = typeof BigInt !== "undefined" ? BigInt(str) : null;
          ++this.pos;
          return this.finishToken(tt.num, val);
        };
        anonymous.prototype.getNumberInput = function getNumberInput(start, end) {
          if (Parser4.prototype.getNumberInput) {
            return Parser4.prototype.getNumberInput.call(this, start, end);
          }
          return this.input.slice(start, end);
        };
        return anonymous;
      }(Parser3);
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/private-class-elements/index.js
var require_private_class_elements = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/private-class-elements/index.js"(exports, module2) {
    "use strict";
    var acorn = (init_acorn(), __toCommonJS(acorn_exports));
    if (false) {
      throw new Error("acorn-private-class-elements requires acorn@^6.1.0, not " + acorn.version);
    }
    var tt = acorn.tokTypes;
    var TokenType3 = acorn.TokenType;
    module2.exports = function(Parser3) {
      if (Parser3.prototype.parsePrivateName) {
        return Parser3;
      }
      var cur = Parser3;
      while (cur && cur !== acorn.Parser) {
        cur = cur.__proto__;
      }
      if (cur !== acorn.Parser) {
        throw new Error("acorn-private-class-elements does not support mixing different acorn copies");
      }
      Parser3 = /* @__PURE__ */ function(Parser4) {
        function Parser_() {
          Parser4.apply(this, arguments);
        }
        if (Parser4)
          Parser_.__proto__ = Parser4;
        Parser_.prototype = Object.create(Parser4 && Parser4.prototype);
        Parser_.prototype.constructor = Parser_;
        Parser_.prototype._branch = function _branch() {
          this.__branch = this.__branch || new Parser4({ ecmaVersion: this.options.ecmaVersion }, this.input);
          this.__branch.end = this.end;
          this.__branch.pos = this.pos;
          this.__branch.type = this.type;
          this.__branch.value = this.value;
          this.__branch.containsEsc = this.containsEsc;
          return this.__branch;
        };
        Parser_.prototype.parsePrivateClassElementName = function parsePrivateClassElementName(element) {
          element.computed = false;
          element.key = this.parsePrivateName();
          if (element.key.name == "constructor") {
            this.raise(element.key.start, "Classes may not have a private element named constructor");
          }
          var accept = { get: "set", set: "get" }[element.kind];
          var privateBoundNames = this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1];
          if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) {
            this.raise(element.start, "Duplicate private element");
          }
          privateBoundNames[element.key.name] = element.kind || true;
          delete this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][element.key.name];
          return element.key;
        };
        Parser_.prototype.parsePrivateName = function parsePrivateName() {
          var node = this.startNode();
          node.name = this.value;
          this.next();
          this.finishNode(node, "PrivateName");
          if (this.options.allowReserved == "never") {
            this.checkUnreserved(node);
          }
          return node;
        };
        Parser_.prototype.getTokenFromCode = function getTokenFromCode(code) {
          if (code === 35) {
            ++this.pos;
            var word = this.readWord1();
            return this.finishToken(this.privateNameToken, word);
          }
          return Parser4.prototype.getTokenFromCode.call(this, code);
        };
        Parser_.prototype.parseClass = function parseClass(node, isStatement) {
          this._privateBoundNamesStack = this._privateBoundNamesStack || [];
          var privateBoundNames = Object.create(this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1] || null);
          this._privateBoundNamesStack.push(privateBoundNames);
          this._unresolvedPrivateNamesStack = this._unresolvedPrivateNamesStack || [];
          var unresolvedPrivateNames = /* @__PURE__ */ Object.create(null);
          this._unresolvedPrivateNamesStack.push(unresolvedPrivateNames);
          var _return = Parser4.prototype.parseClass.call(this, node, isStatement);
          this._privateBoundNamesStack.pop();
          this._unresolvedPrivateNamesStack.pop();
          if (!this._unresolvedPrivateNamesStack.length) {
            var names = Object.keys(unresolvedPrivateNames);
            if (names.length) {
              names.sort(function(n1, n2) {
                return unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2];
              });
              this.raise(unresolvedPrivateNames[names[0]], "Usage of undeclared private name");
            }
          } else {
            Object.assign(this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1], unresolvedPrivateNames);
          }
          return _return;
        };
        Parser_.prototype.parseSubscript = function parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow) {
          if (!this.eat(tt.dot)) {
            return Parser4.prototype.parseSubscript.call(this, base2, startPos, startLoc, noCalls, maybeAsyncArrow);
          }
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base2;
          node.computed = false;
          if (this.type == this.privateNameToken) {
            node.property = this.parsePrivateName();
            if (!this._privateBoundNamesStack.length || !this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1][node.property.name]) {
              this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][node.property.name] = node.property.start;
            }
          } else {
            node.property = this.parseIdent(true);
          }
          return this.finishNode(node, "MemberExpression");
        };
        Parser_.prototype.parseMaybeUnary = function parseMaybeUnary(refDestructuringErrors, sawUnary) {
          var _return = Parser4.prototype.parseMaybeUnary.call(this, refDestructuringErrors, sawUnary);
          if (_return.operator == "delete") {
            if (_return.argument.type == "MemberExpression" && _return.argument.property.type == "PrivateName") {
              this.raise(_return.start, "Private elements may not be deleted");
            }
          }
          return _return;
        };
        return Parser_;
      }(Parser3);
      Parser3.prototype.privateNameToken = new TokenType3("privateName");
      return Parser3;
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/class-fields/index.js
var require_class_fields = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/class-fields/index.js"(exports, module2) {
    "use strict";
    var acorn = (init_acorn(), __toCommonJS(acorn_exports));
    var tt = acorn.tokTypes;
    var privateClassElements = require_private_class_elements();
    function maybeParseFieldValue(field) {
      if (this.eat(tt.eq)) {
        var oldInFieldValue = this._inFieldValue;
        this._inFieldValue = true;
        field.value = this.parseExpression();
        this._inFieldValue = oldInFieldValue;
      } else {
        field.value = null;
      }
    }
    module2.exports = function(Parser3) {
      Parser3 = privateClassElements(Parser3);
      return /* @__PURE__ */ function(Parser4) {
        function anonymous() {
          Parser4.apply(this, arguments);
        }
        if (Parser4)
          anonymous.__proto__ = Parser4;
        anonymous.prototype = Object.create(Parser4 && Parser4.prototype);
        anonymous.prototype.constructor = anonymous;
        anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {
          if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {
            var branch = this._branch();
            if (branch.type == tt.bracketL) {
              var count = 0;
              do {
                if (branch.eat(tt.bracketL)) {
                  ++count;
                } else if (branch.eat(tt.bracketR)) {
                  --count;
                } else {
                  branch.next();
                }
              } while (count > 0);
            } else {
              branch.next();
            }
            if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {
              var node = this.startNode();
              if (this.type == this.privateNameToken) {
                this.parsePrivateClassElementName(node);
              } else {
                this.parsePropertyName(node);
              }
              if (node.key.type === "Identifier" && node.key.name === "constructor" || node.key.type === "Literal" && node.key.value === "constructor") {
                this.raise(node.key.start, "Classes may not have a field called constructor");
              }
              maybeParseFieldValue.call(this, node);
              this.finishNode(node, "FieldDefinition");
              this.semicolon();
              return node;
            }
          }
          return Parser4.prototype.parseClassElement.apply(this, arguments);
        };
        anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {
          var ident = Parser4.prototype.parseIdent.call(this, liberal, isBinding);
          if (this._inFieldValue && ident.name == "arguments") {
            this.raise(ident.start, "A class field initializer may not contain arguments");
          }
          return ident;
        };
        return anonymous;
      }(Parser3);
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/static-class-features/index.js
var require_static_class_features = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/static-class-features/index.js"(exports, module2) {
    "use strict";
    var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var acorn = (init_acorn(), __toCommonJS(acorn_exports));
    var tt = acorn.tokTypes;
    function maybeParseFieldValue(field) {
      if (this.eat(tt.eq)) {
        var oldInFieldValue = this._inStaticFieldValue;
        this._inStaticFieldValue = true;
        field.value = this.parseExpression();
        this._inStaticFieldValue = oldInFieldValue;
      } else {
        field.value = null;
      }
    }
    var privateClassElements = require_private_class_elements();
    module2.exports = function(Parser3) {
      var ExtendedParser = privateClassElements(Parser3);
      return /* @__PURE__ */ function(ExtendedParser2) {
        function anonymous() {
          ExtendedParser2.apply(this, arguments);
        }
        if (ExtendedParser2)
          anonymous.__proto__ = ExtendedParser2;
        anonymous.prototype = Object.create(ExtendedParser2 && ExtendedParser2.prototype);
        anonymous.prototype.constructor = anonymous;
        anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {
          var this$1 = this;
          if (this.eat(tt.semi)) {
            return null;
          }
          var node = this.startNode();
          var tryContextual = function(k, noLineBreak) {
            if (typeof noLineBreak == "undefined") {
              noLineBreak = false;
            }
            var start = this$1.start, startLoc = this$1.startLoc;
            if (!this$1.eatContextual(k)) {
              return false;
            }
            if (this$1.type !== tt.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {
              return true;
            }
            if (node.key) {
              this$1.unexpected();
            }
            node.computed = false;
            node.key = this$1.startNodeAt(start, startLoc);
            node.key.name = k;
            this$1.finishNode(node.key, "Identifier");
            return false;
          };
          node.static = tryContextual("static");
          if (!node.static) {
            return ExtendedParser2.prototype.parseClassElement.apply(this, arguments);
          }
          var isGenerator = this.eat(tt.star);
          var isAsync = false;
          if (!isGenerator) {
            if (this.options.ecmaVersion >= 8 && this.isContextual("async")) {
              skipWhiteSpace2.lastIndex = this.pos;
              var skip = skipWhiteSpace2.exec(this.input);
              var next = this.input.charAt(this.pos + skip[0].length);
              if (next === ";" || next === "=") {
                node.key = this.parseIdent(true);
                node.computed = false;
                maybeParseFieldValue.call(this, node);
                this.finishNode(node, "FieldDefinition");
                this.semicolon();
                return node;
              } else if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
                isAsync = true;
                isGenerator = this.options.ecmaVersion >= 9 && this.eat(tt.star);
              }
            } else if (tryContextual("get")) {
              node.kind = "get";
            } else if (tryContextual("set")) {
              node.kind = "set";
            }
          }
          if (this.type === this.privateNameToken) {
            this.parsePrivateClassElementName(node);
            if (this.type !== tt.parenL) {
              if (node.key.name === "prototype") {
                this.raise(node.key.start, "Classes may not have a private static property named prototype");
              }
              maybeParseFieldValue.call(this, node);
              this.finishNode(node, "FieldDefinition");
              this.semicolon();
              return node;
            }
          } else if (!node.key) {
            this.parsePropertyName(node);
            if ((node.key.name || node.key.value) === "prototype" && !node.computed) {
              this.raise(node.key.start, "Classes may not have a static property named prototype");
            }
          }
          if (!node.kind) {
            node.kind = "method";
          }
          this.parseClassMethod(node, isGenerator, isAsync);
          if (!node.kind && (node.key.name || node.key.value) === "constructor" && !node.computed) {
            this.raise(node.key.start, "Classes may not have a static field named constructor");
          }
          if (node.kind === "get" && node.value.params.length !== 0) {
            this.raiseRecoverable(node.value.start, "getter should have no params");
          }
          if (node.kind === "set" && node.value.params.length !== 1) {
            this.raiseRecoverable(node.value.start, "setter should have exactly one param");
          }
          if (node.kind === "set" && node.value.params[0].type === "RestElement") {
            this.raiseRecoverable(node.value.params[0].start, "Setter cannot use rest params");
          }
          return node;
        };
        anonymous.prototype.parseClassMethod = function parseClassMethod(method, isGenerator, isAsync, _allowsDirectSuper) {
          if (isGenerator || isAsync || method.kind != "method" || !method.static || this.options.ecmaVersion < 8 || this.type == tt.parenL) {
            return ExtendedParser2.prototype.parseClassMethod.apply(this, arguments);
          }
          maybeParseFieldValue.call(this, method);
          delete method.kind;
          method = this.finishNode(method, "FieldDefinition");
          this.semicolon();
          return method;
        };
        anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {
          var ident = ExtendedParser2.prototype.parseIdent.call(this, liberal, isBinding);
          if (this._inStaticFieldValue && ident.name == "arguments") {
            this.raise(ident.start, "A static class field initializer may not contain arguments");
          }
          return ident;
        };
        return anonymous;
      }(ExtendedParser);
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/numeric-separator/index.js
var require_numeric_separator = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/numeric-separator/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(Parser3) {
      return /* @__PURE__ */ function(Parser4) {
        function anonymous() {
          Parser4.apply(this, arguments);
        }
        if (Parser4)
          anonymous.__proto__ = Parser4;
        anonymous.prototype = Object.create(Parser4 && Parser4.prototype);
        anonymous.prototype.constructor = anonymous;
        anonymous.prototype.readInt = function readInt(radix, len) {
          if (len != null) {
            return Parser4.prototype.readInt.call(this, radix, len);
          }
          var start = this.pos, total = 0, acceptUnderscore = false;
          for (; ; ) {
            var code = this.input.charCodeAt(this.pos), val = void 0;
            if (code >= 97) {
              val = code - 97 + 10;
            } else if (code == 95) {
              if (!acceptUnderscore) {
                this.raise(this.pos, "Invalid numeric separator");
              }
              ++this.pos;
              acceptUnderscore = false;
              continue;
            } else if (code >= 65) {
              val = code - 65 + 10;
            } else if (code >= 48 && code <= 57) {
              val = code - 48;
            } else {
              val = Infinity;
            }
            if (val >= radix) {
              break;
            }
            ++this.pos;
            total = total * radix + val;
            acceptUnderscore = true;
          }
          if (this.pos === start) {
            return null;
          }
          if (!acceptUnderscore) {
            this.raise(this.pos - 1, "Invalid numeric separator");
          }
          return total;
        };
        anonymous.prototype.readNumber = function readNumber(startsWithDot) {
          var token = Parser4.prototype.readNumber.call(this, startsWithDot);
          var octal = this.end - this.start >= 2 && this.input.charCodeAt(this.start) === 48;
          var stripped = this.getNumberInput(this.start, this.end);
          if (stripped.length < this.end - this.start) {
            if (octal) {
              this.raise(this.start, "Invalid number");
            }
            this.value = parseFloat(stripped);
          }
          return token;
        };
        anonymous.prototype.getNumberInput = function getNumberInput(start, end) {
          return this.input.slice(start, end).replace(/_/g, "");
        };
        return anonymous;
      }(Parser3);
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/dynamic-import/index.js
var require_dynamic_import = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/dynamic-import/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DynamicImportKey = void 0;
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) {
            descriptor.writable = true;
          }
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) {
          defineProperties(Constructor.prototype, protoProps);
        }
        if (staticProps) {
          defineProperties(Constructor, staticProps);
        }
        return Constructor;
      };
    }();
    var _get = function() {
      function get(object, property, receiver) {
        if (object === null) {
          object = Function.prototype;
        }
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === void 0) {
          var parent = Object.getPrototypeOf(object);
          if (parent === null) {
            return void 0;
          } else {
            return get(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === void 0) {
            return void 0;
          }
          return getter.call(receiver);
        }
      }
      return get;
    }();
    exports["default"] = dynamicImport;
    var _acorn = (init_acorn(), __toCommonJS(acorn_exports));
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) {
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
    }
    var DynamicImportKey = exports.DynamicImportKey = "Import";
    _acorn.tokTypes._import.startsExpr = true;
    function parseDynamicImport() {
      var node = this.startNode();
      this.next();
      if (this.type !== _acorn.tokTypes.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, DynamicImportKey);
    }
    function parenAfter() {
      return /^(\s|\/\/.*|\/\*[^]*?\*\/)*\(/.test(this.input.slice(this.pos));
    }
    function dynamicImport(Parser3) {
      return function(_Parser) {
        _inherits(_class, _Parser);
        function _class() {
          _classCallCheck(this, _class);
          return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }
        _createClass(_class, [{
          key: "parseStatement",
          value: function() {
            function parseStatement(context, topLevel, exports2) {
              if (this.type === _acorn.tokTypes._import && parenAfter.call(this)) {
                return this.parseExpressionStatement(this.startNode(), this.parseExpression());
              }
              return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "parseStatement", this).call(this, context, topLevel, exports2);
            }
            return parseStatement;
          }()
        }, {
          key: "parseExprAtom",
          value: function() {
            function parseExprAtom(refDestructuringErrors) {
              if (this.type === _acorn.tokTypes._import) {
                return parseDynamicImport.call(this);
              }
              return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "parseExprAtom", this).call(this, refDestructuringErrors);
            }
            return parseExprAtom;
          }()
        }]);
        return _class;
      }(Parser3);
    }
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/export-ns-from/index.js
var require_export_ns_from = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/export-ns-from/index.js"(exports, module2) {
    "use strict";
    var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var tt = (init_acorn(), __toCommonJS(acorn_exports)).tokTypes;
    module2.exports = function(Parser3) {
      return /* @__PURE__ */ function(Parser4) {
        function anonymous() {
          Parser4.apply(this, arguments);
        }
        if (Parser4)
          anonymous.__proto__ = Parser4;
        anonymous.prototype = Object.create(Parser4 && Parser4.prototype);
        anonymous.prototype.constructor = anonymous;
        anonymous.prototype.parseExport = function parseExport(node, exports2) {
          skipWhiteSpace2.lastIndex = this.pos;
          var skip = skipWhiteSpace2.exec(this.input);
          var next = this.input.charAt(this.pos + skip[0].length);
          if (next !== "*") {
            return Parser4.prototype.parseExport.call(this, node, exports2);
          }
          this.next();
          var specifier = this.startNode();
          this.expect(tt.star);
          if (this.eatContextual("as")) {
            node.declaration = null;
            specifier.exported = this.parseIdent(true);
            this.checkExport(exports2, specifier.exported.name, this.lastTokStart);
            node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
          }
          this.expectContextual("from");
          if (this.type !== tt.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node, node.specifiers ? "ExportNamedDeclaration" : "ExportAllDeclaration");
        };
        return anonymous;
      }(Parser3);
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/import-meta/index.js
var require_import_meta = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/lib/import-meta/index.js"(exports, module2) {
    "use strict";
    var tt = (init_acorn(), __toCommonJS(acorn_exports)).tokTypes;
    var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var nextTokenIsDot = function(parser) {
      skipWhiteSpace2.lastIndex = parser.pos;
      var skip = skipWhiteSpace2.exec(parser.input);
      var next = parser.pos + skip[0].length;
      return parser.input.slice(next, next + 1) === ".";
    };
    module2.exports = function(Parser3) {
      return /* @__PURE__ */ function(Parser4) {
        function anonymous() {
          Parser4.apply(this, arguments);
        }
        if (Parser4)
          anonymous.__proto__ = Parser4;
        anonymous.prototype = Object.create(Parser4 && Parser4.prototype);
        anonymous.prototype.constructor = anonymous;
        anonymous.prototype.parseExprAtom = function parseExprAtom(refDestructuringErrors) {
          if (this.type !== tt._import || !nextTokenIsDot(this)) {
            return Parser4.prototype.parseExprAtom.call(this, refDestructuringErrors);
          }
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
          var node = this.startNode();
          node.meta = this.parseIdent(true);
          this.expect(tt.dot);
          node.property = this.parseIdent(true);
          if (node.property.name !== "meta") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for import is import.meta");
          }
          return this.finishNode(node, "MetaProperty");
        };
        anonymous.prototype.parseStatement = function parseStatement(context, topLevel, exports2) {
          if (this.type !== tt._import || !nextTokenIsDot(this)) {
            return Parser4.prototype.parseStatement.call(this, context, topLevel, exports2);
          }
          var node = this.startNode();
          var expr = this.parseExpression();
          return this.parseExpressionStatement(node, expr);
        };
        return anonymous;
      }(Parser3);
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/index.js
var require_acorn_node = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/index.js"(exports, module2) {
    var acorn = (init_acorn(), __toCommonJS(acorn_exports));
    var xtend = require_immutable();
    var CJSParser = acorn.Parser.extend(require_bigint()).extend(require_class_fields()).extend(require_static_class_features()).extend(require_numeric_separator()).extend(require_dynamic_import().default);
    var ESModulesParser = CJSParser.extend(require_export_ns_from()).extend(require_import_meta());
    function mapOptions(opts) {
      if (!opts)
        opts = {};
      return xtend({
        ecmaVersion: 2020,
        allowHashBang: true,
        allowReturnOutsideFunction: true
      }, opts);
    }
    function getParser(opts) {
      if (!opts)
        opts = {};
      return opts.sourceType === "module" ? ESModulesParser : CJSParser;
    }
    module2.exports = exports = xtend(acorn, {
      parse: function parse4(src, opts) {
        return getParser(opts).parse(src, mapOptions(opts));
      },
      parseExpressionAt: function parseExpressionAt3(src, offset2, opts) {
        return getParser(opts).parseExpressionAt(src, offset2, mapOptions(opts));
      },
      tokenizer: function tokenizer3(src, opts) {
        return getParser(opts).tokenizer(src, mapOptions(opts));
      }
    });
  }
});

// node_modules/.pnpm/acorn-walk@7.2.0/node_modules/acorn-walk/dist/walk.mjs
var walk_exports = {};
__export(walk_exports, {
  ancestor: () => ancestor,
  base: () => base,
  findNodeAfter: () => findNodeAfter,
  findNodeAround: () => findNodeAround,
  findNodeAt: () => findNodeAt,
  findNodeBefore: () => findNodeBefore,
  full: () => full,
  fullAncestor: () => fullAncestor,
  make: () => make,
  recursive: () => recursive,
  simple: () => simple
});
function simple(node, visitors, baseVisitor, state, override) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c(node2, st, override2) {
    var type = override2 || node2.type, found = visitors[type];
    baseVisitor[type](node2, st, c);
    if (found) {
      found(node2, st);
    }
  })(node, state, override);
}
function ancestor(node, visitors, baseVisitor, state, override) {
  var ancestors = [];
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c(node2, st, override2) {
    var type = override2 || node2.type, found = visitors[type];
    var isNew = node2 !== ancestors[ancestors.length - 1];
    if (isNew) {
      ancestors.push(node2);
    }
    baseVisitor[type](node2, st, c);
    if (found) {
      found(node2, st || ancestors, ancestors);
    }
    if (isNew) {
      ancestors.pop();
    }
  })(node, state, override);
}
function recursive(node, state, funcs, baseVisitor, override) {
  var visitor = funcs ? make(funcs, baseVisitor || void 0) : baseVisitor;
  (function c(node2, st, override2) {
    visitor[override2 || node2.type](node2, st, c);
  })(node, state, override);
}
function makeTest(test) {
  if (typeof test === "string") {
    return function(type) {
      return type === test;
    };
  } else if (!test) {
    return function() {
      return true;
    };
  } else {
    return test;
  }
}
function full(node, callback, baseVisitor, state, override) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c(node2, st, override2) {
    var type = override2 || node2.type;
    baseVisitor[type](node2, st, c);
    if (!override2) {
      callback(node2, st, type);
    }
  })(node, state, override);
}
function fullAncestor(node, callback, baseVisitor, state) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  var ancestors = [];
  (function c(node2, st, override) {
    var type = override || node2.type;
    var isNew = node2 !== ancestors[ancestors.length - 1];
    if (isNew) {
      ancestors.push(node2);
    }
    baseVisitor[type](node2, st, c);
    if (!override) {
      callback(node2, st || ancestors, ancestors, type);
    }
    if (isNew) {
      ancestors.pop();
    }
  })(node, state);
}
function findNodeAt(node, start, end, test, baseVisitor, state) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  test = makeTest(test);
  try {
    (function c(node2, st, override) {
      var type = override || node2.type;
      if ((start == null || node2.start <= start) && (end == null || node2.end >= end)) {
        baseVisitor[type](node2, st, c);
      }
      if ((start == null || node2.start === start) && (end == null || node2.end === end) && test(type, node2)) {
        throw new Found(node2, st);
      }
    })(node, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }
    throw e;
  }
}
function findNodeAround(node, pos, test, baseVisitor, state) {
  test = makeTest(test);
  if (!baseVisitor) {
    baseVisitor = base;
  }
  try {
    (function c(node2, st, override) {
      var type = override || node2.type;
      if (node2.start > pos || node2.end < pos) {
        return;
      }
      baseVisitor[type](node2, st, c);
      if (test(type, node2)) {
        throw new Found(node2, st);
      }
    })(node, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }
    throw e;
  }
}
function findNodeAfter(node, pos, test, baseVisitor, state) {
  test = makeTest(test);
  if (!baseVisitor) {
    baseVisitor = base;
  }
  try {
    (function c(node2, st, override) {
      if (node2.end < pos) {
        return;
      }
      var type = override || node2.type;
      if (node2.start >= pos && test(type, node2)) {
        throw new Found(node2, st);
      }
      baseVisitor[type](node2, st, c);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }
    throw e;
  }
}
function findNodeBefore(node, pos, test, baseVisitor, state) {
  test = makeTest(test);
  if (!baseVisitor) {
    baseVisitor = base;
  }
  var max;
  (function c(node2, st, override) {
    if (node2.start > pos) {
      return;
    }
    var type = override || node2.type;
    if (node2.end <= pos && (!max || max.node.end < node2.end) && test(type, node2)) {
      max = new Found(node2, st);
    }
    baseVisitor[type](node2, st, c);
  })(node, state);
  return max;
}
function make(funcs, baseVisitor) {
  var visitor = create(baseVisitor || base);
  for (var type in funcs) {
    visitor[type] = funcs[type];
  }
  return visitor;
}
function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {
}
var Found, create, base;
var init_walk = __esm({
  "node_modules/.pnpm/acorn-walk@7.2.0/node_modules/acorn-walk/dist/walk.mjs"() {
    Found = function Found2(node, state) {
      this.node = node;
      this.state = state;
    };
    create = Object.create || function(proto) {
      function Ctor() {
      }
      Ctor.prototype = proto;
      return new Ctor();
    };
    base = {};
    base.Program = base.BlockStatement = function(node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1) {
        var stmt = list[i];
        c(stmt, st, "Statement");
      }
    };
    base.Statement = skipThrough;
    base.EmptyStatement = ignore;
    base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
      return c(node.expression, st, "Expression");
    };
    base.IfStatement = function(node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Statement");
      if (node.alternate) {
        c(node.alternate, st, "Statement");
      }
    };
    base.LabeledStatement = function(node, st, c) {
      return c(node.body, st, "Statement");
    };
    base.BreakStatement = base.ContinueStatement = ignore;
    base.WithStatement = function(node, st, c) {
      c(node.object, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.SwitchStatement = function(node, st, c) {
      c(node.discriminant, st, "Expression");
      for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
        var cs = list$1[i$1];
        if (cs.test) {
          c(cs.test, st, "Expression");
        }
        for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      }
    };
    base.SwitchCase = function(node, st, c) {
      if (node.test) {
        c(node.test, st, "Expression");
      }
      for (var i = 0, list = node.consequent; i < list.length; i += 1) {
        var cons = list[i];
        c(cons, st, "Statement");
      }
    };
    base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
      if (node.argument) {
        c(node.argument, st, "Expression");
      }
    };
    base.ThrowStatement = base.SpreadElement = function(node, st, c) {
      return c(node.argument, st, "Expression");
    };
    base.TryStatement = function(node, st, c) {
      c(node.block, st, "Statement");
      if (node.handler) {
        c(node.handler, st);
      }
      if (node.finalizer) {
        c(node.finalizer, st, "Statement");
      }
    };
    base.CatchClause = function(node, st, c) {
      if (node.param) {
        c(node.param, st, "Pattern");
      }
      c(node.body, st, "Statement");
    };
    base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
      c(node.test, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForStatement = function(node, st, c) {
      if (node.init) {
        c(node.init, st, "ForInit");
      }
      if (node.test) {
        c(node.test, st, "Expression");
      }
      if (node.update) {
        c(node.update, st, "Expression");
      }
      c(node.body, st, "Statement");
    };
    base.ForInStatement = base.ForOfStatement = function(node, st, c) {
      c(node.left, st, "ForInit");
      c(node.right, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForInit = function(node, st, c) {
      if (node.type === "VariableDeclaration") {
        c(node, st);
      } else {
        c(node, st, "Expression");
      }
    };
    base.DebuggerStatement = ignore;
    base.FunctionDeclaration = function(node, st, c) {
      return c(node, st, "Function");
    };
    base.VariableDeclaration = function(node, st, c) {
      for (var i = 0, list = node.declarations; i < list.length; i += 1) {
        var decl = list[i];
        c(decl, st);
      }
    };
    base.VariableDeclarator = function(node, st, c) {
      c(node.id, st, "Pattern");
      if (node.init) {
        c(node.init, st, "Expression");
      }
    };
    base.Function = function(node, st, c) {
      if (node.id) {
        c(node.id, st, "Pattern");
      }
      for (var i = 0, list = node.params; i < list.length; i += 1) {
        var param = list[i];
        c(param, st, "Pattern");
      }
      c(node.body, st, node.expression ? "Expression" : "Statement");
    };
    base.Pattern = function(node, st, c) {
      if (node.type === "Identifier") {
        c(node, st, "VariablePattern");
      } else if (node.type === "MemberExpression") {
        c(node, st, "MemberPattern");
      } else {
        c(node, st);
      }
    };
    base.VariablePattern = ignore;
    base.MemberPattern = skipThrough;
    base.RestElement = function(node, st, c) {
      return c(node.argument, st, "Pattern");
    };
    base.ArrayPattern = function(node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Pattern");
        }
      }
    };
    base.ObjectPattern = function(node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];
        if (prop.type === "Property") {
          if (prop.computed) {
            c(prop.key, st, "Expression");
          }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };
    base.Expression = skipThrough;
    base.ThisExpression = base.Super = base.MetaProperty = ignore;
    base.ArrayExpression = function(node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Expression");
        }
      }
    };
    base.ObjectExpression = function(node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];
        c(prop, st);
      }
    };
    base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
    base.SequenceExpression = function(node, st, c) {
      for (var i = 0, list = node.expressions; i < list.length; i += 1) {
        var expr = list[i];
        c(expr, st, "Expression");
      }
    };
    base.TemplateLiteral = function(node, st, c) {
      for (var i = 0, list = node.quasis; i < list.length; i += 1) {
        var quasi = list[i];
        c(quasi, st);
      }
      for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
        var expr = list$1[i$1];
        c(expr, st, "Expression");
      }
    };
    base.TemplateElement = ignore;
    base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
      c(node.argument, st, "Expression");
    };
    base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
      c(node.left, st, "Expression");
      c(node.right, st, "Expression");
    };
    base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
      c(node.left, st, "Pattern");
      c(node.right, st, "Expression");
    };
    base.ConditionalExpression = function(node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Expression");
      c(node.alternate, st, "Expression");
    };
    base.NewExpression = base.CallExpression = function(node, st, c) {
      c(node.callee, st, "Expression");
      if (node.arguments) {
        for (var i = 0, list = node.arguments; i < list.length; i += 1) {
          var arg = list[i];
          c(arg, st, "Expression");
        }
      }
    };
    base.MemberExpression = function(node, st, c) {
      c(node.object, st, "Expression");
      if (node.computed) {
        c(node.property, st, "Expression");
      }
    };
    base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
      if (node.declaration) {
        c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
      }
      if (node.source) {
        c(node.source, st, "Expression");
      }
    };
    base.ExportAllDeclaration = function(node, st, c) {
      if (node.exported) {
        c(node.exported, st);
      }
      c(node.source, st, "Expression");
    };
    base.ImportDeclaration = function(node, st, c) {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        c(spec, st);
      }
      c(node.source, st, "Expression");
    };
    base.ImportExpression = function(node, st, c) {
      c(node.source, st, "Expression");
    };
    base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;
    base.TaggedTemplateExpression = function(node, st, c) {
      c(node.tag, st, "Expression");
      c(node.quasi, st, "Expression");
    };
    base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
      return c(node, st, "Class");
    };
    base.Class = function(node, st, c) {
      if (node.id) {
        c(node.id, st, "Pattern");
      }
      if (node.superClass) {
        c(node.superClass, st, "Expression");
      }
      c(node.body, st);
    };
    base.ClassBody = function(node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1) {
        var elt = list[i];
        c(elt, st);
      }
    };
    base.MethodDefinition = base.Property = function(node, st, c) {
      if (node.computed) {
        c(node.key, st, "Expression");
      }
      c(node.value, st, "Expression");
    };
  }
});

// node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/walk.js
var require_walk = __commonJS({
  "node_modules/.pnpm/acorn-node@1.8.2/node_modules/acorn-node/walk.js"(exports) {
    var xtend = require_immutable();
    var walk = (init_walk(), __toCommonJS(walk_exports));
    var base2 = xtend(walk.base);
    base2.Import = function() {
    };
    function simple2(node, visitors, baseVisitor, state, override) {
      return walk.simple(node, visitors, baseVisitor || base2, state, override);
    }
    function ancestor2(node, visitors, baseVisitor, state) {
      return walk.ancestor(node, visitors, baseVisitor || base2, state);
    }
    function recursive2(node, state, funcs, baseVisitor, override) {
      return walk.recursive(node, state, funcs, baseVisitor || base2, override);
    }
    function full2(node, callback, baseVisitor, state, override) {
      return walk.full(node, callback, baseVisitor || base2, state, override);
    }
    function fullAncestor2(node, callback, baseVisitor, state) {
      return walk.fullAncestor(node, callback, baseVisitor || base2, state);
    }
    function findNodeAt2(node, start, end, test, baseVisitor, state) {
      return walk.findNodeAt(node, start, end, test, baseVisitor || base2, state);
    }
    function findNodeAround2(node, pos, test, baseVisitor, state) {
      return walk.findNodeAround(node, pos, test, baseVisitor || base2, state);
    }
    function findNodeAfter2(node, pos, test, baseVisitor, state) {
      return walk.findNodeAfter(node, pos, test, baseVisitor || base2, state);
    }
    function findNodeBefore2(node, pos, test, baseVisitor, state) {
      return walk.findNodeBefore(node, pos, test, baseVisitor || base2, state);
    }
    function make2(funcs, baseVisitor) {
      return walk.make(funcs, baseVisitor || base2);
    }
    exports.simple = simple2;
    exports.ancestor = ancestor2;
    exports.recursive = recursive2;
    exports.full = full2;
    exports.fullAncestor = fullAncestor2;
    exports.findNodeAt = findNodeAt2;
    exports.findNodeAround = findNodeAround2;
    exports.findNodeAfter = findNodeAfter2;
    exports.findNodeBefore = findNodeBefore2;
    exports.make = make2;
    exports.base = base2;
  }
});

// node_modules/.pnpm/defined@1.0.1/node_modules/defined/index.js
var require_defined = __commonJS({
  "node_modules/.pnpm/defined@1.0.1/node_modules/defined/index.js"(exports, module2) {
    "use strict";
    module2.exports = function defined() {
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] !== "undefined") {
          return arguments[i];
        }
      }
    };
  }
});

// node_modules/.pnpm/detective@5.2.1/node_modules/detective/index.js
var require_detective = __commonJS({
  "node_modules/.pnpm/detective@5.2.1/node_modules/detective/index.js"(exports, module2) {
    var acorn = require_acorn_node();
    var walk = require_walk();
    var defined = require_defined();
    var requireRe = /\brequire\b/;
    function parse4(src, opts) {
      if (!opts)
        opts = {};
      var acornOpts = {
        ranges: defined(opts.ranges, opts.range),
        locations: defined(opts.locations, opts.loc),
        allowReserved: defined(opts.allowReserved, true),
        allowImportExportEverywhere: defined(opts.allowImportExportEverywhere, false)
      };
      if (opts.ecmaVersion != null)
        acornOpts.ecmaVersion = opts.ecmaVersion;
      if (opts.sourceType != null)
        acornOpts.sourceType = opts.sourceType;
      if (opts.allowHashBang != null)
        acornOpts.allowHashBang = opts.allowHashBang;
      if (opts.allowReturnOutsideFunction != null)
        acornOpts.allowReturnOutsideFunction = opts.allowReturnOutsideFunction;
      return acorn.parse(src, acornOpts);
    }
    var exports = module2.exports = function(src, opts) {
      return exports.find(src, opts).strings;
    };
    exports.find = function(src, opts) {
      if (!opts)
        opts = {};
      var word = opts.word === void 0 ? "require" : opts.word;
      if (typeof src !== "string")
        src = String(src);
      var isRequire = opts.isRequire || function(node) {
        return node.callee.type === "Identifier" && node.callee.name === word;
      };
      var modules = { strings: [], expressions: [] };
      if (opts.nodes)
        modules.nodes = [];
      var wordRe = word === "require" ? requireRe : RegExp("\\b" + word + "\\b");
      if (!wordRe.test(src))
        return modules;
      var ast = parse4(src, opts.parse);
      function visit(node, st, c) {
        var hasRequire = wordRe.test(src.slice(node.start, node.end));
        if (!hasRequire)
          return;
        walk.base[node.type](node, st, c);
        if (node.type !== "CallExpression")
          return;
        if (isRequire(node)) {
          if (node.arguments.length) {
            var arg = node.arguments[0];
            if (arg.type === "Literal") {
              modules.strings.push(arg.value);
            } else if (arg.type === "TemplateLiteral" && arg.quasis.length === 1 && arg.expressions.length === 0) {
              modules.strings.push(arg.quasis[0].value.raw);
            } else {
              modules.expressions.push(src.slice(arg.start, arg.end));
            }
          }
          if (opts.nodes)
            modules.nodes.push(node);
        }
      }
      walk.recursive(ast, null, {
        Statement: visit,
        Expression: visit
      });
      return modules;
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/getModuleDependencies.js
var require_getModuleDependencies = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/getModuleDependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => getModuleDependencies
    });
    var _fs = /* @__PURE__ */ _interopRequireDefault(require("fs"));
    var _path = /* @__PURE__ */ _interopRequireDefault(require("path"));
    var _resolve = /* @__PURE__ */ _interopRequireDefault(require_resolve());
    var _detective = /* @__PURE__ */ _interopRequireDefault(require_detective());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createModule(file) {
      const source = _fs.default.readFileSync(file, "utf-8");
      const requires = (0, _detective.default)(source);
      return {
        file,
        requires
      };
    }
    function getModuleDependencies(entryFile) {
      const rootModule = createModule(entryFile);
      const modules = [
        rootModule
      ];
      for (const mdl of modules) {
        mdl.requires.filter((dep) => {
          return dep.startsWith("./") || dep.startsWith("../");
        }).forEach((dep) => {
          try {
            const basedir = _path.default.dirname(mdl.file);
            const depPath = _resolve.default.sync(dep, {
              basedir
            });
            const depModule = createModule(depPath);
            modules.push(depModule);
          } catch (_err) {
          }
        });
      }
      return modules;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/negateValue.js
var require_negateValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/negateValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    function _default(value) {
      value = `${value}`;
      if (value === "0") {
        return "0";
      }
      if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value)) {
        return value.replace(/^[+-]?/, (sign) => sign === "-" ? "" : "-");
      }
      let numericFunctions = [
        "var",
        "calc",
        "min",
        "max",
        "clamp"
      ];
      for (const fn of numericFunctions) {
        if (value.includes(`${fn}(`)) {
          return `calc(${value} * -1)`;
        }
      }
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/corePluginList.js
var require_corePluginList = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/corePluginList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var _default = [
      "preflight",
      "container",
      "accessibility",
      "pointerEvents",
      "visibility",
      "position",
      "inset",
      "isolation",
      "zIndex",
      "order",
      "gridColumn",
      "gridColumnStart",
      "gridColumnEnd",
      "gridRow",
      "gridRowStart",
      "gridRowEnd",
      "float",
      "clear",
      "margin",
      "boxSizing",
      "display",
      "aspectRatio",
      "height",
      "maxHeight",
      "minHeight",
      "width",
      "minWidth",
      "maxWidth",
      "flex",
      "flexShrink",
      "flexGrow",
      "flexBasis",
      "tableLayout",
      "borderCollapse",
      "borderSpacing",
      "transformOrigin",
      "translate",
      "rotate",
      "skew",
      "scale",
      "transform",
      "animation",
      "cursor",
      "touchAction",
      "userSelect",
      "resize",
      "scrollSnapType",
      "scrollSnapAlign",
      "scrollSnapStop",
      "scrollMargin",
      "scrollPadding",
      "listStylePosition",
      "listStyleType",
      "appearance",
      "columns",
      "breakBefore",
      "breakInside",
      "breakAfter",
      "gridAutoColumns",
      "gridAutoFlow",
      "gridAutoRows",
      "gridTemplateColumns",
      "gridTemplateRows",
      "flexDirection",
      "flexWrap",
      "placeContent",
      "placeItems",
      "alignContent",
      "alignItems",
      "justifyContent",
      "justifyItems",
      "gap",
      "space",
      "divideWidth",
      "divideStyle",
      "divideColor",
      "divideOpacity",
      "placeSelf",
      "alignSelf",
      "justifySelf",
      "overflow",
      "overscrollBehavior",
      "scrollBehavior",
      "textOverflow",
      "whitespace",
      "wordBreak",
      "borderRadius",
      "borderWidth",
      "borderStyle",
      "borderColor",
      "borderOpacity",
      "backgroundColor",
      "backgroundOpacity",
      "backgroundImage",
      "gradientColorStops",
      "boxDecorationBreak",
      "backgroundSize",
      "backgroundAttachment",
      "backgroundClip",
      "backgroundPosition",
      "backgroundRepeat",
      "backgroundOrigin",
      "fill",
      "stroke",
      "strokeWidth",
      "objectFit",
      "objectPosition",
      "padding",
      "textAlign",
      "textIndent",
      "verticalAlign",
      "fontFamily",
      "fontSize",
      "fontWeight",
      "textTransform",
      "fontStyle",
      "fontVariantNumeric",
      "lineHeight",
      "letterSpacing",
      "textColor",
      "textOpacity",
      "textDecoration",
      "textDecorationColor",
      "textDecorationStyle",
      "textDecorationThickness",
      "textUnderlineOffset",
      "fontSmoothing",
      "placeholderColor",
      "placeholderOpacity",
      "caretColor",
      "accentColor",
      "opacity",
      "backgroundBlendMode",
      "mixBlendMode",
      "boxShadow",
      "boxShadowColor",
      "outlineStyle",
      "outlineWidth",
      "outlineOffset",
      "outlineColor",
      "ringWidth",
      "ringColor",
      "ringOpacity",
      "ringOffsetWidth",
      "ringOffsetColor",
      "blur",
      "brightness",
      "contrast",
      "dropShadow",
      "grayscale",
      "hueRotate",
      "invert",
      "saturate",
      "sepia",
      "filter",
      "backdropBlur",
      "backdropBrightness",
      "backdropContrast",
      "backdropGrayscale",
      "backdropHueRotate",
      "backdropInvert",
      "backdropOpacity",
      "backdropSaturate",
      "backdropSepia",
      "backdropFilter",
      "transitionProperty",
      "transitionDelay",
      "transitionDuration",
      "transitionTimingFunction",
      "willChange",
      "content"
    ];
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/configurePlugins.js
var require_configurePlugins = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/configurePlugins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    function _default(pluginConfig, plugins) {
      if (pluginConfig === void 0) {
        return plugins;
      }
      const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
        ...new Set(plugins.filter((pluginName) => {
          return pluginConfig !== false && pluginConfig[pluginName] !== false;
        }).concat(Object.keys(pluginConfig).filter((pluginName) => {
          return pluginConfig[pluginName] !== false;
        })))
      ];
      return pluginNames;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/stubs/defaultConfig.stub.js
var require_defaultConfig_stub = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/stubs/defaultConfig.stub.js"(exports, module2) {
    module2.exports = {
      content: [],
      presets: [],
      darkMode: "media",
      theme: {
        screens: {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px",
          "2xl": "1536px"
        },
        supports: {},
        colors: ({ colors }) => ({
          inherit: colors.inherit,
          current: colors.current,
          transparent: colors.transparent,
          black: colors.black,
          white: colors.white,
          slate: colors.slate,
          gray: colors.gray,
          zinc: colors.zinc,
          neutral: colors.neutral,
          stone: colors.stone,
          red: colors.red,
          orange: colors.orange,
          amber: colors.amber,
          yellow: colors.yellow,
          lime: colors.lime,
          green: colors.green,
          emerald: colors.emerald,
          teal: colors.teal,
          cyan: colors.cyan,
          sky: colors.sky,
          blue: colors.blue,
          indigo: colors.indigo,
          violet: colors.violet,
          purple: colors.purple,
          fuchsia: colors.fuchsia,
          pink: colors.pink,
          rose: colors.rose
        }),
        columns: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          "3xs": "16rem",
          "2xs": "18rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem"
        },
        spacing: {
          px: "1px",
          0: "0px",
          0.5: "0.125rem",
          1: "0.25rem",
          1.5: "0.375rem",
          2: "0.5rem",
          2.5: "0.625rem",
          3: "0.75rem",
          3.5: "0.875rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem",
          11: "2.75rem",
          12: "3rem",
          14: "3.5rem",
          16: "4rem",
          20: "5rem",
          24: "6rem",
          28: "7rem",
          32: "8rem",
          36: "9rem",
          40: "10rem",
          44: "11rem",
          48: "12rem",
          52: "13rem",
          56: "14rem",
          60: "15rem",
          64: "16rem",
          72: "18rem",
          80: "20rem",
          96: "24rem"
        },
        animation: {
          none: "none",
          spin: "spin 1s linear infinite",
          ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
          pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
          bounce: "bounce 1s infinite"
        },
        aria: {
          checked: 'checked="true"',
          disabled: 'disabled="true"',
          expanded: 'expanded="true"',
          hidden: 'hidden="true"',
          pressed: 'pressed="true"',
          readonly: 'readonly="true"',
          required: 'required="true"',
          selected: 'selected="true"'
        },
        aspectRatio: {
          auto: "auto",
          square: "1 / 1",
          video: "16 / 9"
        },
        backdropBlur: ({ theme }) => theme("blur"),
        backdropBrightness: ({ theme }) => theme("brightness"),
        backdropContrast: ({ theme }) => theme("contrast"),
        backdropGrayscale: ({ theme }) => theme("grayscale"),
        backdropHueRotate: ({ theme }) => theme("hueRotate"),
        backdropInvert: ({ theme }) => theme("invert"),
        backdropOpacity: ({ theme }) => theme("opacity"),
        backdropSaturate: ({ theme }) => theme("saturate"),
        backdropSepia: ({ theme }) => theme("sepia"),
        backgroundColor: ({ theme }) => theme("colors"),
        backgroundImage: {
          none: "none",
          "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
          "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
          "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
          "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
          "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
          "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
          "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
          "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
        },
        backgroundOpacity: ({ theme }) => theme("opacity"),
        backgroundPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        backgroundSize: {
          auto: "auto",
          cover: "cover",
          contain: "contain"
        },
        blur: {
          0: "0",
          none: "0",
          sm: "4px",
          DEFAULT: "8px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        },
        brightness: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        borderColor: ({ theme }) => ({
          ...theme("colors"),
          DEFAULT: theme("colors.gray.200", "currentColor")
        }),
        borderOpacity: ({ theme }) => theme("opacity"),
        borderRadius: {
          none: "0px",
          sm: "0.125rem",
          DEFAULT: "0.25rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        },
        borderSpacing: ({ theme }) => ({
          ...theme("spacing")
        }),
        borderWidth: {
          DEFAULT: "1px",
          0: "0px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        boxShadow: {
          sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
          DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
          md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
          lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
          xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
          "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
          inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
          none: "none"
        },
        boxShadowColor: ({ theme }) => theme("colors"),
        caretColor: ({ theme }) => theme("colors"),
        accentColor: ({ theme }) => ({
          ...theme("colors"),
          auto: "auto"
        }),
        contrast: {
          0: "0",
          50: ".5",
          75: ".75",
          100: "1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        container: {},
        content: {
          none: "none"
        },
        cursor: {
          auto: "auto",
          default: "default",
          pointer: "pointer",
          wait: "wait",
          text: "text",
          move: "move",
          help: "help",
          "not-allowed": "not-allowed",
          none: "none",
          "context-menu": "context-menu",
          progress: "progress",
          cell: "cell",
          crosshair: "crosshair",
          "vertical-text": "vertical-text",
          alias: "alias",
          copy: "copy",
          "no-drop": "no-drop",
          grab: "grab",
          grabbing: "grabbing",
          "all-scroll": "all-scroll",
          "col-resize": "col-resize",
          "row-resize": "row-resize",
          "n-resize": "n-resize",
          "e-resize": "e-resize",
          "s-resize": "s-resize",
          "w-resize": "w-resize",
          "ne-resize": "ne-resize",
          "nw-resize": "nw-resize",
          "se-resize": "se-resize",
          "sw-resize": "sw-resize",
          "ew-resize": "ew-resize",
          "ns-resize": "ns-resize",
          "nesw-resize": "nesw-resize",
          "nwse-resize": "nwse-resize",
          "zoom-in": "zoom-in",
          "zoom-out": "zoom-out"
        },
        divideColor: ({ theme }) => theme("borderColor"),
        divideOpacity: ({ theme }) => theme("borderOpacity"),
        divideWidth: ({ theme }) => theme("borderWidth"),
        dropShadow: {
          sm: "0 1px 1px rgb(0 0 0 / 0.05)",
          DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
          md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
          lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
          xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
          "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
          none: "0 0 #0000"
        },
        fill: ({ theme }) => ({
          none: "none",
          ...theme("colors")
        }),
        grayscale: {
          0: "0",
          DEFAULT: "100%"
        },
        hueRotate: {
          0: "0deg",
          15: "15deg",
          30: "30deg",
          60: "60deg",
          90: "90deg",
          180: "180deg"
        },
        invert: {
          0: "0",
          DEFAULT: "100%"
        },
        flex: {
          1: "1 1 0%",
          auto: "1 1 auto",
          initial: "0 1 auto",
          none: "none"
        },
        flexBasis: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%"
        }),
        flexGrow: {
          0: "0",
          DEFAULT: "1"
        },
        flexShrink: {
          0: "0",
          DEFAULT: "1"
        },
        fontFamily: {
          sans: [
            "ui-sans-serif",
            "system-ui",
            "-apple-system",
            "BlinkMacSystemFont",
            '"Segoe UI"',
            "Roboto",
            '"Helvetica Neue"',
            "Arial",
            '"Noto Sans"',
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
          ],
          serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
          mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
          ]
        },
        fontSize: {
          xs: ["0.75rem", { lineHeight: "1rem" }],
          sm: ["0.875rem", { lineHeight: "1.25rem" }],
          base: ["1rem", { lineHeight: "1.5rem" }],
          lg: ["1.125rem", { lineHeight: "1.75rem" }],
          xl: ["1.25rem", { lineHeight: "1.75rem" }],
          "2xl": ["1.5rem", { lineHeight: "2rem" }],
          "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
          "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
          "5xl": ["3rem", { lineHeight: "1" }],
          "6xl": ["3.75rem", { lineHeight: "1" }],
          "7xl": ["4.5rem", { lineHeight: "1" }],
          "8xl": ["6rem", { lineHeight: "1" }],
          "9xl": ["8rem", { lineHeight: "1" }]
        },
        fontWeight: {
          thin: "100",
          extralight: "200",
          light: "300",
          normal: "400",
          medium: "500",
          semibold: "600",
          bold: "700",
          extrabold: "800",
          black: "900"
        },
        gap: ({ theme }) => theme("spacing"),
        gradientColorStops: ({ theme }) => theme("colors"),
        gridAutoColumns: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridAutoRows: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridColumn: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-7": "span 7 / span 7",
          "span-8": "span 8 / span 8",
          "span-9": "span 9 / span 9",
          "span-10": "span 10 / span 10",
          "span-11": "span 11 / span 11",
          "span-12": "span 12 / span 12",
          "span-full": "1 / -1"
        },
        gridColumnEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridColumnStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridRow: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-full": "1 / -1"
        },
        gridRowStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridRowEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridTemplateColumns: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))",
          7: "repeat(7, minmax(0, 1fr))",
          8: "repeat(8, minmax(0, 1fr))",
          9: "repeat(9, minmax(0, 1fr))",
          10: "repeat(10, minmax(0, 1fr))",
          11: "repeat(11, minmax(0, 1fr))",
          12: "repeat(12, minmax(0, 1fr))"
        },
        gridTemplateRows: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))"
        },
        height: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        inset: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        keyframes: {
          spin: {
            to: {
              transform: "rotate(360deg)"
            }
          },
          ping: {
            "75%, 100%": {
              transform: "scale(2)",
              opacity: "0"
            }
          },
          pulse: {
            "50%": {
              opacity: ".5"
            }
          },
          bounce: {
            "0%, 100%": {
              transform: "translateY(-25%)",
              animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
              transform: "none",
              animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
          }
        },
        letterSpacing: {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0em",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        },
        lineHeight: {
          none: "1",
          tight: "1.25",
          snug: "1.375",
          normal: "1.5",
          relaxed: "1.625",
          loose: "2",
          3: ".75rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem"
        },
        listStyleType: {
          none: "none",
          disc: "disc",
          decimal: "decimal"
        },
        margin: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing")
        }),
        maxHeight: ({ theme }) => ({
          ...theme("spacing"),
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        maxWidth: ({ theme, breakpoints }) => ({
          none: "none",
          0: "0rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content",
          prose: "65ch",
          ...breakpoints(theme("screens"))
        }),
        minHeight: {
          0: "0px",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        minWidth: {
          0: "0px",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        objectPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        opacity: {
          0: "0",
          5: "0.05",
          10: "0.1",
          20: "0.2",
          25: "0.25",
          30: "0.3",
          40: "0.4",
          50: "0.5",
          60: "0.6",
          70: "0.7",
          75: "0.75",
          80: "0.8",
          90: "0.9",
          95: "0.95",
          100: "1"
        },
        order: {
          first: "-9999",
          last: "9999",
          none: "0",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12"
        },
        padding: ({ theme }) => theme("spacing"),
        placeholderColor: ({ theme }) => theme("colors"),
        placeholderOpacity: ({ theme }) => theme("opacity"),
        outlineColor: ({ theme }) => theme("colors"),
        outlineOffset: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        outlineWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        ringColor: ({ theme }) => ({
          DEFAULT: theme("colors.blue.500", "#3b82f6"),
          ...theme("colors")
        }),
        ringOffsetColor: ({ theme }) => theme("colors"),
        ringOffsetWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        ringOpacity: ({ theme }) => ({
          DEFAULT: "0.5",
          ...theme("opacity")
        }),
        ringWidth: {
          DEFAULT: "3px",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        rotate: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg",
          45: "45deg",
          90: "90deg",
          180: "180deg"
        },
        saturate: {
          0: "0",
          50: ".5",
          100: "1",
          150: "1.5",
          200: "2"
        },
        scale: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5"
        },
        scrollMargin: ({ theme }) => ({
          ...theme("spacing")
        }),
        scrollPadding: ({ theme }) => theme("spacing"),
        sepia: {
          0: "0",
          DEFAULT: "100%"
        },
        skew: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg"
        },
        space: ({ theme }) => ({
          ...theme("spacing")
        }),
        stroke: ({ theme }) => ({
          none: "none",
          ...theme("colors")
        }),
        strokeWidth: {
          0: "0",
          1: "1",
          2: "2"
        },
        textColor: ({ theme }) => theme("colors"),
        textDecorationColor: ({ theme }) => theme("colors"),
        textDecorationThickness: {
          auto: "auto",
          "from-font": "from-font",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        textUnderlineOffset: {
          auto: "auto",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        textIndent: ({ theme }) => ({
          ...theme("spacing")
        }),
        textOpacity: ({ theme }) => theme("opacity"),
        transformOrigin: {
          center: "center",
          top: "top",
          "top-right": "top right",
          right: "right",
          "bottom-right": "bottom right",
          bottom: "bottom",
          "bottom-left": "bottom left",
          left: "left",
          "top-left": "top left"
        },
        transitionDelay: {
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionDuration: {
          DEFAULT: "150ms",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionProperty: {
          none: "none",
          all: "all",
          DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
          colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
          opacity: "opacity",
          shadow: "box-shadow",
          transform: "transform"
        },
        transitionTimingFunction: {
          DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
          linear: "linear",
          in: "cubic-bezier(0.4, 0, 1, 1)",
          out: "cubic-bezier(0, 0, 0.2, 1)",
          "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        },
        translate: ({ theme }) => ({
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        width: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%",
          screen: "100vw",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        willChange: {
          auto: "auto",
          scroll: "scroll-position",
          contents: "contents",
          transform: "transform"
        },
        zIndex: {
          auto: "auto",
          0: "0",
          10: "10",
          20: "20",
          30: "30",
          40: "40",
          50: "50"
        }
      },
      variantOrder: [
        "first",
        "last",
        "odd",
        "even",
        "visited",
        "checked",
        "empty",
        "read-only",
        "group-hover",
        "group-focus",
        "focus-within",
        "hover",
        "focus",
        "focus-visible",
        "active",
        "disabled"
      ],
      plugins: []
    };
  }
});

// node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js"(exports, module2) {
    var tty = require("tty");
    var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input;
      let index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let start = string.substring(0, index) + replace;
      let end = string.substring(index + close.length);
      let nextIndex2 = end.indexOf(close);
      return ~nextIndex2 ? start + replaceClose(end, close, replace, nextIndex2) : start + end;
    };
    var createColors = (enabled = isColorSupported) => ({
      isColorSupported: enabled,
      reset: enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String,
      bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
      dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
      italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
      underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
      inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
      hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
      strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
      black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
      red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
      green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
      yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
      blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
      magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
      cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
      white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
      gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
      bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
      bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
      bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
      bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
      bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
      bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
      bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
      bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
    });
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/log.js
var require_log = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      dim: () => dim,
      default: () => _default
    });
    var _picocolors = /* @__PURE__ */ _interopRequireDefault(require_picocolors());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var alreadyShown = /* @__PURE__ */ new Set();
    function log(type, messages, key) {
      if (typeof process !== "undefined" && process.env.JEST_WORKER_ID)
        return;
      if (key && alreadyShown.has(key))
        return;
      if (key)
        alreadyShown.add(key);
      console.warn("");
      messages.forEach((message) => console.warn(type, "-", message));
    }
    function dim(input) {
      return _picocolors.default.dim(input);
    }
    var _default = {
      info(key, messages) {
        log(_picocolors.default.bold(_picocolors.default.cyan("info")), ...Array.isArray(key) ? [
          key
        ] : [
          messages,
          key
        ]);
      },
      warn(key, messages) {
        log(_picocolors.default.bold(_picocolors.default.yellow("warn")), ...Array.isArray(key) ? [
          key
        ] : [
          messages,
          key
        ]);
      },
      risk(key, messages) {
        log(_picocolors.default.bold(_picocolors.default.magenta("risk")), ...Array.isArray(key) ? [
          key
        ] : [
          messages,
          key
        ]);
      }
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/public/colors.js
var require_colors = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/public/colors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function warn({ version: version2, from, to }) {
      _log.default.warn(`${from}-color-renamed`, [
        `As of Tailwind CSS ${version2}, \`${from}\` has been renamed to \`${to}\`.`,
        "Update your configuration file to silence this warning."
      ]);
    }
    var _default = {
      inherit: "inherit",
      current: "currentColor",
      transparent: "transparent",
      black: "#000",
      white: "#fff",
      slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a"
      },
      gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827"
      },
      zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b"
      },
      neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717"
      },
      stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917"
      },
      red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d"
      },
      orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12"
      },
      amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f"
      },
      yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12"
      },
      lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314"
      },
      green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d"
      },
      emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b"
      },
      teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a"
      },
      cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63"
      },
      sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e"
      },
      blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a"
      },
      indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81"
      },
      violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95"
      },
      purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87"
      },
      fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75"
      },
      pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843"
      },
      rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337"
      },
      get lightBlue() {
        warn({
          version: "v2.2",
          from: "lightBlue",
          to: "sky"
        });
        return this.sky;
      },
      get warmGray() {
        warn({
          version: "v3.0",
          from: "warmGray",
          to: "stone"
        });
        return this.stone;
      },
      get trueGray() {
        warn({
          version: "v3.0",
          from: "trueGray",
          to: "neutral"
        });
        return this.neutral;
      },
      get coolGray() {
        warn({
          version: "v3.0",
          from: "coolGray",
          to: "gray"
        });
        return this.gray;
      },
      get blueGray() {
        warn({
          version: "v3.0",
          from: "blueGray",
          to: "slate"
        });
        return this.slate;
      }
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/defaults.js
var require_defaults = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "defaults", {
      enumerable: true,
      get: () => defaults
    });
    function defaults(target, ...sources) {
      for (let source of sources) {
        for (let k in source) {
          var ref2;
          if (!(target === null || target === void 0 ? void 0 : (ref2 = target.hasOwnProperty) === null || ref2 === void 0 ? void 0 : ref2.call(target, k))) {
            target[k] = source[k];
          }
        }
        for (let k1 of Object.getOwnPropertySymbols(source)) {
          var ref1;
          if (!(target === null || target === void 0 ? void 0 : (ref1 = target.hasOwnProperty) === null || ref1 === void 0 ? void 0 : ref1.call(target, k1))) {
            target[k1] = source[k1];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/toPath.js
var require_toPath = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/toPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "toPath", {
      enumerable: true,
      get: () => toPath
    });
    function toPath(path3) {
      if (Array.isArray(path3))
        return path3;
      let openBrackets = path3.split("[").length - 1;
      let closedBrackets = path3.split("]").length - 1;
      if (openBrackets !== closedBrackets) {
        throw new Error(`Path is invalid. Has unbalanced brackets: ${path3}`);
      }
      return path3.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/normalizeConfig.js
var require_normalizeConfig = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/normalizeConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizeConfig", {
      enumerable: true,
      get: () => normalizeConfig
    });
    var _log = /* @__PURE__ */ _interopRequireWildcard(require_log());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function normalizeConfig(config) {
      let valid = (() => {
        if (config.purge) {
          return false;
        }
        if (!config.content) {
          return false;
        }
        if (!Array.isArray(config.content) && !(typeof config.content === "object" && config.content !== null)) {
          return false;
        }
        if (Array.isArray(config.content)) {
          return config.content.every((path3) => {
            if (typeof path3 === "string")
              return true;
            if (typeof (path3 === null || path3 === void 0 ? void 0 : path3.raw) !== "string")
              return false;
            if ((path3 === null || path3 === void 0 ? void 0 : path3.extension) && typeof (path3 === null || path3 === void 0 ? void 0 : path3.extension) !== "string") {
              return false;
            }
            return true;
          });
        }
        if (typeof config.content === "object" && config.content !== null) {
          if (Object.keys(config.content).some((key) => ![
            "files",
            "relative",
            "extract",
            "transform"
          ].includes(key))) {
            return false;
          }
          if (Array.isArray(config.content.files)) {
            if (!config.content.files.every((path3) => {
              if (typeof path3 === "string")
                return true;
              if (typeof (path3 === null || path3 === void 0 ? void 0 : path3.raw) !== "string")
                return false;
              if ((path3 === null || path3 === void 0 ? void 0 : path3.extension) && typeof (path3 === null || path3 === void 0 ? void 0 : path3.extension) !== "string") {
                return false;
              }
              return true;
            })) {
              return false;
            }
            if (typeof config.content.extract === "object") {
              for (let value of Object.values(config.content.extract)) {
                if (typeof value !== "function") {
                  return false;
                }
              }
            } else if (!(config.content.extract === void 0 || typeof config.content.extract === "function")) {
              return false;
            }
            if (typeof config.content.transform === "object") {
              for (let value1 of Object.values(config.content.transform)) {
                if (typeof value1 !== "function") {
                  return false;
                }
              }
            } else if (!(config.content.transform === void 0 || typeof config.content.transform === "function")) {
              return false;
            }
            if (typeof config.content.relative !== "boolean" && typeof config.content.relative !== "undefined") {
              return false;
            }
          }
          return true;
        }
        return false;
      })();
      if (!valid) {
        _log.default.warn("purge-deprecation", [
          "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
          "Update your configuration file to eliminate this warning.",
          "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
        ]);
      }
      config.safelist = (() => {
        var ref2;
        let { content, purge, safelist } = config;
        if (Array.isArray(safelist))
          return safelist;
        if (Array.isArray(content === null || content === void 0 ? void 0 : content.safelist))
          return content.safelist;
        if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.safelist))
          return purge.safelist;
        if (Array.isArray(purge === null || purge === void 0 ? void 0 : (ref2 = purge.options) === null || ref2 === void 0 ? void 0 : ref2.safelist))
          return purge.options.safelist;
        return [];
      })();
      config.blocklist = (() => {
        let { blocklist } = config;
        if (Array.isArray(blocklist)) {
          if (blocklist.every((item) => typeof item === "string")) {
            return blocklist;
          }
          _log.default.warn("blocklist-invalid", [
            "The `blocklist` option must be an array of strings.",
            "https://tailwindcss.com/docs/content-configuration#discarding-classes"
          ]);
        }
        return [];
      })();
      if (typeof config.prefix === "function") {
        _log.default.warn("prefix-function", [
          "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
          "Update `prefix` in your configuration to be a string to eliminate this warning.",
          "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
        ]);
        config.prefix = "";
      } else {
        var _prefix;
        config.prefix = (_prefix = config.prefix) !== null && _prefix !== void 0 ? _prefix : "";
      }
      config.content = {
        relative: (() => {
          var ref2;
          let { content } = config;
          if (content === null || content === void 0 ? void 0 : content.relative) {
            return content.relative;
          }
          var ref1;
          return (ref1 = (ref2 = config.future) === null || ref2 === void 0 ? void 0 : ref2.relativeContentPathsByDefault) !== null && ref1 !== void 0 ? ref1 : false;
        })(),
        files: (() => {
          let { content, purge } = config;
          if (Array.isArray(purge))
            return purge;
          if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.content))
            return purge.content;
          if (Array.isArray(content))
            return content;
          if (Array.isArray(content === null || content === void 0 ? void 0 : content.content))
            return content.content;
          if (Array.isArray(content === null || content === void 0 ? void 0 : content.files))
            return content.files;
          return [];
        })(),
        extract: (() => {
          let extract = (() => {
            var ref2, ref1, ref22, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
            if ((ref2 = config.purge) === null || ref2 === void 0 ? void 0 : ref2.extract)
              return config.purge.extract;
            if ((ref1 = config.content) === null || ref1 === void 0 ? void 0 : ref1.extract)
              return config.content.extract;
            if ((ref22 = config.purge) === null || ref22 === void 0 ? void 0 : (ref3 = ref22.extract) === null || ref3 === void 0 ? void 0 : ref3.DEFAULT)
              return config.purge.extract.DEFAULT;
            if ((ref4 = config.content) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.extract) === null || ref5 === void 0 ? void 0 : ref5.DEFAULT)
              return config.content.extract.DEFAULT;
            if ((ref6 = config.purge) === null || ref6 === void 0 ? void 0 : (ref7 = ref6.options) === null || ref7 === void 0 ? void 0 : ref7.extractors)
              return config.purge.options.extractors;
            if ((ref8 = config.content) === null || ref8 === void 0 ? void 0 : (ref9 = ref8.options) === null || ref9 === void 0 ? void 0 : ref9.extractors)
              return config.content.options.extractors;
            return {};
          })();
          let extractors = {};
          let defaultExtractor = (() => {
            var ref2, ref1, ref22, ref3;
            if ((ref2 = config.purge) === null || ref2 === void 0 ? void 0 : (ref1 = ref2.options) === null || ref1 === void 0 ? void 0 : ref1.defaultExtractor) {
              return config.purge.options.defaultExtractor;
            }
            if ((ref22 = config.content) === null || ref22 === void 0 ? void 0 : (ref3 = ref22.options) === null || ref3 === void 0 ? void 0 : ref3.defaultExtractor) {
              return config.content.options.defaultExtractor;
            }
            return void 0;
          })();
          if (defaultExtractor !== void 0) {
            extractors.DEFAULT = defaultExtractor;
          }
          if (typeof extract === "function") {
            extractors.DEFAULT = extract;
          } else if (Array.isArray(extract)) {
            for (let { extensions, extractor } of extract !== null && extract !== void 0 ? extract : []) {
              for (let extension of extensions) {
                extractors[extension] = extractor;
              }
            }
          } else if (typeof extract === "object" && extract !== null) {
            Object.assign(extractors, extract);
          }
          return extractors;
        })(),
        transform: (() => {
          let transform = (() => {
            var ref2, ref1, ref22, ref3, ref4, ref5;
            if ((ref2 = config.purge) === null || ref2 === void 0 ? void 0 : ref2.transform)
              return config.purge.transform;
            if ((ref1 = config.content) === null || ref1 === void 0 ? void 0 : ref1.transform)
              return config.content.transform;
            if ((ref22 = config.purge) === null || ref22 === void 0 ? void 0 : (ref3 = ref22.transform) === null || ref3 === void 0 ? void 0 : ref3.DEFAULT)
              return config.purge.transform.DEFAULT;
            if ((ref4 = config.content) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.transform) === null || ref5 === void 0 ? void 0 : ref5.DEFAULT)
              return config.content.transform.DEFAULT;
            return {};
          })();
          let transformers = {};
          if (typeof transform === "function") {
            transformers.DEFAULT = transform;
          }
          if (typeof transform === "object" && transform !== null) {
            Object.assign(transformers, transform);
          }
          return transformers;
        })()
      };
      for (let file of config.content.files) {
        if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
          _log.default.warn("invalid-glob-braces", [
            `The glob pattern ${(0, _log.dim)(file)} in your Tailwind CSS configuration is invalid.`,
            `Update it to ${(0, _log.dim)(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
          ]);
          break;
        }
      }
      return config;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/isPlainObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => isPlainObject
    });
    function isPlainObject(value) {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: () => cloneDeep
    });
    function cloneDeep(value) {
      if (Array.isArray(value)) {
        return value.map((child) => cloneDeep(child));
      }
      if (typeof value === "object" && value !== null) {
        return Object.fromEntries(Object.entries(value).map(([k, v]) => [
          k,
          cloneDeep(v)
        ]));
      }
      return value;
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/unesc.js
var require_unesc = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/unesc.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = unesc;
    function gobbleHex(str) {
      var lower = str.toLowerCase();
      var hex = "";
      var spaceTerminated = false;
      for (var i = 0; i < 6 && lower[i] !== void 0; i++) {
        var code = lower.charCodeAt(i);
        var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
        spaceTerminated = code === 32;
        if (!valid) {
          break;
        }
        hex += lower[i];
      }
      if (hex.length === 0) {
        return void 0;
      }
      var codePoint = parseInt(hex, 16);
      var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
      if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
        return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
      }
      return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
    }
    var CONTAINS_ESCAPE = /\\/;
    function unesc(str) {
      var needToProcess = CONTAINS_ESCAPE.test(str);
      if (!needToProcess) {
        return str;
      }
      var ret = "";
      for (var i = 0; i < str.length; i++) {
        if (str[i] === "\\") {
          var gobbled = gobbleHex(str.slice(i + 1, i + 7));
          if (gobbled !== void 0) {
            ret += gobbled[0];
            i += gobbled[1];
            continue;
          }
          if (str[i + 1] === "\\") {
            ret += "\\";
            i++;
            continue;
          }
          if (str.length === i + 1) {
            ret += str[i];
          }
          continue;
        }
        ret += str[i];
      }
      return ret;
    }
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/getProp.js
var require_getProp = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/getProp.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = getProp;
    function getProp(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          return void 0;
        }
        obj = obj[prop];
      }
      return obj;
    }
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/ensureObject.js
var require_ensureObject = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = ensureObject;
    function ensureObject(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          obj[prop] = {};
        }
        obj = obj[prop];
      }
    }
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/stripComments.js
var require_stripComments = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = stripComments;
    function stripComments(str) {
      var s = "";
      var commentStart = str.indexOf("/*");
      var lastEnd = 0;
      while (commentStart >= 0) {
        s = s + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
          return s;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
      }
      s = s + str.slice(lastEnd);
      return s;
    }
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/index.js
var require_util = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/util/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;
    var _unesc = _interopRequireDefault(require_unesc());
    exports.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault(require_getProp());
    exports.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault(require_ensureObject());
    exports.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault(require_stripComments());
    exports.stripComments = _stripComments["default"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/node.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _util = require_util();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var cloneNode = function cloneNode2(obj, parent) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var cloned = new obj.constructor();
      for (var i in obj) {
        if (!obj.hasOwnProperty(i)) {
          continue;
        }
        var value = obj[i];
        var type = typeof value;
        if (i === "parent" && type === "object") {
          if (parent) {
            cloned[i] = parent;
          }
        } else if (value instanceof Array) {
          cloned[i] = value.map(function(j) {
            return cloneNode2(j, cloned);
          });
        } else {
          cloned[i] = cloneNode2(value, cloned);
        }
      }
      return cloned;
    };
    var Node3 = /* @__PURE__ */ function() {
      function Node4(opts) {
        if (opts === void 0) {
          opts = {};
        }
        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || "";
        this.spaces.after = this.spaces.after || "";
      }
      var _proto = Node4.prototype;
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var index in arguments) {
            this.parent.insertBefore(this, arguments[index]);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
      };
      _proto.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      };
      _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value;
        if (originalEscaped || valueEscaped !== value) {
          this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
          delete this.raws[name];
        }
      };
      _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        this[name] = value;
        this.raws[name] = valueEscaped;
      };
      _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
        this[name] = value;
        if (this.raws) {
          delete this.raws[name];
        }
      };
      _proto.isAtPosition = function isAtPosition(line, column) {
        if (this.source && this.source.start && this.source.end) {
          if (this.source.start.line > line) {
            return false;
          }
          if (this.source.end.line < line) {
            return false;
          }
          if (this.source.start.line === line && this.source.start.column > column) {
            return false;
          }
          if (this.source.end.line === line && this.source.end.column < column) {
            return false;
          }
          return true;
        }
        return void 0;
      };
      _proto.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
      };
      _proto.valueToString = function valueToString() {
        return String(this.stringifyProperty("value"));
      };
      _proto.toString = function toString2() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      };
      _createClass(Node4, [{
        key: "rawSpaceBefore",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
          if (rawSpace === void 0) {
            rawSpace = this.spaces && this.spaces.before;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.before = raw;
        }
      }, {
        key: "rawSpaceAfter",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
          if (rawSpace === void 0) {
            rawSpace = this.spaces.after;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.after = raw;
        }
      }]);
      return Node4;
    }();
    exports["default"] = Node3;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
    var TAG = "tag";
    exports.TAG = TAG;
    var STRING = "string";
    exports.STRING = STRING;
    var SELECTOR = "selector";
    exports.SELECTOR = SELECTOR;
    var ROOT = "root";
    exports.ROOT = ROOT;
    var PSEUDO = "pseudo";
    exports.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    exports.NESTING = NESTING;
    var ID = "id";
    exports.ID = ID;
    var COMMENT = "comment";
    exports.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    exports.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    exports.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    exports.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    exports.UNIVERSAL = UNIVERSAL;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/container.js
var require_container = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/container.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var types2 = _interopRequireWildcard(require_types());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Container = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Container2, _Node);
      function Container2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        if (!_this.nodes) {
          _this.nodes = [];
        }
        return _this;
      }
      var _proto = Container2.prototype;
      _proto.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
      };
      _proto.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
      };
      _proto.at = function at2(index) {
        return this.nodes[index];
      };
      _proto.index = function index(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = void 0;
        this.nodes.splice(child, 1);
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
          var node = _step.value;
          node.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.empty = function empty2() {
        return this.removeAll();
      };
      _proto.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (oldIndex <= index) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index <= oldIndex) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
        var found = void 0;
        this.each(function(node) {
          if (node.atPosition) {
            var foundChild = node.atPosition(line, col);
            if (foundChild) {
              found = foundChild;
              return false;
            }
          } else if (node.isAtPosition(line, col)) {
            found = node;
            return false;
          }
        });
        return found;
      };
      _proto.atPosition = function atPosition(line, col) {
        if (this.isAtPosition(line, col)) {
          return this._findChildAtPosition(line, col) || this;
        } else {
          return void 0;
        }
      };
      _proto._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
          this.source = this.source || {};
          this.source.end = this.source.end || {};
          Object.assign(this.source.end, this.last.source.end);
        }
      };
      _proto.each = function each(callback) {
        if (!this.lastEach) {
          this.lastEach = 0;
        }
        if (!this.indexes) {
          this.indexes = {};
        }
        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.length) {
          return void 0;
        }
        var index, result;
        while (this.indexes[id] < this.length) {
          index = this.indexes[id];
          result = callback(this.at(index), index);
          if (result === false) {
            break;
          }
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        if (result === false) {
          return false;
        }
      };
      _proto.walk = function walk(callback) {
        return this.each(function(node, i) {
          var result = callback(node, i);
          if (result !== false && node.length) {
            result = node.walk(callback);
          }
          if (result === false) {
            return false;
          }
        });
      };
      _proto.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.ATTRIBUTE) {
            return callback.call(_this2, selector);
          }
        });
      };
      _proto.walkClasses = function walkClasses(callback) {
        var _this3 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.CLASS) {
            return callback.call(_this3, selector);
          }
        });
      };
      _proto.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.COMBINATOR) {
            return callback.call(_this4, selector);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        var _this5 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.COMMENT) {
            return callback.call(_this5, selector);
          }
        });
      };
      _proto.walkIds = function walkIds(callback) {
        var _this6 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.ID) {
            return callback.call(_this6, selector);
          }
        });
      };
      _proto.walkNesting = function walkNesting(callback) {
        var _this7 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.NESTING) {
            return callback.call(_this7, selector);
          }
        });
      };
      _proto.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.PSEUDO) {
            return callback.call(_this8, selector);
          }
        });
      };
      _proto.walkTags = function walkTags(callback) {
        var _this9 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.TAG) {
            return callback.call(_this9, selector);
          }
        });
      };
      _proto.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.UNIVERSAL) {
            return callback.call(_this10, selector);
          }
        });
      };
      _proto.split = function split(callback) {
        var _this11 = this;
        var current2 = [];
        return this.reduce(function(memo, node, index) {
          var split2 = callback.call(_this11, node);
          current2.push(node);
          if (split2) {
            memo.push(current2);
            current2 = [];
          } else if (index === _this11.length - 1) {
            memo.push(current2);
          }
          return memo;
        }, []);
      };
      _proto.map = function map(callback) {
        return this.nodes.map(callback);
      };
      _proto.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
      };
      _proto.every = function every(callback) {
        return this.nodes.every(callback);
      };
      _proto.some = function some(callback) {
        return this.nodes.some(callback);
      };
      _proto.filter = function filter(callback) {
        return this.nodes.filter(callback);
      };
      _proto.sort = function sort(callback) {
        return this.nodes.sort(callback);
      };
      _proto.toString = function toString2() {
        return this.map(String).join("");
      };
      _createClass(Container2, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]);
      return Container2;
    }(_node["default"]);
    exports["default"] = Container;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/root.js
var require_root = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/root.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Root = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Root2, _Container);
      function Root2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.ROOT;
        return _this;
      }
      var _proto = Root2.prototype;
      _proto.toString = function toString2() {
        var str = this.reduce(function(memo, selector) {
          memo.push(String(selector));
          return memo;
        }, []).join(",");
        return this.trailingComma ? str + "," : str;
      };
      _proto.error = function error(message, options) {
        if (this._error) {
          return this._error(message, options);
        } else {
          return new Error(message);
        }
      };
      _createClass(Root2, [{
        key: "errorGenerator",
        set: function set(handler) {
          this._error = handler;
        }
      }]);
      return Root2;
    }(_container["default"]);
    exports["default"] = Root;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/selector.js
var require_selector = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Selector = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Selector2, _Container);
      function Selector2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.SELECTOR;
        return _this;
      }
      return Selector2;
    }(_container["default"]);
    exports["default"] = Selector;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js"(exports, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty2.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    module2.exports = cssesc;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/className.js
var require_className = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/className.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util();
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ClassName = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ClassName2, _Node);
      function ClassName2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
      }
      var _proto = ClassName2.prototype;
      _proto.valueToString = function valueToString() {
        return "." + _Node.prototype.valueToString.call(this);
      };
      _createClass(ClassName2, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(v, {
              isIdentifier: true
            });
            if (escaped !== v) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.value = escaped;
            } else if (this.raws) {
              delete this.raws.value;
            }
          }
          this._value = v;
        }
      }]);
      return ClassName2;
    }(_node["default"]);
    exports["default"] = ClassName;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/comment.js
var require_comment = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Comment = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Comment2, _Node);
      function Comment2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMMENT;
        return _this;
      }
      return Comment2;
    }(_node["default"]);
    exports["default"] = Comment;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/id.js
var require_id = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/id.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ID = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ID2, _Node);
      function ID2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.ID;
        return _this;
      }
      var _proto = ID2.prototype;
      _proto.valueToString = function valueToString() {
        return "#" + _Node.prototype.valueToString.call(this);
      };
      return ID2;
    }(_node["default"]);
    exports["default"] = ID;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/namespace.js
var require_namespace = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util();
    var _node = _interopRequireDefault(require_node());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Namespace = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Namespace2, _Node);
      function Namespace2() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Namespace2.prototype;
      _proto.qualifiedName = function qualifiedName(value) {
        if (this.namespace) {
          return this.namespaceString + "|" + value;
        } else {
          return value;
        }
      };
      _proto.valueToString = function valueToString() {
        return this.qualifiedName(_Node.prototype.valueToString.call(this));
      };
      _createClass(Namespace2, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          if (namespace === true || namespace === "*" || namespace === "&") {
            this._namespace = namespace;
            if (this.raws) {
              delete this.raws.namespace;
            }
            return;
          }
          var escaped = (0, _cssesc["default"])(namespace, {
            isIdentifier: true
          });
          this._namespace = namespace;
          if (escaped !== namespace) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.namespace = escaped;
          } else if (this.raws) {
            delete this.raws.namespace;
          }
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          this.namespace = namespace;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var ns = this.stringifyProperty("namespace");
            if (ns === true) {
              return "";
            } else {
              return ns;
            }
          } else {
            return "";
          }
        }
      }]);
      return Namespace2;
    }(_node["default"]);
    exports["default"] = Namespace;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/tag.js
var require_tag = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Tag = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Tag2, _Namespace);
      function Tag2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.TAG;
        return _this;
      }
      return Tag2;
    }(_namespace["default"]);
    exports["default"] = Tag;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/string.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var String2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(String3, _Node);
      function String3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.STRING;
        return _this;
      }
      return String3;
    }(_node["default"]);
    exports["default"] = String2;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/pseudo.js
var require_pseudo = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Pseudo = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Pseudo2, _Container);
      function Pseudo2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.PSEUDO;
        return _this;
      }
      var _proto = Pseudo2.prototype;
      _proto.toString = function toString2() {
        var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
      };
      return Pseudo2;
    }(_container["default"]);
    exports["default"] = Pseudo;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/attribute.js
var require_attribute = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.unescapeValue = unescapeValue;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _unesc = _interopRequireDefault(require_unesc());
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    var _CSSESC_QUOTE_OPTIONS;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var deprecate = require_node2();
    var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
    var warnOfDeprecatedValueAssignment = deprecate(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
    var warnOfDeprecatedQuotedAssignment = deprecate(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
    var warnOfDeprecatedConstructor = deprecate(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function unescapeValue(value) {
      var deprecatedUsage = false;
      var quoteMark = null;
      var unescaped = value;
      var m = unescaped.match(WRAPPED_IN_QUOTES);
      if (m) {
        quoteMark = m[1];
        unescaped = m[2];
      }
      unescaped = (0, _unesc["default"])(unescaped);
      if (unescaped !== value) {
        deprecatedUsage = true;
      }
      return {
        deprecatedUsage,
        unescaped,
        quoteMark
      };
    }
    function handleDeprecatedContructorOpts(opts) {
      if (opts.quoteMark !== void 0) {
        return opts;
      }
      if (opts.value === void 0) {
        return opts;
      }
      warnOfDeprecatedConstructor();
      var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
      if (!opts.raws) {
        opts.raws = {};
      }
      if (opts.raws.value === void 0) {
        opts.raws.value = opts.value;
      }
      opts.value = unescaped;
      opts.quoteMark = quoteMark;
      return opts;
    }
    var Attribute = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Attribute2, _Namespace);
      function Attribute2(opts) {
        var _this;
        if (opts === void 0) {
          opts = {};
        }
        _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, "unquoted", {
          get: deprecate(function() {
            return _this.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: deprecate(function() {
            return _this.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
      }
      var _proto = Attribute2.prototype;
      _proto.getQuotedValue = function getQuotedValue(options) {
        if (options === void 0) {
          options = {};
        }
        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc["default"])(this._value, cssescopts);
        return escaped;
      };
      _proto._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
      };
      _proto.setValue = function setValue(value, options) {
        if (options === void 0) {
          options = {};
        }
        this._value = value;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
      };
      _proto.smartQuoteMark = function smartQuoteMark(options) {
        var v = this.value;
        var numSingleQuotes = v.replace(/[^']/g, "").length;
        var numDoubleQuotes = v.replace(/[^"]/g, "").length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
          var escaped = (0, _cssesc["default"])(v, {
            isIdentifier: true
          });
          if (escaped === v) {
            return Attribute2.NO_QUOTE;
          } else {
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute2.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
              var opts = CSSESC_QUOTE_OPTIONS[quote];
              var quoteValue = (0, _cssesc["default"])(v, opts);
              if (quoteValue.length < escaped.length) {
                return quote;
              }
            }
            return pref;
          }
        } else if (numDoubleQuotes === numSingleQuotes) {
          return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
          return Attribute2.DOUBLE_QUOTE;
        } else {
          return Attribute2.SINGLE_QUOTE;
        }
      };
      _proto.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
        if (quoteMark === void 0) {
          quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }
        if (quoteMark === void 0) {
          quoteMark = Attribute2.DOUBLE_QUOTE;
        }
        return quoteMark;
      };
      _proto._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
          if (this.raws) {
            delete this.raws.value;
          }
        } else {
          this.raws.value = rawValue;
        }
      };
      _proto._handleEscapes = function _handleEscapes(prop, value) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(value, {
            isIdentifier: true
          });
          if (escaped !== value) {
            this.raws[prop] = escaped;
          } else {
            delete this.raws[prop];
          }
        }
      };
      _proto._spacesFor = function _spacesFor(name) {
        var attrSpaces = {
          before: "",
          after: ""
        };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
      };
      _proto._stringFor = function _stringFor(name, spaceName, concat) {
        if (spaceName === void 0) {
          spaceName = name;
        }
        if (concat === void 0) {
          concat = defaultAttrConcat;
        }
        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
      };
      _proto.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
          return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
          return count;
        }
        count += this.namespaceString.length;
        if (this.namespace) {
          count += 1;
        }
        if (name === "attribute") {
          return count;
        }
        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
          return operator ? count : -1;
        }
        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value = this.stringifyProperty("value");
        if (name === "value") {
          return value ? count : -1;
        }
        count += value.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
          return this.insensitive ? count : -1;
        }
        return -1;
      };
      _proto.toString = function toString2() {
        var _this2 = this;
        var selector = [this.rawSpaceBefore, "["];
        selector.push(this._stringFor("qualifiedAttribute", "attribute"));
        if (this.operator && (this.value || this.value === "")) {
          selector.push(this._stringFor("operator"));
          selector.push(this._stringFor("value"));
          selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
            if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
              attrSpaces.before = " ";
            }
            return defaultAttrConcat(attrValue, attrSpaces);
          }));
        }
        selector.push("]");
        selector.push(this.rawSpaceAfter);
        return selector.join("");
      };
      _createClass(Attribute2, [{
        key: "quoted",
        get: function get() {
          var qm = this.quoteMark;
          return qm === "'" || qm === '"';
        },
        set: function set(value) {
          warnOfDeprecatedQuotedAssignment();
        }
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set(quoteMark) {
          if (!this._constructed) {
            this._quoteMark = quoteMark;
            return;
          }
          if (this._quoteMark !== quoteMark) {
            this._quoteMark = quoteMark;
            this._syncRawValue();
          }
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v) {
          if (this._constructed) {
            var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
            if (deprecatedUsage) {
              warnOfDeprecatedValueAssignment();
            }
            if (unescaped === this._value && quoteMark === this._quoteMark) {
              return;
            }
            this._value = unescaped;
            this._quoteMark = quoteMark;
            this._syncRawValue();
          } else {
            this._value = v;
          }
        }
      }, {
        key: "insensitive",
        get: function get() {
          return this._insensitive;
        },
        set: function set(insensitive) {
          if (!insensitive) {
            this._insensitive = false;
            if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
              this.raws.insensitiveFlag = void 0;
            }
          }
          this._insensitive = insensitive;
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set(name) {
          this._handleEscapes("attribute", name);
          this._attribute = name;
        }
      }]);
      return Attribute2;
    }(_namespace["default"]);
    exports["default"] = Attribute;
    Attribute.NO_QUOTE = null;
    Attribute.SINGLE_QUOTE = "'";
    Attribute.DOUBLE_QUOTE = '"';
    var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, _CSSESC_QUOTE_OPTIONS[null] = {
      isIdentifier: true
    }, _CSSESC_QUOTE_OPTIONS);
    function defaultAttrConcat(attrValue, attrSpaces) {
      return "" + attrSpaces.before + attrValue + attrSpaces.after;
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/universal.js
var require_universal = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Universal = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Universal2, _Namespace);
      function Universal2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.UNIVERSAL;
        _this.value = "*";
        return _this;
      }
      return Universal2;
    }(_namespace["default"]);
    exports["default"] = Universal;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/combinator.js
var require_combinator = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Combinator = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Combinator2, _Node);
      function Combinator2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMBINATOR;
        return _this;
      }
      return Combinator2;
    }(_node["default"]);
    exports["default"] = Combinator;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/nesting.js
var require_nesting = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Nesting = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Nesting2, _Node);
      function Nesting2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.NESTING;
        _this.value = "&";
        return _this;
      }
      return Nesting2;
    }(_node["default"]);
    exports["default"] = Nesting;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/sortAscending.js
var require_sortAscending = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/sortAscending.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = sortAscending;
    function sortAscending(list) {
      return list.sort(function(a, b) {
        return a - b;
      });
    }
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/tokenTypes.js
var require_tokenTypes = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
    var ampersand = 38;
    exports.ampersand = ampersand;
    var asterisk = 42;
    exports.asterisk = asterisk;
    var at2 = 64;
    exports.at = at2;
    var comma = 44;
    exports.comma = comma;
    var colon = 58;
    exports.colon = colon;
    var semicolon = 59;
    exports.semicolon = semicolon;
    var openParenthesis = 40;
    exports.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    exports.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    exports.openSquare = openSquare;
    var closeSquare = 93;
    exports.closeSquare = closeSquare;
    var dollar = 36;
    exports.dollar = dollar;
    var tilde = 126;
    exports.tilde = tilde;
    var caret = 94;
    exports.caret = caret;
    var plus = 43;
    exports.plus = plus;
    var equals = 61;
    exports.equals = equals;
    var pipe = 124;
    exports.pipe = pipe;
    var greaterThan = 62;
    exports.greaterThan = greaterThan;
    var space = 32;
    exports.space = space;
    var singleQuote = 39;
    exports.singleQuote = singleQuote;
    var doubleQuote = 34;
    exports.doubleQuote = doubleQuote;
    var slash = 47;
    exports.slash = slash;
    var bang = 33;
    exports.bang = bang;
    var backslash = 92;
    exports.backslash = backslash;
    var cr = 13;
    exports.cr = cr;
    var feed = 12;
    exports.feed = feed;
    var newline = 10;
    exports.newline = newline;
    var tab = 9;
    exports.tab = tab;
    var str = singleQuote;
    exports.str = str;
    var comment = -1;
    exports.comment = comment;
    var word = -2;
    exports.word = word;
    var combinator = -3;
    exports.combinator = combinator;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/tokenize.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = tokenize;
    exports.FIELDS = void 0;
    var t = _interopRequireWildcard(require_tokenTypes());
    var _unescapable;
    var _wordDelimiters;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
    var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
    var hex = {};
    var hexChars = "0123456789abcdefABCDEF";
    for (i = 0; i < hexChars.length; i++) {
      hex[hexChars.charCodeAt(i)] = true;
    }
    var i;
    function consumeWord(css, start) {
      var next = start;
      var code;
      do {
        code = css.charCodeAt(next);
        if (wordDelimiters[code]) {
          return next - 1;
        } else if (code === t.backslash) {
          next = consumeEscape(css, next) + 1;
        } else {
          next++;
        }
      } while (next < css.length);
      return next - 1;
    }
    function consumeEscape(css, start) {
      var next = start;
      var code = css.charCodeAt(next + 1);
      if (unescapable[code]) {
      } else if (hex[code]) {
        var hexDigits = 0;
        do {
          next++;
          hexDigits++;
          code = css.charCodeAt(next + 1);
        } while (hex[code] && hexDigits < 6);
        if (hexDigits < 6 && code === t.space) {
          next++;
        }
      } else {
        next++;
      }
      return next;
    }
    var FIELDS = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    exports.FIELDS = FIELDS;
    function tokenize(input) {
      var tokens = [];
      var css = input.css.valueOf();
      var _css = css, length = _css.length;
      var offset2 = -1;
      var line = 1;
      var start = 0;
      var end = 0;
      var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
      function unclosed(what, fix) {
        if (input.safe) {
          css += fix;
          next = css.length - 1;
        } else {
          throw input.error("Unclosed " + what, line, start - offset2, start);
        }
      }
      while (start < length) {
        code = css.charCodeAt(start);
        if (code === t.newline) {
          offset2 = start;
          line += 1;
        }
        switch (code) {
          case t.space:
          case t.tab:
          case t.newline:
          case t.cr:
          case t.feed:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
              if (code === t.newline) {
                offset2 = next;
                line += 1;
              }
            } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
            tokenType = t.space;
            endLine = line;
            endColumn = next - offset2 - 1;
            end = next;
            break;
          case t.plus:
          case t.greaterThan:
          case t.tilde:
          case t.pipe:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
            tokenType = t.combinator;
            endLine = line;
            endColumn = start - offset2;
            end = next;
            break;
          case t.asterisk:
          case t.ampersand:
          case t.bang:
          case t.comma:
          case t.equals:
          case t.dollar:
          case t.caret:
          case t.openSquare:
          case t.closeSquare:
          case t.colon:
          case t.semicolon:
          case t.openParenthesis:
          case t.closeParenthesis:
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset2;
            end = next + 1;
            break;
          case t.singleQuote:
          case t.doubleQuote:
            quote = code === t.singleQuote ? "'" : '"';
            next = start;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                unclosed("quote", quote);
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === t.backslash) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            tokenType = t.str;
            endLine = line;
            endColumn = start - offset2;
            end = next + 1;
            break;
          default:
            if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
              next = css.indexOf("*/", start + 2) + 1;
              if (next === 0) {
                unclosed("comment", "*/");
              }
              content = css.slice(start, next + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset2;
              }
              tokenType = t.comment;
              line = nextLine;
              endLine = nextLine;
              endColumn = next - nextOffset;
            } else if (code === t.slash) {
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset2;
              end = next + 1;
            } else {
              next = consumeWord(css, start);
              tokenType = t.word;
              endLine = line;
              endColumn = next - offset2;
            }
            end = next + 1;
            break;
        }
        tokens.push([
          tokenType,
          line,
          start - offset2,
          endLine,
          endColumn,
          start,
          end
        ]);
        if (nextOffset) {
          offset2 = nextOffset;
          nextOffset = null;
        }
        start = end;
      }
      return tokens;
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/parser.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _root = _interopRequireDefault(require_root());
    var _selector = _interopRequireDefault(require_selector());
    var _className = _interopRequireDefault(require_className());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _tag = _interopRequireDefault(require_tag());
    var _string = _interopRequireDefault(require_string());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _attribute = _interopRequireWildcard(require_attribute());
    var _universal = _interopRequireDefault(require_universal());
    var _combinator = _interopRequireDefault(require_combinator());
    var _nesting = _interopRequireDefault(require_nesting());
    var _sortAscending = _interopRequireDefault(require_sortAscending());
    var _tokenize = _interopRequireWildcard(require_tokenize());
    var tokens = _interopRequireWildcard(require_tokenTypes());
    var types2 = _interopRequireWildcard(require_types());
    var _util = require_util();
    var _WHITESPACE_TOKENS;
    var _Object$assign;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
    var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
    function tokenStart(token) {
      return {
        line: token[_tokenize.FIELDS.START_LINE],
        column: token[_tokenize.FIELDS.START_COL]
      };
    }
    function tokenEnd(token) {
      return {
        line: token[_tokenize.FIELDS.END_LINE],
        column: token[_tokenize.FIELDS.END_COL]
      };
    }
    function getSource(startLine, startColumn, endLine, endColumn) {
      return {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      };
    }
    function getTokenSource(token) {
      return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
    }
    function getTokenSourceSpan(startToken, endToken) {
      if (!startToken) {
        return void 0;
      }
      return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
    }
    function unescapeProp(node, prop) {
      var value = node[prop];
      if (typeof value !== "string") {
        return;
      }
      if (value.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node, "raws");
        node[prop] = (0, _util.unesc)(value);
        if (node.raws[prop] === void 0) {
          node.raws[prop] = value;
        }
      }
      return node;
    }
    function indexesOf(array, item) {
      var i = -1;
      var indexes = [];
      while ((i = array.indexOf(item, i + 1)) !== -1) {
        indexes.push(i);
      }
      return indexes;
    }
    function uniqs() {
      var list = Array.prototype.concat.apply([], arguments);
      return list.filter(function(item, i) {
        return i === list.indexOf(item);
      });
    }
    var Parser3 = /* @__PURE__ */ function() {
      function Parser4(rule, options) {
        if (options === void 0) {
          options = {};
        }
        this.rule = rule;
        this.options = Object.assign({
          lossy: false,
          safe: false
        }, options);
        this.position = 0;
        this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
        this.tokens = (0, _tokenize["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root["default"]({
          source: rootSource
        });
        this.root.errorGenerator = this._errorGenerator();
        var selector = new _selector["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          }
        });
        this.root.append(selector);
        this.current = selector;
        this.loop();
      }
      var _proto = Parser4.prototype;
      _proto._errorGenerator = function _errorGenerator() {
        var _this = this;
        return function(message, errorOptions) {
          if (typeof _this.rule === "string") {
            return new Error(message);
          }
          return _this.rule.error(message, errorOptions);
        };
      };
      _proto.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          attr.push(this.currToken);
          this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }
        var len = attr.length;
        var node = {
          source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };
        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
          return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
        }
        var pos = 0;
        var spaceBefore = "";
        var commentBefore = "";
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;
        while (pos < len) {
          var token = attr[pos];
          var content = this.content(token);
          var next = attr[pos + 1];
          switch (token[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              spaceAfterMeaningfulToken = true;
              if (this.options.lossy) {
                break;
              }
              if (lastAdded) {
                (0, _util.ensureObject)(node, "spaces", lastAdded);
                var prevContent = node.spaces[lastAdded].after || "";
                node.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                if (existingComment) {
                  node.raws.spaces[lastAdded].after = existingComment + content;
                }
              } else {
                spaceBefore = spaceBefore + content;
                commentBefore = commentBefore + content;
              }
              break;
            case tokens.asterisk:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = spaceBefore;
                  commentBefore = "";
                }
                node.namespace = (node.namespace || "") + content;
                var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                if (rawValue) {
                  node.raws.namespace += content;
                }
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.dollar:
              if (lastAdded === "value") {
                var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                node.value += "$";
                if (oldRawValue) {
                  node.raws.value = oldRawValue + "$";
                }
                break;
              }
            case tokens.caret:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.combinator:
              if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              if (content !== "|") {
                spaceAfterMeaningfulToken = false;
                break;
              }
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if (!node.namespace && !node.attribute) {
                node.namespace = true;
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.word:
              if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node.operator && !node.namespace) {
                node.namespace = content;
                lastAdded = "namespace";
              } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = commentBefore;
                  commentBefore = "";
                }
                node.attribute = (node.attribute || "") + content;
                var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                if (_rawValue) {
                  node.raws.attribute += content;
                }
                lastAdded = "attribute";
              } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
                var _unescaped = (0, _util.unesc)(content);
                var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                var oldValue = node.value || "";
                node.value = oldValue + _unescaped;
                node.quoteMark = null;
                if (_unescaped !== content || _oldRawValue) {
                  (0, _util.ensureObject)(node, "raws");
                  node.raws.value = (_oldRawValue || oldValue) + content;
                }
                lastAdded = "value";
              } else {
                var insensitive = content === "i" || content === "I";
                if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                  node.insensitive = insensitive;
                  if (!insensitive || content === "I") {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.insensitiveFlag = content;
                  }
                  lastAdded = "insensitive";
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "insensitive");
                    node.spaces.insensitive.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                    node.raws.spaces.insensitive.before = commentBefore;
                    commentBefore = "";
                  }
                } else if (node.value || node.value === "") {
                  lastAdded = "value";
                  node.value += content;
                  if (node.raws.value) {
                    node.raws.value += content;
                  }
                }
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.str:
              if (!node.attribute || !node.operator) {
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node.value = unescaped;
              node.quoteMark = quoteMark;
              lastAdded = "value";
              (0, _util.ensureObject)(node, "raws");
              node.raws.value = content;
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.equals:
              if (!node.attribute) {
                return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
              }
              if (node.value) {
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              node.operator = node.operator ? node.operator + content : content;
              lastAdded = "operator";
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.comment:
              if (lastAdded) {
                if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                  var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                  var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                  (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                  node.raws.spaces[lastAdded].after = rawLastComment + content;
                } else {
                  var lastValue = node[lastAdded] || "";
                  var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                  (0, _util.ensureObject)(node, "raws");
                  node.raws[lastAdded] = rawLastValue + content;
                }
              } else {
                commentBefore = commentBefore + content;
              }
              break;
            default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
          }
          pos++;
        }
        unescapeProp(node, "attribute");
        unescapeProp(node, "namespace");
        this.newNode(new _attribute["default"](node));
        this.position++;
      };
      _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
          stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = void 0;
        do {
          if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            if (!this.options.lossy) {
              space += this.content();
            }
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
            var spaces = {};
            if (space) {
              spaces.before = space;
              space = "";
            }
            lastComment = new _comment["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              spaces
            });
            nodes.push(lastComment);
          }
        } while (++this.position < stopPosition);
        if (space) {
          if (lastComment) {
            lastComment.spaces.after = space;
          } else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition];
            var lastToken = this.tokens[this.position - 1];
            nodes.push(new _string["default"]({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
        }
        return nodes;
      };
      _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
        var _this2 = this;
        if (requiredSpace === void 0) {
          requiredSpace = false;
        }
        var space = "";
        var rawSpace = "";
        nodes.forEach(function(n) {
          var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
          var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
          space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
          rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
          rawSpace = void 0;
        }
        var result = {
          space,
          rawSpace
        };
        return result;
      };
      _proto.isNamedCombinator = function isNamedCombinator(position) {
        if (position === void 0) {
          position = this.position;
        }
        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
      };
      _proto.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
          var nameRaw = this.content(this.tokens[this.position + 1]);
          var name = (0, _util.unesc)(nameRaw).toLowerCase();
          var raws = {};
          if (name !== nameRaw) {
            raws.value = "/" + nameRaw + "/";
          }
          var node = new _combinator["default"]({
            value: "/" + name + "/",
            source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            raws
          });
          this.position = this.position + 3;
          return node;
        } else {
          this.unexpected();
        }
      };
      _proto.combinator = function combinator() {
        var _this3 = this;
        if (this.content() === "|") {
          return this.namespace();
        }
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              if (rawSpace !== void 0) {
                last.rawSpaceAfter += rawSpace;
              }
              last.spaces.after += space;
            } else {
              nodes.forEach(function(n) {
                return _this3.newNode(n);
              });
            }
          }
          return;
        }
        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = void 0;
        if (nextSigTokenPos > this.position) {
          spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }
        var node;
        if (this.isNamedCombinator()) {
          node = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
          node = new _combinator["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
          });
          this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        } else if (!spaceOrDescendantSelectorNodes) {
          this.unexpected();
        }
        if (node) {
          if (spaceOrDescendantSelectorNodes) {
            var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
            node.spaces.before = _space;
            node.rawSpaceBefore = _rawSpace;
          }
        } else {
          var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
          if (!_rawSpace2) {
            _rawSpace2 = _space2;
          }
          var spaces = {};
          var raws = {
            spaces: {}
          };
          if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
            spaces.before = _space2.slice(0, _space2.length - 1);
            raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
          } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
            spaces.after = _space2.slice(1);
            raws.spaces.after = _rawSpace2.slice(1);
          } else {
            raws.value = _rawSpace2;
          }
          node = new _combinator["default"]({
            value: " ",
            source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces,
            raws
          });
        }
        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
          node.spaces.after = this.optionalSpace(this.content());
          this.position++;
        }
        return this.newNode(node);
      };
      _proto.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true;
          this.position++;
          return;
        }
        this.current._inferEndPosition();
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position + 1])
          }
        });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
      };
      _proto.comment = function comment() {
        var current2 = this.currToken;
        this.newNode(new _comment["default"]({
          value: this.content(),
          source: getTokenSource(current2),
          sourceIndex: current2[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.error = function error(message, opts) {
        throw this.root.error(message, opts);
      };
      _proto.missingBackslash = function missingBackslash() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[_tokenize.FIELDS.START_POS]
        });
      };
      _proto.missingParenthesis = function missingParenthesis() {
        return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.missingSquareBracket = function missingSquareBracket() {
        return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpected = function unexpected() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.position++;
          return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
          this.position++;
          return this.universal(before);
        }
      };
      _proto.nesting = function nesting() {
        if (this.nextToken) {
          var nextContent = this.content(this.nextToken);
          if (nextContent === "|") {
            this.position++;
            return;
          }
        }
        var current2 = this.currToken;
        this.newNode(new _nesting["default"]({
          value: this.content(),
          source: getTokenSource(current2),
          sourceIndex: current2[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types2.PSEUDO) {
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position - 1])
            }
          });
          var cache = this.current;
          last.append(selector);
          this.current = selector;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            if (unbalanced) {
              this.parse();
            } else {
              this.current.source.end = tokenEnd(this.currToken);
              this.current.parent.source.end = tokenEnd(this.currToken);
              this.position++;
            }
          }
          this.current = cache;
        } else {
          var parenStart = this.currToken;
          var parenValue = "(";
          var parenEnd;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            parenEnd = this.currToken;
            parenValue += this.parseParenthesisToken(this.currToken);
            this.position++;
          }
          if (last) {
            last.appendToPropertyAndEscape("value", parenValue, parenValue);
          } else {
            this.newNode(new _string["default"]({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
        }
        if (unbalanced) {
          return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.pseudo = function pseudo() {
        var _this4 = this;
        var pseudoStr = "";
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
          pseudoStr += this.content();
          this.position++;
        }
        if (!this.currToken) {
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.splitWord(false, function(first, length) {
            pseudoStr += first;
            _this4.newNode(new _pseudo["default"]({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            }));
            if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              _this4.error("Misplaced parenthesis.", {
                index: _this4.nextToken[_tokenize.FIELDS.START_POS]
              });
            }
          });
        } else {
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.space = function space() {
        var content = this.content();
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
          return node.type === "comment";
        })) {
          this.spaces = this.optionalSpace(content);
          this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          this.current.last.spaces.after = this.optionalSpace(content);
          this.position++;
        } else {
          this.combinator();
        }
      };
      _proto.string = function string() {
        var current2 = this.currToken;
        this.newNode(new _string["default"]({
          value: this.content(),
          source: getTokenSource(current2),
          sourceIndex: current2[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        var current2 = this.currToken;
        this.newNode(new _universal["default"]({
          value: this.content(),
          source: getTokenSource(current2),
          sourceIndex: current2[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
      };
      _proto.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;
        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
          this.position++;
          var current2 = this.content();
          word += current2;
          if (current2.lastIndexOf("\\") === current2.length - 1) {
            var next = this.nextToken;
            if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
              word += this.requiredSpace(this.content(next));
              this.position++;
            }
          }
          nextToken = this.nextToken;
        }
        var hasClass = indexesOf(word, ".").filter(function(i) {
          var escapedDot = word[i - 1] === "\\";
          var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
          return !escapedDot && !isKeyframesPercent;
        });
        var hasId = indexesOf(word, "#").filter(function(i) {
          return word[i - 1] !== "\\";
        });
        var interpolations = indexesOf(word, "#{");
        if (interpolations.length) {
          hasId = hasId.filter(function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          });
        }
        var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
        indices.forEach(function(ind, i) {
          var index = indices[i + 1] || word.length;
          var value = word.slice(ind, index);
          if (i === 0 && firstCallback) {
            return firstCallback.call(_this5, value, indices.length);
          }
          var node;
          var current3 = _this5.currToken;
          var sourceIndex = current3[_tokenize.FIELDS.START_POS] + indices[i];
          var source = getSource(current3[1], current3[2] + ind, current3[3], current3[2] + (index - 1));
          if (~hasClass.indexOf(ind)) {
            var classNameOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _className["default"](unescapeProp(classNameOpts, "value"));
          } else if (~hasId.indexOf(ind)) {
            var idOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _id["default"](unescapeProp(idOpts, "value"));
          } else {
            var tagOpts = {
              value,
              source,
              sourceIndex
            };
            unescapeProp(tagOpts, "value");
            node = new _tag["default"](tagOpts);
          }
          _this5.newNode(node, namespace);
          namespace = null;
        });
        this.position++;
      };
      _proto.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        return this.splitWord(namespace);
      };
      _proto.loop = function loop() {
        while (this.position < this.tokens.length) {
          this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
      };
      _proto.parse = function parse4(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            this.space();
            break;
          case tokens.comment:
            this.comment();
            break;
          case tokens.openParenthesis:
            this.parentheses();
            break;
          case tokens.closeParenthesis:
            if (throwOnParenthesis) {
              this.missingParenthesis();
            }
            break;
          case tokens.openSquare:
            this.attribute();
            break;
          case tokens.dollar:
          case tokens.caret:
          case tokens.equals:
          case tokens.word:
            this.word();
            break;
          case tokens.colon:
            this.pseudo();
            break;
          case tokens.comma:
            this.comma();
            break;
          case tokens.asterisk:
            this.universal();
            break;
          case tokens.ampersand:
            this.nesting();
            break;
          case tokens.slash:
          case tokens.combinator:
            this.combinator();
            break;
          case tokens.str:
            this.string();
            break;
          case tokens.closeSquare:
            this.missingSquareBracket();
          case tokens.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      };
      _proto.expected = function expected(description, index, found) {
        if (Array.isArray(description)) {
          var last = description.pop();
          description = description.join(", ") + " or " + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
        if (!found) {
          return this.error("Expected " + an + " " + description + ".", {
            index
          });
        }
        return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
          index
        });
      };
      _proto.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? " " : space;
      };
      _proto.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? "" : space;
      };
      _proto.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
          return required ? " " : "";
        } else {
          return space;
        }
      };
      _proto.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
          return this.requiredSpace(content);
        } else {
          return content;
        }
      };
      _proto.newNode = function newNode(node, namespace) {
        if (namespace) {
          if (/^ +$/.test(namespace)) {
            if (!this.options.lossy) {
              this.spaces = (this.spaces || "") + namespace;
            }
            namespace = true;
          }
          node.namespace = namespace;
          unescapeProp(node, "namespace");
        }
        if (this.spaces) {
          node.spaces.before = this.spaces;
          this.spaces = "";
        }
        return this.current.append(node);
      };
      _proto.content = function content(token) {
        if (token === void 0) {
          token = this.currToken;
        }
        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
      };
      _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
        if (startPosition === void 0) {
          startPosition = this.position + 1;
        }
        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
          if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
            searchPosition++;
            continue;
          } else {
            return searchPosition;
          }
        }
        return -1;
      };
      _createClass(Parser4, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]);
      return Parser4;
    }();
    exports["default"] = Parser3;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/processor.js
var require_processor = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/processor.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _parser = _interopRequireDefault(require_parser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var Processor = /* @__PURE__ */ function() {
      function Processor2(func, options) {
        this.func = func || function noop() {
        };
        this.funcRes = null;
        this.options = options;
      }
      var _proto = Processor2.prototype;
      _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
          return false;
        } else {
          return typeof rule !== "string";
        }
      };
      _proto._isLossy = function _isLossy(options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
          return true;
        } else {
          return false;
        }
      };
      _proto._root = function _root(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var parser = new _parser["default"](rule, this._parseOptions(options));
        return parser.root;
      };
      _proto._parseOptions = function _parseOptions(options) {
        return {
          lossy: this._isLossy(options)
        };
      };
      _proto._run = function _run(rule, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        return new Promise(function(resolve, reject) {
          try {
            var root = _this._root(rule, options);
            Promise.resolve(_this.func(root)).then(function(transform) {
              var string = void 0;
              if (_this._shouldUpdateSelector(rule, options)) {
                string = root.toString();
                rule.selector = string;
              }
              return {
                transform,
                root,
                string
              };
            }).then(resolve, reject);
          } catch (e) {
            reject(e);
            return;
          }
        });
      };
      _proto._runSync = function _runSync(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var root = this._root(rule, options);
        var transform = this.func(root);
        if (transform && typeof transform.then === "function") {
          throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = void 0;
        if (options.updateSelector && typeof rule !== "string") {
          string = root.toString();
          rule.selector = string;
        }
        return {
          transform,
          root,
          string
        };
      };
      _proto.ast = function ast(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.root;
        });
      };
      _proto.astSync = function astSync(rule, options) {
        return this._runSync(rule, options).root;
      };
      _proto.transform = function transform(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.transform;
        });
      };
      _proto.transformSync = function transformSync(rule, options) {
        return this._runSync(rule, options).transform;
      };
      _proto.process = function process2(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.string || result.root.toString();
        });
      };
      _proto.processSync = function processSync(rule, options) {
        var result = this._runSync(rule, options);
        return result.string || result.root.toString();
      };
      return Processor2;
    }();
    exports["default"] = Processor;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/constructors.js
var require_constructors = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
    var _attribute = _interopRequireDefault(require_attribute());
    var _className = _interopRequireDefault(require_className());
    var _combinator = _interopRequireDefault(require_combinator());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _nesting = _interopRequireDefault(require_nesting());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _root = _interopRequireDefault(require_root());
    var _selector = _interopRequireDefault(require_selector());
    var _string = _interopRequireDefault(require_string());
    var _tag = _interopRequireDefault(require_tag());
    var _universal = _interopRequireDefault(require_universal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    exports.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    exports.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    exports.combinator = combinator;
    var comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    exports.comment = comment;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    exports.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    exports.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    exports.pseudo = pseudo;
    var root = function root2(opts) {
      return new _root["default"](opts);
    };
    exports.root = root;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    exports.selector = selector;
    var string = function string2(opts) {
      return new _string["default"](opts);
    };
    exports.string = string;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    exports.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    exports.universal = universal;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/guards.js
var require_guards = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.isNode = isNode;
    exports.isPseudoElement = isPseudoElement;
    exports.isPseudoClass = isPseudoClass;
    exports.isContainer = isContainer;
    exports.isNamespace = isNamespace;
    exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
    var _types = require_types();
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node) {
      return typeof node === "object" && IS_TYPE[node.type];
    }
    function isNodeType(type, node) {
      return isNode(node) && node.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    exports.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    exports.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    exports.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    exports.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    exports.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    exports.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    exports.isPseudo = isPseudo;
    var isRoot = isNodeType.bind(null, _types.ROOT);
    exports.isRoot = isRoot;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    exports.isSelector = isSelector;
    var isString = isNodeType.bind(null, _types.STRING);
    exports.isString = isString;
    var isTag = isNodeType.bind(null, _types.TAG);
    exports.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    exports.isUniversal = isUniversal;
    function isPseudoElement(node) {
      return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
    }
    function isPseudoClass(node) {
      return isPseudo(node) && !isPseudoElement(node);
    }
    function isContainer(node) {
      return !!(isNode(node) && node.walk);
    }
    function isNamespace(node) {
      return isAttribute(node) || isTag(node);
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/index.js
var require_selectors = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/selectors/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _types[key])
        return;
      exports[key] = _types[key];
    });
    var _constructors = require_constructors();
    Object.keys(_constructors).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _constructors[key])
        return;
      exports[key] = _constructors[key];
    });
    var _guards = require_guards();
    Object.keys(_guards).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _guards[key])
        return;
      exports[key] = _guards[key];
    });
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.11/node_modules/postcss-selector-parser/dist/index.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _processor = _interopRequireDefault(require_processor());
    var selectors = _interopRequireWildcard(require_selectors());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var parser = function parser2(processor) {
      return new _processor["default"](processor);
    };
    Object.assign(parser, selectors);
    delete parser.__esModule;
    var _default = parser;
    exports["default"] = _default;
    module2.exports = exports.default;
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/escapeCommas.js
var require_escapeCommas = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/escapeCommas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => escapeCommas
    });
    function escapeCommas(className) {
      return className.replace(/\\,/g, "\\2c ");
    }
  }
});

// node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/color.js
var require_color = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/color.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      parseColor: () => parseColor,
      formatColor: () => formatColor
    });
    var _colorName = /* @__PURE__ */ _interopRequireDefault(require_color_name());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
    var SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
    var VALUE = /(?:\d+|\d*\.\d+)%?/;
    var SEP = /(?:\s*,\s*|\s+)/;
    var ALPHA_SEP = /\s*[,/]\s*/;
    var CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)\)/;
    var RGB = new RegExp(`^(rgb)a?\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
    var HSL = new RegExp(`^(hsl)a?\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
    function parseColor(value, { loose = false } = {}) {
      var ref2, ref1;
      if (typeof value !== "string") {
        return null;
      }
      value = value.trim();
      if (value === "transparent") {
        return {
          mode: "rgb",
          color: [
            "0",
            "0",
            "0"
          ],
          alpha: "0"
        };
      }
      if (value in _colorName.default) {
        return {
          mode: "rgb",
          color: _colorName.default[value].map((v) => v.toString())
        };
      }
      let hex = value.replace(SHORT_HEX, (_, r, g, b, a) => [
        "#",
        r,
        r,
        g,
        g,
        b,
        b,
        a ? a + a : ""
      ].join("")).match(HEX);
      if (hex !== null) {
        return {
          mode: "rgb",
          color: [
            parseInt(hex[1], 16),
            parseInt(hex[2], 16),
            parseInt(hex[3], 16)
          ].map((v) => v.toString()),
          alpha: hex[4] ? (parseInt(hex[4], 16) / 255).toString() : void 0
        };
      }
      var ref22;
      let match = (ref22 = value.match(RGB)) !== null && ref22 !== void 0 ? ref22 : value.match(HSL);
      if (match === null) {
        return null;
      }
      let color = [
        match[2],
        match[3],
        match[4]
      ].filter(Boolean).map((v) => v.toString());
      if (!loose && color.length !== 3) {
        return null;
      }
      if (color.length < 3 && !color.some((part) => /^var\(.*?\)$/.test(part))) {
        return null;
      }
      return {
        mode: match[1],
        color,
        alpha: (ref2 = match[5]) === null || ref2 === void 0 ? void 0 : (ref1 = ref2.toString) === null || ref1 === void 0 ? void 0 : ref1.call(ref2)
      };
    }
    function formatColor({ mode, color, alpha }) {
      let hasAlpha = alpha !== void 0;
      return `${mode}(${color.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/withAlphaVariable.js
var require_withAlphaVariable = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/withAlphaVariable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      withAlphaValue: () => withAlphaValue,
      default: () => withAlphaVariable
    });
    var _color = require_color();
    function withAlphaValue(color, alphaValue, defaultValue) {
      if (typeof color === "function") {
        return color({
          opacityValue: alphaValue
        });
      }
      let parsed = (0, _color.parseColor)(color, {
        loose: true
      });
      if (parsed === null) {
        return defaultValue;
      }
      return (0, _color.formatColor)({
        ...parsed,
        alpha: alphaValue
      });
    }
    function withAlphaVariable({ color, property, variable }) {
      let properties = [].concat(property);
      if (typeof color === "function") {
        return {
          [variable]: "1",
          ...Object.fromEntries(properties.map((p) => {
            return [
              p,
              color({
                opacityVariable: variable,
                opacityValue: `var(${variable})`
              })
            ];
          }))
        };
      }
      const parsed = (0, _color.parseColor)(color);
      if (parsed === null) {
        return Object.fromEntries(properties.map((p) => [
          p,
          color
        ]));
      }
      if (parsed.alpha !== void 0) {
        return Object.fromEntries(properties.map((p) => [
          p,
          color
        ]));
      }
      return {
        [variable]: "1",
        ...Object.fromEntries(properties.map((p) => {
          return [
            p,
            (0, _color.formatColor)({
              ...parsed,
              alpha: `var(${variable})`
            })
          ];
        }))
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js
var require_splitAtTopLevelOnly = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "splitAtTopLevelOnly", {
      enumerable: true,
      get: () => splitAtTopLevelOnly
    });
    function splitAtTopLevelOnly(input, separator) {
      let stack = [];
      let parts = [];
      let lastPos = 0;
      for (let idx = 0; idx < input.length; idx++) {
        let char = input[idx];
        if (stack.length === 0 && char === separator[0]) {
          if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
            parts.push(input.slice(lastPos, idx));
            lastPos = idx + separator.length;
          }
        }
        if (char === "(" || char === "[" || char === "{") {
          stack.push(char);
        } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
          stack.pop();
        }
      }
      parts.push(input.slice(lastPos));
      return parts;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseBoxShadowValue.js
var require_parseBoxShadowValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseBoxShadowValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      parseBoxShadowValue: () => parseBoxShadowValue,
      formatBoxShadowValue: () => formatBoxShadowValue
    });
    var _splitAtTopLevelOnly = require_splitAtTopLevelOnly();
    var KEYWORDS = /* @__PURE__ */ new Set([
      "inset",
      "inherit",
      "initial",
      "revert",
      "unset"
    ]);
    var SPACE = /\ +(?![^(]*\))/g;
    var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
    function parseBoxShadowValue(input) {
      let shadows = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, ",");
      return shadows.map((shadow) => {
        let value = shadow.trim();
        let result = {
          raw: value
        };
        let parts = value.split(SPACE);
        let seen = /* @__PURE__ */ new Set();
        for (let part of parts) {
          LENGTH.lastIndex = 0;
          if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
            result.keyword = part;
            seen.add("KEYWORD");
          } else if (LENGTH.test(part)) {
            if (!seen.has("X")) {
              result.x = part;
              seen.add("X");
            } else if (!seen.has("Y")) {
              result.y = part;
              seen.add("Y");
            } else if (!seen.has("BLUR")) {
              result.blur = part;
              seen.add("BLUR");
            } else if (!seen.has("SPREAD")) {
              result.spread = part;
              seen.add("SPREAD");
            }
          } else {
            if (!result.color) {
              result.color = part;
            } else {
              if (!result.unknown)
                result.unknown = [];
              result.unknown.push(part);
            }
          }
        }
        result.valid = result.x !== void 0 && result.y !== void 0;
        return result;
      });
    }
    function formatBoxShadowValue(shadows) {
      return shadows.map((shadow) => {
        if (!shadow.valid) {
          return shadow.raw;
        }
        return [
          shadow.keyword,
          shadow.x,
          shadow.y,
          shadow.blur,
          shadow.spread,
          shadow.color
        ].filter(Boolean).join(" ");
      }).join(", ");
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/dataTypes.js
var require_dataTypes = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/dataTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      normalize: () => normalize,
      url: () => url,
      number: () => number,
      percentage: () => percentage,
      length: () => length,
      lineWidth: () => lineWidth,
      shadow: () => shadow,
      color: () => color,
      image: () => image,
      gradient: () => gradient,
      position: () => position,
      familyName: () => familyName,
      genericName: () => genericName,
      absoluteSize: () => absoluteSize,
      relativeSize: () => relativeSize
    });
    var _color = require_color();
    var _parseBoxShadowValue = require_parseBoxShadowValue();
    var _splitAtTopLevelOnly = require_splitAtTopLevelOnly();
    var cssFunctions = [
      "min",
      "max",
      "clamp",
      "calc"
    ];
    function isCSSFunction(value) {
      return cssFunctions.some((fn) => new RegExp(`^${fn}\\(.*\\)`).test(value));
    }
    function normalize(value, isRoot = true) {
      if (value.includes("url(")) {
        return value.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
          if (/^url\(.*?\)$/.test(part)) {
            return part;
          }
          return normalize(part, false);
        }).join("");
      }
      value = value.replace(/([^\\])_+/g, (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_");
      if (isRoot) {
        value = value.trim();
      }
      value = value.replace(/(calc|min|max|clamp)\(.+\)/g, (match) => {
        return match.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ");
      });
      return value;
    }
    function url(value) {
      return value.startsWith("url(");
    }
    function number(value) {
      return !isNaN(Number(value)) || isCSSFunction(value);
    }
    function percentage(value) {
      return value.endsWith("%") && number(value.slice(0, -1)) || isCSSFunction(value);
    }
    var lengthUnits = [
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px",
      "em",
      "ex",
      "ch",
      "rem",
      "lh",
      "vw",
      "vh",
      "vmin",
      "vmax"
    ];
    var lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
    function length(value) {
      return value === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value) || isCSSFunction(value);
    }
    var lineWidths = /* @__PURE__ */ new Set([
      "thin",
      "medium",
      "thick"
    ]);
    function lineWidth(value) {
      return lineWidths.has(value);
    }
    function shadow(value) {
      let parsedShadows = (0, _parseBoxShadowValue.parseBoxShadowValue)(normalize(value));
      for (let parsedShadow of parsedShadows) {
        if (!parsedShadow.valid) {
          return false;
        }
      }
      return true;
    }
    function color(value) {
      let colors = 0;
      let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if ((0, _color.parseColor)(part, {
          loose: true
        }) !== null)
          return colors++, true;
        return false;
      });
      if (!result)
        return false;
      return colors > 0;
    }
    function image(value) {
      let images = 0;
      let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if (url(part) || gradient(part) || [
          "element(",
          "image(",
          "cross-fade(",
          "image-set("
        ].some((fn) => part.startsWith(fn))) {
          images++;
          return true;
        }
        return false;
      });
      if (!result)
        return false;
      return images > 0;
    }
    var gradientTypes = /* @__PURE__ */ new Set([
      "linear-gradient",
      "radial-gradient",
      "repeating-linear-gradient",
      "repeating-radial-gradient",
      "conic-gradient"
    ]);
    function gradient(value) {
      value = normalize(value);
      for (let type of gradientTypes) {
        if (value.startsWith(`${type}(`)) {
          return true;
        }
      }
      return false;
    }
    var validPositions = /* @__PURE__ */ new Set([
      "center",
      "top",
      "right",
      "bottom",
      "left"
    ]);
    function position(value) {
      let positions = 0;
      let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if (validPositions.has(part) || length(part) || percentage(part)) {
          positions++;
          return true;
        }
        return false;
      });
      if (!result)
        return false;
      return positions > 0;
    }
    function familyName(value) {
      let fonts = 0;
      let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if (part.includes(" ")) {
          if (!/(['"])([^"']+)\1/g.test(part)) {
            return false;
          }
        }
        if (/^\d/g.test(part)) {
          return false;
        }
        fonts++;
        return true;
      });
      if (!result)
        return false;
      return fonts > 0;
    }
    var genericNames = /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "math",
      "emoji",
      "fangsong"
    ]);
    function genericName(value) {
      return genericNames.has(value);
    }
    var absoluteSizes = /* @__PURE__ */ new Set([
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "x-large",
      "xxx-large"
    ]);
    function absoluteSize(value) {
      return absoluteSizes.has(value);
    }
    var relativeSizes = /* @__PURE__ */ new Set([
      "larger",
      "smaller"
    ]);
    function relativeSize(value) {
      return relativeSizes.has(value);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/validateFormalSyntax.js
var require_validateFormalSyntax = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/validateFormalSyntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "backgroundSize", {
      enumerable: true,
      get: () => backgroundSize
    });
    var _dataTypes = require_dataTypes();
    var _splitAtTopLevelOnly = require_splitAtTopLevelOnly();
    function backgroundSize(value) {
      let keywordValues = [
        "cover",
        "contain"
      ];
      return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part) => {
        let sizes = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(part, "_").filter(Boolean);
        if (sizes.length === 1 && keywordValues.includes(sizes[0]))
          return true;
        if (sizes.length !== 1 && sizes.length !== 2)
          return false;
        return sizes.every((size) => (0, _dataTypes.length)(size) || (0, _dataTypes.percentage)(size) || size === "auto");
      });
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/featureFlags.js
var require_featureFlags = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/featureFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      flagEnabled: () => flagEnabled,
      issueFlagNotices: () => issueFlagNotices,
      default: () => _default
    });
    var _picocolors = /* @__PURE__ */ _interopRequireDefault(require_picocolors());
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var defaults = {
      optimizeUniversalDefaults: false,
      generalizedModifiers: true
    };
    var featureFlags = {
      future: [
        "hoverOnlyWhenSupported",
        "respectDefaultRingColorOpacity",
        "disableColorOpacityUtilitiesByDefault",
        "relativeContentPathsByDefault"
      ],
      experimental: [
        "optimizeUniversalDefaults",
        "generalizedModifiers"
      ]
    };
    function flagEnabled(config, flag) {
      if (featureFlags.future.includes(flag)) {
        var ref2;
        var ref1, ref22;
        return config.future === "all" || ((ref22 = (ref1 = config === null || config === void 0 ? void 0 : (ref2 = config.future) === null || ref2 === void 0 ? void 0 : ref2[flag]) !== null && ref1 !== void 0 ? ref1 : defaults[flag]) !== null && ref22 !== void 0 ? ref22 : false);
      }
      if (featureFlags.experimental.includes(flag)) {
        var ref3;
        var ref4, ref5;
        return config.experimental === "all" || ((ref5 = (ref4 = config === null || config === void 0 ? void 0 : (ref3 = config.experimental) === null || ref3 === void 0 ? void 0 : ref3[flag]) !== null && ref4 !== void 0 ? ref4 : defaults[flag]) !== null && ref5 !== void 0 ? ref5 : false);
      }
      return false;
    }
    function experimentalFlagsEnabled(config) {
      if (config.experimental === "all") {
        return featureFlags.experimental;
      }
      var ref2;
      return Object.keys((ref2 = config === null || config === void 0 ? void 0 : config.experimental) !== null && ref2 !== void 0 ? ref2 : {}).filter((flag) => featureFlags.experimental.includes(flag) && config.experimental[flag]);
    }
    function issueFlagNotices(config) {
      if (process.env.JEST_WORKER_ID !== void 0) {
        return;
      }
      if (experimentalFlagsEnabled(config).length > 0) {
        let changes = experimentalFlagsEnabled(config).map((s) => _picocolors.default.yellow(s)).join(", ");
        _log.default.warn("experimental-flags-enabled", [
          `You have enabled experimental features: ${changes}`,
          "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
        ]);
      }
    }
    var _default = featureFlags;
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/pluginUtils.js
var require_pluginUtils = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/pluginUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      updateAllClasses: () => updateAllClasses,
      filterSelectorsForClass: () => filterSelectorsForClass,
      asValue: () => asValue,
      parseColorFormat: () => parseColorFormat,
      asColor: () => asColor,
      asLookupValue: () => asLookupValue,
      typeMap: () => typeMap,
      coerceValue: () => coerceValue,
      getMatchingTypes: () => getMatchingTypes
    });
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _escapeCommas = /* @__PURE__ */ _interopRequireDefault(require_escapeCommas());
    var _withAlphaVariable = require_withAlphaVariable();
    var _dataTypes = require_dataTypes();
    var _negateValue = /* @__PURE__ */ _interopRequireDefault(require_negateValue());
    var _validateFormalSyntax = require_validateFormalSyntax();
    var _featureFlagsJs = require_featureFlags();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function updateAllClasses(selectors, updateClass) {
      let parser = (0, _postcssSelectorParser.default)((selectors2) => {
        selectors2.walkClasses((sel) => {
          let updatedClass = updateClass(sel.value);
          sel.value = updatedClass;
          if (sel.raws && sel.raws.value) {
            sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);
          }
        });
      });
      let result = parser.processSync(selectors);
      return result;
    }
    function filterSelectorsForClass(selectors, classCandidate) {
      let parser = (0, _postcssSelectorParser.default)((selectors2) => {
        selectors2.each((sel) => {
          const containsClass = sel.nodes.some((node) => node.type === "class" && node.value === classCandidate);
          if (!containsClass) {
            sel.remove();
          }
        });
      });
      let result = parser.processSync(selectors);
      return result;
    }
    function resolveArbitraryValue(modifier, validate) {
      if (!isArbitraryValue(modifier)) {
        return void 0;
      }
      let value = modifier.slice(1, -1);
      if (!validate(value)) {
        return void 0;
      }
      return (0, _dataTypes.normalize)(value);
    }
    function asNegativeValue(modifier, lookup = {}, validate) {
      let positiveValue = lookup[modifier];
      if (positiveValue !== void 0) {
        return (0, _negateValue.default)(positiveValue);
      }
      if (isArbitraryValue(modifier)) {
        let resolved = resolveArbitraryValue(modifier, validate);
        if (resolved === void 0) {
          return void 0;
        }
        return (0, _negateValue.default)(resolved);
      }
    }
    function asValue(modifier, options = {}, { validate = () => true } = {}) {
      var ref2;
      let value = (ref2 = options.values) === null || ref2 === void 0 ? void 0 : ref2[modifier];
      if (value !== void 0) {
        return value;
      }
      if (options.supportsNegativeValues && modifier.startsWith("-")) {
        return asNegativeValue(modifier.slice(1), options.values, validate);
      }
      return resolveArbitraryValue(modifier, validate);
    }
    function isArbitraryValue(input) {
      return input.startsWith("[") && input.endsWith("]");
    }
    function splitUtilityModifier(modifier) {
      let slashIdx = modifier.lastIndexOf("/");
      if (slashIdx === -1 || slashIdx === modifier.length - 1) {
        return [
          modifier,
          void 0
        ];
      }
      let arbitrary = isArbitraryValue(modifier);
      if (arbitrary && !modifier.includes("]/[")) {
        return [
          modifier,
          void 0
        ];
      }
      return [
        modifier.slice(0, slashIdx),
        modifier.slice(slashIdx + 1)
      ];
    }
    function parseColorFormat(value) {
      if (typeof value === "string" && value.includes("<alpha-value>")) {
        let oldValue = value;
        return ({ opacityValue = 1 }) => oldValue.replace("<alpha-value>", opacityValue);
      }
      return value;
    }
    function asColor(_, options = {}, { tailwindConfig = {}, utilityModifier, rawModifier } = {}) {
      var ref2;
      if (((ref2 = options.values) === null || ref2 === void 0 ? void 0 : ref2[rawModifier]) !== void 0) {
        var ref1;
        return parseColorFormat((ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[rawModifier]);
      }
      let [color, alpha] = splitUtilityModifier(rawModifier);
      if (alpha !== void 0) {
        var ref22, ref3, ref4;
        var ref5;
        let normalizedColor = (ref5 = (ref22 = options.values) === null || ref22 === void 0 ? void 0 : ref22[color]) !== null && ref5 !== void 0 ? ref5 : isArbitraryValue(color) ? color.slice(1, -1) : void 0;
        if (normalizedColor === void 0) {
          return void 0;
        }
        normalizedColor = parseColorFormat(normalizedColor);
        if (isArbitraryValue(alpha)) {
          return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, alpha.slice(1, -1));
        }
        if (((ref3 = tailwindConfig.theme) === null || ref3 === void 0 ? void 0 : (ref4 = ref3.opacity) === null || ref4 === void 0 ? void 0 : ref4[alpha]) === void 0) {
          return void 0;
        }
        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);
      }
      return asValue(rawModifier, options, {
        rawModifier,
        utilityModifier,
        validate: _dataTypes.color
      });
    }
    function asLookupValue(modifier, options = {}) {
      var ref2;
      return (ref2 = options.values) === null || ref2 === void 0 ? void 0 : ref2[modifier];
    }
    function guess(validate) {
      return (modifier, options, extras) => {
        return asValue(modifier, options, {
          ...extras,
          validate
        });
      };
    }
    var typeMap = {
      any: asValue,
      color: asColor,
      url: guess(_dataTypes.url),
      image: guess(_dataTypes.image),
      length: guess(_dataTypes.length),
      percentage: guess(_dataTypes.percentage),
      position: guess(_dataTypes.position),
      lookup: asLookupValue,
      "generic-name": guess(_dataTypes.genericName),
      "family-name": guess(_dataTypes.familyName),
      number: guess(_dataTypes.number),
      "line-width": guess(_dataTypes.lineWidth),
      "absolute-size": guess(_dataTypes.absoluteSize),
      "relative-size": guess(_dataTypes.relativeSize),
      shadow: guess(_dataTypes.shadow),
      size: guess(_validateFormalSyntax.backgroundSize)
    };
    var supportedTypes = Object.keys(typeMap);
    function splitAtFirst(input, delim) {
      let idx = input.indexOf(delim);
      if (idx === -1)
        return [
          void 0,
          input
        ];
      return [
        input.slice(0, idx),
        input.slice(idx + 1)
      ];
    }
    function coerceValue(types2, modifier, options, tailwindConfig) {
      if (isArbitraryValue(modifier)) {
        let arbitraryValue = modifier.slice(1, -1);
        let [explicitType, value] = splitAtFirst(arbitraryValue, ":");
        if (!/^[\w-_]+$/g.test(explicitType)) {
          value = arbitraryValue;
        } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
          return [];
        }
        if (value.length > 0 && supportedTypes.includes(explicitType)) {
          return [
            asValue(`[${value}]`, options),
            explicitType,
            null
          ];
        }
      }
      let matches = getMatchingTypes(types2, modifier, options, tailwindConfig);
      for (let match of matches) {
        return match;
      }
      return [];
    }
    function* getMatchingTypes(types2, rawModifier, options, tailwindConfig) {
      let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
      let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
      let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
      if (!canUseUtilityModifier) {
        modifier = rawModifier;
        utilityModifier = void 0;
      }
      if (utilityModifier !== void 0 && modifier === "") {
        modifier = "DEFAULT";
      }
      if (utilityModifier !== void 0) {
        if (typeof options.modifiers === "object") {
          var ref2;
          var ref1;
          let configValue = (ref1 = (ref2 = options.modifiers) === null || ref2 === void 0 ? void 0 : ref2[utilityModifier]) !== null && ref1 !== void 0 ? ref1 : null;
          if (configValue !== null) {
            utilityModifier = configValue;
          } else if (isArbitraryValue(utilityModifier)) {
            utilityModifier = utilityModifier.slice(1, -1);
          }
        }
        let result = asValue(rawModifier, options, {
          rawModifier,
          utilityModifier,
          tailwindConfig
        });
        if (result !== void 0) {
          yield [
            result,
            "any",
            null
          ];
        }
      }
      for (const { type } of types2 !== null && types2 !== void 0 ? types2 : []) {
        let result1 = typeMap[type](modifier, options, {
          rawModifier,
          utilityModifier,
          tailwindConfig
        });
        if (result1 === void 0) {
          continue;
        }
        yield [
          result1,
          type,
          utilityModifier !== null && utilityModifier !== void 0 ? utilityModifier : null
        ];
      }
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/toColorValue.js
var require_toColorValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/toColorValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => toColorValue
    });
    function toColorValue(maybeFunction) {
      return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/resolveConfig.js
var require_resolveConfig = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/resolveConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => resolveConfig
    });
    var _negateValue = /* @__PURE__ */ _interopRequireDefault(require_negateValue());
    var _corePluginList = /* @__PURE__ */ _interopRequireDefault(require_corePluginList());
    var _configurePlugins = /* @__PURE__ */ _interopRequireDefault(require_configurePlugins());
    var _defaultConfigStub = /* @__PURE__ */ _interopRequireDefault(require_defaultConfig_stub());
    var _colors = /* @__PURE__ */ _interopRequireDefault(require_colors());
    var _defaults = require_defaults();
    var _toPath = require_toPath();
    var _normalizeConfig = require_normalizeConfig();
    var _isPlainObject = /* @__PURE__ */ _interopRequireDefault(require_isPlainObject());
    var _cloneDeep = require_cloneDeep();
    var _pluginUtils = require_pluginUtils();
    var _withAlphaVariable = require_withAlphaVariable();
    var _toColorValue = /* @__PURE__ */ _interopRequireDefault(require_toColorValue());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function isFunction(input) {
      return typeof input === "function";
    }
    function mergeWith(target, ...sources) {
      let customizer = sources.pop();
      for (let source of sources) {
        for (let k in source) {
          let merged = customizer(target[k], source[k]);
          if (merged === void 0) {
            if ((0, _isPlainObject.default)(target[k]) && (0, _isPlainObject.default)(source[k])) {
              target[k] = mergeWith({}, target[k], source[k], customizer);
            } else {
              target[k] = source[k];
            }
          } else {
            target[k] = merged;
          }
        }
      }
      return target;
    }
    var configUtils = {
      colors: _colors.default,
      negative(scale) {
        return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
          let negativeValue = (0, _negateValue.default)(scale[key]);
          if (negativeValue !== void 0) {
            negativeScale[`-${key}`] = negativeValue;
          }
          return negativeScale;
        }, {});
      },
      breakpoints(screens) {
        return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce((breakpoints, key) => ({
          ...breakpoints,
          [`screen-${key}`]: screens[key]
        }), {});
      }
    };
    function value(valueToResolve, ...args) {
      return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;
    }
    function collectExtends(items) {
      return items.reduce((merged, { extend: extend2 }) => {
        return mergeWith(merged, extend2, (mergedValue, extendValue) => {
          if (mergedValue === void 0) {
            return [
              extendValue
            ];
          }
          if (Array.isArray(mergedValue)) {
            return [
              extendValue,
              ...mergedValue
            ];
          }
          return [
            extendValue,
            mergedValue
          ];
        });
      }, {});
    }
    function mergeThemes(themes) {
      return {
        ...themes.reduce((merged, theme) => (0, _defaults.defaults)(merged, theme), {}),
        extend: collectExtends(themes)
      };
    }
    function mergeExtensionCustomizer(merged, value2) {
      if (Array.isArray(merged) && (0, _isPlainObject.default)(merged[0])) {
        return merged.concat(value2);
      }
      if (Array.isArray(value2) && (0, _isPlainObject.default)(value2[0]) && (0, _isPlainObject.default)(merged)) {
        return [
          merged,
          ...value2
        ];
      }
      if (Array.isArray(value2)) {
        return value2;
      }
      return void 0;
    }
    function mergeExtensions({ extend: extend2, ...theme }) {
      return mergeWith(theme, extend2, (themeValue, extensions) => {
        if (!isFunction(themeValue) && !extensions.some(isFunction)) {
          return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
        }
        return (resolveThemePath, utils) => mergeWith({}, ...[
          themeValue,
          ...extensions
        ].map((e) => value(e, resolveThemePath, utils)), mergeExtensionCustomizer);
      });
    }
    function* toPaths(key) {
      let path3 = (0, _toPath.toPath)(key);
      if (path3.length === 0) {
        return;
      }
      yield path3;
      if (Array.isArray(key)) {
        return;
      }
      let pattern = /^(.*?)\s*\/\s*([^/]+)$/;
      let matches = key.match(pattern);
      if (matches !== null) {
        let [, prefix, alpha] = matches;
        let newPath = (0, _toPath.toPath)(prefix);
        newPath.alpha = alpha;
        yield newPath;
      }
    }
    function resolveFunctionKeys(object) {
      const resolvePath = (key, defaultValue) => {
        for (const path3 of toPaths(key)) {
          let index = 0;
          let val = object;
          while (val !== void 0 && val !== null && index < path3.length) {
            val = val[path3[index++]];
            let shouldResolveAsFn = isFunction(val) && (path3.alpha === void 0 || index <= path3.length - 1);
            val = shouldResolveAsFn ? val(resolvePath, configUtils) : val;
          }
          if (val !== void 0) {
            if (path3.alpha !== void 0) {
              let normalized = (0, _pluginUtils.parseColorFormat)(val);
              return (0, _withAlphaVariable.withAlphaValue)(normalized, path3.alpha, (0, _toColorValue.default)(normalized));
            }
            if ((0, _isPlainObject.default)(val)) {
              return (0, _cloneDeep.cloneDeep)(val);
            }
            return val;
          }
        }
        return defaultValue;
      };
      Object.assign(resolvePath, {
        theme: resolvePath,
        ...configUtils
      });
      return Object.keys(object).reduce((resolved, key) => {
        resolved[key] = isFunction(object[key]) ? object[key](resolvePath, configUtils) : object[key];
        return resolved;
      }, {});
    }
    function extractPluginConfigs(configs) {
      let allConfigs = [];
      configs.forEach((config) => {
        allConfigs = [
          ...allConfigs,
          config
        ];
        var ref2;
        const plugins = (ref2 = config === null || config === void 0 ? void 0 : config.plugins) !== null && ref2 !== void 0 ? ref2 : [];
        if (plugins.length === 0) {
          return;
        }
        plugins.forEach((plugin) => {
          if (plugin.__isOptionsFunction) {
            plugin = plugin();
          }
          var ref3;
          allConfigs = [
            ...allConfigs,
            ...extractPluginConfigs([
              (ref3 = plugin === null || plugin === void 0 ? void 0 : plugin.config) !== null && ref3 !== void 0 ? ref3 : {}
            ])
          ];
        });
      });
      return allConfigs;
    }
    function resolveCorePlugins(corePluginConfigs) {
      const result = [
        ...corePluginConfigs
      ].reduceRight((resolved, corePluginConfig) => {
        if (isFunction(corePluginConfig)) {
          return corePluginConfig({
            corePlugins: resolved
          });
        }
        return (0, _configurePlugins.default)(corePluginConfig, resolved);
      }, _corePluginList.default);
      return result;
    }
    function resolvePluginLists(pluginLists) {
      const result = [
        ...pluginLists
      ].reduceRight((resolved, pluginList) => {
        return [
          ...resolved,
          ...pluginList
        ];
      }, []);
      return result;
    }
    function resolveConfig(configs) {
      let allConfigs = [
        ...extractPluginConfigs(configs),
        {
          prefix: "",
          important: false,
          separator: ":",
          variantOrder: _defaultConfigStub.default.variantOrder
        }
      ];
      var ref2, ref1;
      return (0, _normalizeConfig.normalizeConfig)((0, _defaults.defaults)({
        theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map((t) => {
          return (ref2 = t === null || t === void 0 ? void 0 : t.theme) !== null && ref2 !== void 0 ? ref2 : {};
        })))),
        corePlugins: resolveCorePlugins(allConfigs.map((c) => c.corePlugins)),
        plugins: resolvePluginLists(configs.map((c) => {
          return (ref1 = c === null || c === void 0 ? void 0 : c.plugins) !== null && ref1 !== void 0 ? ref1 : [];
        }))
      }, ...allConfigs));
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/getAllConfigs.js
var require_getAllConfigs = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/getAllConfigs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => getAllConfigs
    });
    var _defaultConfigStubJs = /* @__PURE__ */ _interopRequireDefault(require_defaultConfig_stub());
    var _featureFlags = require_featureFlags();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function getAllConfigs(config) {
      var ref2;
      const configs = ((ref2 = config === null || config === void 0 ? void 0 : config.presets) !== null && ref2 !== void 0 ? ref2 : [
        _defaultConfigStubJs.default
      ]).slice().reverse().flatMap((preset) => getAllConfigs(preset instanceof Function ? preset() : preset));
      const features = {
        respectDefaultRingColorOpacity: {
          theme: {
            ringColor: ({ theme }) => ({
              DEFAULT: "#3b82f67f",
              ...theme("colors")
            })
          }
        },
        disableColorOpacityUtilitiesByDefault: {
          corePlugins: {
            backgroundOpacity: false,
            borderOpacity: false,
            divideOpacity: false,
            placeholderOpacity: false,
            ringOpacity: false,
            textOpacity: false
          }
        }
      };
      const experimentals = Object.keys(features).filter((feature) => (0, _featureFlags.flagEnabled)(config, feature)).map((feature) => features[feature]);
      return [
        config,
        ...experimentals,
        ...configs
      ];
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/public/resolve-config.js
var require_resolve_config = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/public/resolve-config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => resolveConfig
    });
    var _resolveConfig = /* @__PURE__ */ _interopRequireDefault(require_resolveConfig());
    var _getAllConfigs = /* @__PURE__ */ _interopRequireDefault(require_getAllConfigs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function resolveConfig(...configs) {
      let [, ...defaultConfigs] = (0, _getAllConfigs.default)(configs[0]);
      return (0, _resolveConfig.default)([
        ...configs,
        ...defaultConfigs
      ]);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/resolveConfigPath.js
var require_resolveConfigPath = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/resolveConfigPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => resolveConfigPath
    });
    var _fs = /* @__PURE__ */ _interopRequireDefault(require("fs"));
    var _path = /* @__PURE__ */ _interopRequireDefault(require("path"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isEmpty(obj) {
      return Object.keys(obj).length === 0;
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function resolveConfigPath(pathOrConfig) {
      if (isObject(pathOrConfig) && pathOrConfig.config === void 0 && !isEmpty(pathOrConfig)) {
        return null;
      }
      if (isObject(pathOrConfig) && pathOrConfig.config !== void 0 && isString(pathOrConfig.config)) {
        return _path.default.resolve(pathOrConfig.config);
      }
      if (isObject(pathOrConfig) && pathOrConfig.config !== void 0 && isObject(pathOrConfig.config)) {
        return null;
      }
      if (isString(pathOrConfig)) {
        return _path.default.resolve(pathOrConfig);
      }
      for (const configFile of [
        "./tailwind.config.js",
        "./tailwind.config.cjs"
      ]) {
        try {
          const configPath = _path.default.resolve(configFile);
          _fs.default.accessSync(configPath);
          return configPath;
        } catch (err) {
        }
      }
      return null;
    }
  }
});

// node_modules/.pnpm/dlv@1.1.3/node_modules/dlv/dist/dlv.es.js
var dlv_es_exports = {};
__export(dlv_es_exports, {
  default: () => dlv_es_default
});
function dlv_es_default(t, e, l, n, r) {
  for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++)
    t = t ? t[e[n]] : r;
  return t === r ? l : t;
}
var init_dlv_es = __esm({
  "node_modules/.pnpm/dlv@1.1.3/node_modules/dlv/dist/dlv.es.js"() {
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/transformThemeValue.js
var require_transformThemeValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/transformThemeValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => transformThemeValue
    });
    var _postcss = /* @__PURE__ */ _interopRequireDefault(require("postcss"));
    var _isPlainObject = /* @__PURE__ */ _interopRequireDefault(require_isPlainObject());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function transformThemeValue(themeSection) {
      if ([
        "fontSize",
        "outline"
      ].includes(themeSection)) {
        return (value) => {
          if (typeof value === "function")
            value = value({});
          if (Array.isArray(value))
            value = value[0];
          return value;
        };
      }
      if (themeSection === "fontFamily") {
        return (value) => {
          if (typeof value === "function")
            value = value({});
          let families = Array.isArray(value) && (0, _isPlainObject.default)(value[1]) ? value[0] : value;
          return Array.isArray(families) ? families.join(", ") : families;
        };
      }
      if ([
        "boxShadow",
        "transitionProperty",
        "transitionDuration",
        "transitionDelay",
        "transitionTimingFunction",
        "backgroundImage",
        "backgroundSize",
        "backgroundColor",
        "cursor",
        "animation"
      ].includes(themeSection)) {
        return (value) => {
          if (typeof value === "function")
            value = value({});
          if (Array.isArray(value))
            value = value.join(", ");
          return value;
        };
      }
      if ([
        "gridTemplateColumns",
        "gridTemplateRows",
        "objectPosition"
      ].includes(themeSection)) {
        return (value) => {
          if (typeof value === "function")
            value = value({});
          if (typeof value === "string")
            value = _postcss.default.list.comma(value).join(" ");
          return value;
        };
      }
      return (value, opts = {}) => {
        if (typeof value === "function") {
          value = value(opts);
        }
        return value;
      };
    }
  }
});

// node_modules/.pnpm/postcss-nested@6.0.0_postcss@8.4.21/node_modules/postcss-nested/index.js
var require_postcss_nested = __commonJS({
  "node_modules/.pnpm/postcss-nested@6.0.0_postcss@8.4.21/node_modules/postcss-nested/index.js"(exports, module2) {
    var { Rule, AtRule } = require("postcss");
    var parser = require_dist();
    function parse4(rawSelector, rule) {
      let nodes;
      try {
        parser((parsed) => {
          nodes = parsed;
        }).processSync(rawSelector);
      } catch (e) {
        if (rawSelector.includes(":")) {
          throw rule ? rule.error("Missed semicolon") : e;
        } else {
          throw rule ? rule.error(e.message) : e;
        }
      }
      return nodes.at(0);
    }
    function interpolateAmpInSelector(nodes, parent) {
      let replaced = false;
      nodes.each((node) => {
        if (node.type === "nesting") {
          let clonedParent = parent.clone({});
          if (node.value !== "&") {
            node.replaceWith(
              parse4(node.value.replace("&", clonedParent.toString()))
            );
          } else {
            node.replaceWith(clonedParent);
          }
          replaced = true;
        } else if ("nodes" in node && node.nodes) {
          if (interpolateAmpInSelector(node, parent)) {
            replaced = true;
          }
        }
      });
      return replaced;
    }
    function mergeSelectors(parent, child) {
      let merged = [];
      parent.selectors.forEach((sel) => {
        let parentNode = parse4(sel, parent);
        child.selectors.forEach((selector) => {
          if (!selector) {
            return;
          }
          let node = parse4(selector, child);
          let replaced = interpolateAmpInSelector(node, parentNode);
          if (!replaced) {
            node.prepend(parser.combinator({ value: " " }));
            node.prepend(parentNode.clone({}));
          }
          merged.push(node.toString());
        });
      });
      return merged;
    }
    function breakOut(child, after) {
      let prev = child.prev();
      after.after(child);
      while (prev && prev.type === "comment") {
        let nextPrev = prev.prev();
        after.after(prev);
        prev = nextPrev;
      }
      return child;
    }
    function createFnAtruleChilds(bubble) {
      return function atruleChilds(rule, atrule, bubbling, mergeSels = bubbling) {
        let children = [];
        atrule.each((child) => {
          if (child.type === "rule" && bubbling) {
            if (mergeSels) {
              child.selectors = mergeSelectors(rule, child);
            }
          } else if (child.type === "atrule" && child.nodes) {
            if (bubble[child.name]) {
              atruleChilds(rule, child, mergeSels);
            } else if (atrule[rootRuleMergeSel] !== false) {
              children.push(child);
            }
          } else {
            children.push(child);
          }
        });
        if (bubbling) {
          if (children.length) {
            let clone = rule.clone({ nodes: [] });
            for (let child of children) {
              clone.append(child);
            }
            atrule.prepend(clone);
          }
        }
      };
    }
    function pickDeclarations(selector, declarations, after) {
      let parent = new Rule({
        selector,
        nodes: []
      });
      parent.append(declarations);
      after.after(parent);
      return parent;
    }
    function atruleNames(defaults, custom) {
      let list = {};
      for (let name of defaults) {
        list[name] = true;
      }
      if (custom) {
        for (let name of custom) {
          list[name.replace(/^@/, "")] = true;
        }
      }
      return list;
    }
    function parseRootRuleParams(params) {
      params = params.trim();
      let braceBlock = params.match(/^\((.*)\)$/);
      if (!braceBlock) {
        return { type: "basic", selector: params };
      }
      let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/);
      if (bits) {
        let allowlist = bits[1] === "with";
        let rules = Object.fromEntries(
          bits[2].trim().split(/\s+/).map((name) => [name, true])
        );
        if (allowlist && rules.all) {
          return { type: "noop" };
        }
        let escapes = (rule) => !!rules[rule];
        if (rules.all) {
          escapes = () => true;
        } else if (allowlist) {
          escapes = (rule) => rule === "all" ? false : !rules[rule];
        }
        return {
          type: "withrules",
          escapes
        };
      }
      return { type: "unknown" };
    }
    function getAncestorRules(leaf) {
      let lineage = [];
      let parent = leaf.parent;
      while (parent && parent instanceof AtRule) {
        lineage.push(parent);
        parent = parent.parent;
      }
      return lineage;
    }
    function unwrapRootRule(rule) {
      let escapes = rule[rootRuleEscapes];
      if (!escapes) {
        rule.after(rule.nodes);
      } else {
        let nodes = rule.nodes;
        let topEscaped;
        let topEscapedIdx = -1;
        let breakoutLeaf;
        let breakoutRoot;
        let clone;
        let lineage = getAncestorRules(rule);
        lineage.forEach((parent, i) => {
          if (escapes(parent.name)) {
            topEscaped = parent;
            topEscapedIdx = i;
            breakoutRoot = clone;
          } else {
            let oldClone = clone;
            clone = parent.clone({ nodes: [] });
            oldClone && clone.append(oldClone);
            breakoutLeaf = breakoutLeaf || clone;
          }
        });
        if (!topEscaped) {
          rule.after(nodes);
        } else if (!breakoutRoot) {
          topEscaped.after(nodes);
        } else {
          let leaf = breakoutLeaf;
          leaf.append(nodes);
          topEscaped.after(breakoutRoot);
        }
        if (rule.next() && topEscaped) {
          let restRoot;
          lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {
            let oldRoot = restRoot;
            restRoot = parent.clone({ nodes: [] });
            oldRoot && restRoot.append(oldRoot);
            let nextSibs = [];
            let _child = arr[i - 1] || rule;
            let next = _child.next();
            while (next) {
              nextSibs.push(next);
              next = next.next();
            }
            restRoot.append(nextSibs);
          });
          restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot);
        }
      }
      rule.remove();
    }
    var rootRuleMergeSel = Symbol("rootRuleMergeSel");
    var rootRuleEscapes = Symbol("rootRuleEscapes");
    function normalizeRootRule(rule) {
      let { params } = rule;
      let { type, selector, escapes } = parseRootRuleParams(params);
      if (type === "unknown") {
        throw rule.error(
          `Unknown @${rule.name} parameter ${JSON.stringify(params)}`
        );
      }
      if (type === "basic" && selector) {
        let selectorBlock = new Rule({ selector, nodes: rule.nodes });
        rule.removeAll();
        rule.append(selectorBlock);
      }
      rule[rootRuleEscapes] = escapes;
      rule[rootRuleMergeSel] = escapes ? !escapes("all") : type === "noop";
    }
    var hasRootRule = Symbol("hasRootRule");
    module2.exports = (opts = {}) => {
      let bubble = atruleNames(["media", "supports", "layer"], opts.bubble);
      let atruleChilds = createFnAtruleChilds(bubble);
      let unwrap = atruleNames(
        [
          "document",
          "font-face",
          "keyframes",
          "-webkit-keyframes",
          "-moz-keyframes"
        ],
        opts.unwrap
      );
      let rootRuleName = (opts.rootRuleName || "at-root").replace(/^@/, "");
      let preserveEmpty = opts.preserveEmpty;
      return {
        postcssPlugin: "postcss-nested",
        Once(root) {
          root.walkAtRules(rootRuleName, (node) => {
            normalizeRootRule(node);
            root[hasRootRule] = true;
          });
        },
        Rule(rule) {
          let unwrapped = false;
          let after = rule;
          let copyDeclarations = false;
          let declarations = [];
          rule.each((child) => {
            if (child.type === "rule") {
              if (declarations.length) {
                after = pickDeclarations(rule.selector, declarations, after);
                declarations = [];
              }
              copyDeclarations = true;
              unwrapped = true;
              child.selectors = mergeSelectors(rule, child);
              after = breakOut(child, after);
            } else if (child.type === "atrule") {
              if (declarations.length) {
                after = pickDeclarations(rule.selector, declarations, after);
                declarations = [];
              }
              if (child.name === rootRuleName) {
                unwrapped = true;
                atruleChilds(rule, child, true, child[rootRuleMergeSel]);
                after = breakOut(child, after);
              } else if (bubble[child.name]) {
                copyDeclarations = true;
                unwrapped = true;
                atruleChilds(rule, child, true);
                after = breakOut(child, after);
              } else if (unwrap[child.name]) {
                copyDeclarations = true;
                unwrapped = true;
                atruleChilds(rule, child, false);
                after = breakOut(child, after);
              } else if (copyDeclarations) {
                declarations.push(child);
              }
            } else if (child.type === "decl" && copyDeclarations) {
              declarations.push(child);
            }
          });
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after);
          }
          if (unwrapped && preserveEmpty !== true) {
            rule.raws.semicolon = true;
            if (rule.nodes.length === 0)
              rule.remove();
          }
        },
        RootExit(root) {
          if (root[hasRootRule]) {
            root.walkAtRules(rootRuleName, unwrapRootRule);
            root[hasRootRule] = false;
          }
        }
      };
    };
    module2.exports.postcss = true;
  }
});

// node_modules/.pnpm/camelcase-css@2.0.1/node_modules/camelcase-css/index.js
var require_camelcase_css = __commonJS({
  "node_modules/.pnpm/camelcase-css@2.0.1/node_modules/camelcase-css/index.js"(exports, module2) {
    "use strict";
    var pattern = /-(\w|$)/g;
    var callback = (dashChar, char) => char.toUpperCase();
    var camelCaseCSS = (property) => {
      property = property.toLowerCase();
      if (property === "float") {
        return "cssFloat";
      } else if (property.startsWith("-ms-")) {
        return property.substr(1).replace(pattern, callback);
      } else {
        return property.replace(pattern, callback);
      }
    };
    module2.exports = camelCaseCSS;
  }
});

// node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/objectifier.js
var require_objectifier = __commonJS({
  "node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/objectifier.js"(exports, module2) {
    var camelcase = require_camelcase_css();
    var UNITLESS = {
      boxFlex: true,
      boxFlexGroup: true,
      columnCount: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      strokeDashoffset: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    function atRule(node) {
      if (typeof node.nodes === "undefined") {
        return true;
      } else {
        return process2(node);
      }
    }
    function process2(node) {
      let name;
      let result = {};
      node.each((child) => {
        if (child.type === "atrule") {
          name = "@" + child.name;
          if (child.params)
            name += " " + child.params;
          if (typeof result[name] === "undefined") {
            result[name] = atRule(child);
          } else if (Array.isArray(result[name])) {
            result[name].push(atRule(child));
          } else {
            result[name] = [result[name], atRule(child)];
          }
        } else if (child.type === "rule") {
          let body = process2(child);
          if (result[child.selector]) {
            for (let i in body) {
              result[child.selector][i] = body[i];
            }
          } else {
            result[child.selector] = body;
          }
        } else if (child.type === "decl") {
          if (child.prop[0] === "-" && child.prop[1] === "-") {
            name = child.prop;
          } else {
            name = camelcase(child.prop);
          }
          let value = child.value;
          if (!isNaN(child.value) && UNITLESS[name]) {
            value = parseFloat(child.value);
          }
          if (child.important)
            value += " !important";
          if (typeof result[name] === "undefined") {
            result[name] = value;
          } else if (Array.isArray(result[name])) {
            result[name].push(value);
          } else {
            result[name] = [result[name], value];
          }
        }
      });
      return result;
    }
    module2.exports = process2;
  }
});

// node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/parser.js
var require_parser2 = __commonJS({
  "node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/parser.js"(exports, module2) {
    var postcss2 = require("postcss");
    var IMPORTANT = /\s*!important\s*$/i;
    var UNITLESS = {
      "box-flex": true,
      "box-flex-group": true,
      "column-count": true,
      "flex": true,
      "flex-grow": true,
      "flex-positive": true,
      "flex-shrink": true,
      "flex-negative": true,
      "font-weight": true,
      "line-clamp": true,
      "line-height": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "tab-size": true,
      "widows": true,
      "z-index": true,
      "zoom": true,
      "fill-opacity": true,
      "stroke-dashoffset": true,
      "stroke-opacity": true,
      "stroke-width": true
    };
    function dashify(str) {
      return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
    }
    function decl(parent, name, value) {
      if (value === false || value === null)
        return;
      if (!name.startsWith("--")) {
        name = dashify(name);
      }
      if (typeof value === "number") {
        if (value === 0 || UNITLESS[name]) {
          value = value.toString();
        } else {
          value += "px";
        }
      }
      if (name === "css-float")
        name = "float";
      if (IMPORTANT.test(value)) {
        value = value.replace(IMPORTANT, "");
        parent.push(postcss2.decl({ prop: name, value, important: true }));
      } else {
        parent.push(postcss2.decl({ prop: name, value }));
      }
    }
    function atRule(parent, parts, value) {
      let node = postcss2.atRule({ name: parts[1], params: parts[3] || "" });
      if (typeof value === "object") {
        node.nodes = [];
        parse4(value, node);
      }
      parent.push(node);
    }
    function parse4(obj, parent) {
      let name, value, node;
      for (name in obj) {
        value = obj[name];
        if (value === null || typeof value === "undefined") {
          continue;
        } else if (name[0] === "@") {
          let parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(value)) {
            for (let i of value) {
              atRule(parent, parts, i);
            }
          } else {
            atRule(parent, parts, value);
          }
        } else if (Array.isArray(value)) {
          for (let i of value) {
            decl(parent, name, i);
          }
        } else if (typeof value === "object") {
          node = postcss2.rule({ selector: name });
          parse4(value, node);
          parent.push(node);
        } else {
          decl(parent, name, value);
        }
      }
    }
    module2.exports = function(obj) {
      let root = postcss2.root();
      parse4(obj, root);
      return root;
    };
  }
});

// node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/process-result.js
var require_process_result = __commonJS({
  "node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/process-result.js"(exports, module2) {
    var objectify = require_objectifier();
    module2.exports = function processResult(result) {
      if (console && console.warn) {
        result.warnings().forEach((warn) => {
          let source = warn.plugin || "PostCSS";
          console.warn(source + ": " + warn.text);
        });
      }
      return objectify(result.root);
    };
  }
});

// node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/async.js
var require_async2 = __commonJS({
  "node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/async.js"(exports, module2) {
    var postcss2 = require("postcss");
    var processResult = require_process_result();
    var parse4 = require_parser2();
    module2.exports = function async(plugins) {
      let processor = postcss2(plugins);
      return async (input) => {
        let result = await processor.process(input, {
          parser: parse4,
          from: void 0
        });
        return processResult(result);
      };
    };
  }
});

// node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/sync.js
var require_sync2 = __commonJS({
  "node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/sync.js"(exports, module2) {
    var postcss2 = require("postcss");
    var processResult = require_process_result();
    var parse4 = require_parser2();
    module2.exports = function(plugins) {
      let processor = postcss2(plugins);
      return (input) => {
        let result = processor.process(input, { parser: parse4, from: void 0 });
        return processResult(result);
      };
    };
  }
});

// node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/index.js
var require_postcss_js = __commonJS({
  "node_modules/.pnpm/postcss-js@4.0.0_postcss@8.4.21/node_modules/postcss-js/index.js"(exports, module2) {
    var objectify = require_objectifier();
    var parse4 = require_parser2();
    var async = require_async2();
    var sync = require_sync2();
    module2.exports = {
      objectify,
      parse: parse4,
      async,
      sync
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseObjectStyles.js
var require_parseObjectStyles = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseObjectStyles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => parseObjectStyles
    });
    var _postcss = /* @__PURE__ */ _interopRequireDefault(require("postcss"));
    var _postcssNested = /* @__PURE__ */ _interopRequireDefault(require_postcss_nested());
    var _postcssJs = /* @__PURE__ */ _interopRequireDefault(require_postcss_js());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function parseObjectStyles(styles) {
      if (!Array.isArray(styles)) {
        return parseObjectStyles([
          styles
        ]);
      }
      return styles.flatMap((style) => {
        return (0, _postcss.default)([
          (0, _postcssNested.default)({
            bubble: [
              "screen"
            ]
          })
        ]).process(style, {
          parser: _postcssJs.default
        }).root.nodes;
      });
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/prefixSelector.js
var require_prefixSelector = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/prefixSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _default(prefix, selector, prependNegative = false) {
      return (0, _postcssSelectorParser.default)((selectors) => {
        selectors.walkClasses((classSelector) => {
          let baseClass = classSelector.value;
          let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith("-");
          classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix}${baseClass.slice(1)}` : `${prefix}${baseClass}`;
        });
      }).processSync(selector);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/escapeClassName.js
var require_escapeClassName = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/escapeClassName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => escapeClassName
    });
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _escapeCommas = /* @__PURE__ */ _interopRequireDefault(require_escapeCommas());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function escapeClassName(className) {
      var ref2;
      let node = _postcssSelectorParser.default.className();
      node.value = className;
      var ref1;
      return (0, _escapeCommas.default)((ref1 = node === null || node === void 0 ? void 0 : (ref2 = node.raws) === null || ref2 === void 0 ? void 0 : ref2.value) !== null && ref1 !== void 0 ? ref1 : node.value);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/nameClass.js
var require_nameClass = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/nameClass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      asClass: () => asClass,
      default: () => nameClass,
      formatClass: () => formatClass
    });
    var _escapeClassName = /* @__PURE__ */ _interopRequireDefault(require_escapeClassName());
    var _escapeCommas = /* @__PURE__ */ _interopRequireDefault(require_escapeCommas());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function asClass(name) {
      return (0, _escapeCommas.default)(`.${(0, _escapeClassName.default)(name)}`);
    }
    function nameClass(classPrefix, key) {
      return asClass(formatClass(classPrefix, key));
    }
    function formatClass(classPrefix, key) {
      if (key === "DEFAULT") {
        return classPrefix;
      }
      if (key === "-" || key === "-DEFAULT") {
        return `-${classPrefix}`;
      }
      if (key.startsWith("-")) {
        return `-${classPrefix}${key}`;
      }
      if (key.startsWith("/")) {
        return `${classPrefix}${key}`;
      }
      return `${classPrefix}-${key}`;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/createUtilityPlugin.js
var require_createUtilityPlugin = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/createUtilityPlugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => createUtilityPlugin
    });
    var _transformThemeValue = /* @__PURE__ */ _interopRequireDefault(require_transformThemeValue());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createUtilityPlugin(themeKey, utilityVariations = [
      [
        themeKey,
        [
          themeKey
        ]
      ]
    ], { filterDefault = false, ...options } = {}) {
      let transformValue = (0, _transformThemeValue.default)(themeKey);
      return function({ matchUtilities, theme }) {
        for (let utilityVariation of utilityVariations) {
          let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [
            utilityVariation
          ];
          var ref2;
          matchUtilities(group.reduce((obj, [classPrefix, properties]) => {
            return Object.assign(obj, {
              [classPrefix]: (value) => {
                return properties.reduce((obj2, name) => {
                  if (Array.isArray(name)) {
                    return Object.assign(obj2, {
                      [name[0]]: name[1]
                    });
                  }
                  return Object.assign(obj2, {
                    [name]: transformValue(value)
                  });
                }, {});
              }
            });
          }, {}), {
            ...options,
            values: filterDefault ? Object.fromEntries(Object.entries((ref2 = theme(themeKey)) !== null && ref2 !== void 0 ? ref2 : {}).filter(([modifier]) => modifier !== "DEFAULT")) : theme(themeKey)
          });
        }
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/buildMediaQuery.js
var require_buildMediaQuery = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/buildMediaQuery.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => buildMediaQuery
    });
    function buildMediaQuery(screens) {
      screens = Array.isArray(screens) ? screens : [
        screens
      ];
      return screens.map((screen) => {
        let values = screen.values.map((screen2) => {
          if (screen2.raw !== void 0) {
            return screen2.raw;
          }
          return [
            screen2.min && `(min-width: ${screen2.min})`,
            screen2.max && `(max-width: ${screen2.max})`
          ].filter(Boolean).join(" and ");
        });
        return screen.not ? `not all and ${values}` : values;
      }).join(", ");
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseAnimationValue.js
var require_parseAnimationValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseAnimationValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => parseAnimationValue
    });
    var DIRECTIONS = /* @__PURE__ */ new Set([
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ]);
    var PLAY_STATES = /* @__PURE__ */ new Set([
      "running",
      "paused"
    ]);
    var FILL_MODES = /* @__PURE__ */ new Set([
      "none",
      "forwards",
      "backwards",
      "both"
    ]);
    var ITERATION_COUNTS = /* @__PURE__ */ new Set([
      "infinite"
    ]);
    var TIMINGS = /* @__PURE__ */ new Set([
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "step-start",
      "step-end"
    ]);
    var TIMING_FNS = [
      "cubic-bezier",
      "steps"
    ];
    var COMMA = /\,(?![^(]*\))/g;
    var SPACE = /\ +(?![^(]*\))/g;
    var TIME = /^(-?[\d.]+m?s)$/;
    var DIGIT = /^(\d+)$/;
    function parseAnimationValue(input) {
      let animations = input.split(COMMA);
      return animations.map((animation) => {
        let value = animation.trim();
        let result = {
          value
        };
        let parts = value.split(SPACE);
        let seen = /* @__PURE__ */ new Set();
        for (let part of parts) {
          if (!seen.has("DIRECTIONS") && DIRECTIONS.has(part)) {
            result.direction = part;
            seen.add("DIRECTIONS");
          } else if (!seen.has("PLAY_STATES") && PLAY_STATES.has(part)) {
            result.playState = part;
            seen.add("PLAY_STATES");
          } else if (!seen.has("FILL_MODES") && FILL_MODES.has(part)) {
            result.fillMode = part;
            seen.add("FILL_MODES");
          } else if (!seen.has("ITERATION_COUNTS") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {
            result.iterationCount = part;
            seen.add("ITERATION_COUNTS");
          } else if (!seen.has("TIMING_FUNCTION") && TIMINGS.has(part)) {
            result.timingFunction = part;
            seen.add("TIMING_FUNCTION");
          } else if (!seen.has("TIMING_FUNCTION") && TIMING_FNS.some((f) => part.startsWith(`${f}(`))) {
            result.timingFunction = part;
            seen.add("TIMING_FUNCTION");
          } else if (!seen.has("DURATION") && TIME.test(part)) {
            result.duration = part;
            seen.add("DURATION");
          } else if (!seen.has("DELAY") && TIME.test(part)) {
            result.delay = part;
            seen.add("DELAY");
          } else if (!seen.has("NAME")) {
            result.name = part;
            seen.add("NAME");
          } else {
            if (!result.unknown)
              result.unknown = [];
            result.unknown.push(part);
          }
        }
        return result;
      });
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/flattenColorPalette.js
var require_flattenColorPalette = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/flattenColorPalette.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var flattenColorPalette = (colors) => Object.assign({}, ...Object.entries(colors !== null && colors !== void 0 ? colors : {}).flatMap(([color, values]) => typeof values == "object" ? Object.entries(flattenColorPalette(values)).map(([number, hex]) => ({
      [color + (number === "DEFAULT" ? "" : `-${number}`)]: hex
    })) : [
      {
        [`${color}`]: values
      }
    ]));
    var _default = flattenColorPalette;
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/package.json"(exports, module2) {
    module2.exports = {
      name: "tailwindcss",
      version: "3.2.4",
      description: "A utility-first CSS framework for rapidly building custom user interfaces.",
      license: "MIT",
      main: "lib/index.js",
      types: "types/index.d.ts",
      repository: "https://github.com/tailwindlabs/tailwindcss.git",
      bugs: "https://github.com/tailwindlabs/tailwindcss/issues",
      homepage: "https://tailwindcss.com",
      bin: {
        tailwind: "lib/cli.js",
        tailwindcss: "lib/cli.js"
      },
      scripts: {
        preswcify: "npm run generate && rimraf lib",
        swcify: "swc src --out-dir lib --copy-files",
        postswcify: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js",
        "rebuild-fixtures": "npm run swcify && node -r @swc/register scripts/rebuildFixtures.js",
        prepublishOnly: "npm install --force && npm run swcify",
        style: "eslint .",
        pretest: "npm run generate",
        test: "jest",
        "test:integrations": "npm run test --prefix ./integrations",
        "install:integrations": "node scripts/install-integrations.js",
        "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
        "generate:types": "node -r @swc/register scripts/generate-types.js",
        generate: "npm run generate:plugin-list && npm run generate:types",
        "release-channel": "node ./scripts/release-channel.js",
        "release-notes": "node ./scripts/release-notes.js"
      },
      files: [
        "src/*",
        "cli/*",
        "lib/*",
        "peers/*",
        "scripts/*.js",
        "stubs/*.stub.js",
        "nesting/*",
        "types/**/*",
        "*.d.ts",
        "*.css",
        "*.js"
      ],
      devDependencies: {
        "@swc/cli": "^0.1.57",
        "@swc/core": "^1.3.11",
        "@swc/jest": "^0.2.23",
        "@swc/register": "^0.1.10",
        autoprefixer: "^10.4.13",
        cssnano: "^5.1.14",
        esbuild: "^0.15.12",
        eslint: "^8.26.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        jest: "^28.1.3",
        "jest-diff": "^28.1.3",
        prettier: "^2.7.1",
        rimraf: "^3.0.0",
        "source-map-js": "^1.0.2"
      },
      peerDependencies: {
        postcss: "^8.0.9"
      },
      dependencies: {
        arg: "^5.0.2",
        chokidar: "^3.5.3",
        "color-name": "^1.1.4",
        detective: "^5.2.1",
        didyoumean: "^1.2.2",
        dlv: "^1.1.3",
        "fast-glob": "^3.2.12",
        "glob-parent": "^6.0.2",
        "is-glob": "^4.0.3",
        lilconfig: "^2.0.6",
        micromatch: "^4.0.5",
        "normalize-path": "^3.0.0",
        "object-hash": "^3.0.0",
        picocolors: "^1.0.0",
        postcss: "^8.4.18",
        "postcss-import": "^14.1.0",
        "postcss-js": "^4.0.0",
        "postcss-load-config": "^3.1.4",
        "postcss-nested": "6.0.0",
        "postcss-selector-parser": "^6.0.10",
        "postcss-value-parser": "^4.2.0",
        "quick-lru": "^5.1.1",
        resolve: "^1.22.1"
      },
      browserslist: [
        "> 1%",
        "not edge <= 18",
        "not ie 11",
        "not op_mini all"
      ],
      jest: {
        testTimeout: 3e4,
        setupFilesAfterEnv: [
          "<rootDir>/jest/customMatchers.js"
        ],
        testPathIgnorePatterns: [
          "/node_modules/",
          "/integrations/",
          "/standalone-cli/",
          "\\.test\\.skip\\.js$"
        ],
        transform: {
          "\\.js$": "@swc/jest"
        }
      },
      engines: {
        node: ">=12.13.0"
      }
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/normalizeScreens.js
var require_normalizeScreens = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/normalizeScreens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      normalizeScreens: () => normalizeScreens,
      isScreenSortable: () => isScreenSortable,
      compareScreens: () => compareScreens,
      toScreen: () => toScreen
    });
    function normalizeScreens(screens, root = true) {
      if (Array.isArray(screens)) {
        return screens.map((screen) => {
          if (root && Array.isArray(screen)) {
            throw new Error("The tuple syntax is not supported for `screens`.");
          }
          if (typeof screen === "string") {
            return {
              name: screen.toString(),
              not: false,
              values: [
                {
                  min: screen,
                  max: void 0
                }
              ]
            };
          }
          let [name, options] = screen;
          name = name.toString();
          if (typeof options === "string") {
            return {
              name,
              not: false,
              values: [
                {
                  min: options,
                  max: void 0
                }
              ]
            };
          }
          if (Array.isArray(options)) {
            return {
              name,
              not: false,
              values: options.map((option) => resolveValue(option))
            };
          }
          return {
            name,
            not: false,
            values: [
              resolveValue(options)
            ]
          };
        });
      }
      return normalizeScreens(Object.entries(screens !== null && screens !== void 0 ? screens : {}), false);
    }
    function isScreenSortable(screen) {
      if (screen.values.length !== 1) {
        return {
          result: false,
          reason: "multiple-values"
        };
      } else if (screen.values[0].raw !== void 0) {
        return {
          result: false,
          reason: "raw-values"
        };
      } else if (screen.values[0].min !== void 0 && screen.values[0].max !== void 0) {
        return {
          result: false,
          reason: "min-and-max"
        };
      }
      return {
        result: true,
        reason: null
      };
    }
    function compareScreens(type, a, z) {
      let aScreen = toScreen(a, type);
      let zScreen = toScreen(z, type);
      let aSorting = isScreenSortable(aScreen);
      let bSorting = isScreenSortable(zScreen);
      if (aSorting.reason === "multiple-values" || bSorting.reason === "multiple-values") {
        throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
      } else if (aSorting.reason === "raw-values" || bSorting.reason === "raw-values") {
        throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
      } else if (aSorting.reason === "min-and-max" || bSorting.reason === "min-and-max") {
        throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
      }
      let { min: aMin, max: aMax } = aScreen.values[0];
      let { min: zMin, max: zMax } = zScreen.values[0];
      if (a.not)
        [aMin, aMax] = [
          aMax,
          aMin
        ];
      if (z.not)
        [zMin, zMax] = [
          zMax,
          zMin
        ];
      aMin = aMin === void 0 ? aMin : parseFloat(aMin);
      aMax = aMax === void 0 ? aMax : parseFloat(aMax);
      zMin = zMin === void 0 ? zMin : parseFloat(zMin);
      zMax = zMax === void 0 ? zMax : parseFloat(zMax);
      let [aValue, zValue] = type === "min" ? [
        aMin,
        zMin
      ] : [
        zMax,
        aMax
      ];
      return aValue - zValue;
    }
    function toScreen(value, type) {
      if (typeof value === "object") {
        return value;
      }
      return {
        name: "arbitrary-screen",
        values: [
          {
            [type]: value
          }
        ]
      };
    }
    function resolveValue({ "min-width": _minWidth, min = _minWidth, max, raw } = {}) {
      return {
        min,
        max,
        raw
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/removeAlphaVariables.js
var require_removeAlphaVariables = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/removeAlphaVariables.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removeAlphaVariables", {
      enumerable: true,
      get: () => removeAlphaVariables
    });
    function removeAlphaVariables(container, toRemove) {
      container.walkDecls((decl) => {
        if (toRemove.includes(decl.prop)) {
          decl.remove();
          return;
        }
        for (let varName of toRemove) {
          if (decl.value.includes(`/ var(${varName})`)) {
            decl.value = decl.value.replace(`/ var(${varName})`, "");
          }
        }
      });
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/corePlugins.js
var require_corePlugins = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/corePlugins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      variantPlugins: () => variantPlugins,
      corePlugins: () => corePlugins
    });
    var _fs = /* @__PURE__ */ _interopRequireDefault(require("fs"));
    var _path = /* @__PURE__ */ _interopRequireWildcard(require("path"));
    var _postcss = /* @__PURE__ */ _interopRequireDefault(require("postcss"));
    var _createUtilityPlugin = /* @__PURE__ */ _interopRequireDefault(require_createUtilityPlugin());
    var _buildMediaQuery = /* @__PURE__ */ _interopRequireDefault(require_buildMediaQuery());
    var _escapeClassName = /* @__PURE__ */ _interopRequireDefault(require_escapeClassName());
    var _parseAnimationValue = /* @__PURE__ */ _interopRequireDefault(require_parseAnimationValue());
    var _flattenColorPalette = /* @__PURE__ */ _interopRequireDefault(require_flattenColorPalette());
    var _withAlphaVariable = /* @__PURE__ */ _interopRequireWildcard(require_withAlphaVariable());
    var _toColorValue = /* @__PURE__ */ _interopRequireDefault(require_toColorValue());
    var _isPlainObject = /* @__PURE__ */ _interopRequireDefault(require_isPlainObject());
    var _transformThemeValue = /* @__PURE__ */ _interopRequireDefault(require_transformThemeValue());
    var _packageJson = require_package();
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    var _normalizeScreens = require_normalizeScreens();
    var _parseBoxShadowValue = require_parseBoxShadowValue();
    var _removeAlphaVariables = require_removeAlphaVariables();
    var _featureFlags = require_featureFlags();
    var _dataTypes = require_dataTypes();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var variantPlugins = {
      pseudoElementVariants: ({ addVariant }) => {
        addVariant("first-letter", "&::first-letter");
        addVariant("first-line", "&::first-line");
        addVariant("marker", [
          ({ container }) => {
            (0, _removeAlphaVariables.removeAlphaVariables)(container, [
              "--tw-text-opacity"
            ]);
            return "& *::marker";
          },
          ({ container }) => {
            (0, _removeAlphaVariables.removeAlphaVariables)(container, [
              "--tw-text-opacity"
            ]);
            return "&::marker";
          }
        ]);
        addVariant("selection", [
          "& *::selection",
          "&::selection"
        ]);
        addVariant("file", "&::file-selector-button");
        addVariant("placeholder", "&::placeholder");
        addVariant("backdrop", "&::backdrop");
        addVariant("before", ({ container }) => {
          container.walkRules((rule) => {
            let foundContent = false;
            rule.walkDecls("content", () => {
              foundContent = true;
            });
            if (!foundContent) {
              rule.prepend(_postcss.default.decl({
                prop: "content",
                value: "var(--tw-content)"
              }));
            }
          });
          return "&::before";
        });
        addVariant("after", ({ container }) => {
          container.walkRules((rule) => {
            let foundContent = false;
            rule.walkDecls("content", () => {
              foundContent = true;
            });
            if (!foundContent) {
              rule.prepend(_postcss.default.decl({
                prop: "content",
                value: "var(--tw-content)"
              }));
            }
          });
          return "&::after";
        });
      },
      pseudoClassVariants: ({ addVariant, matchVariant, config }) => {
        let pseudoVariants = [
          [
            "first",
            "&:first-child"
          ],
          [
            "last",
            "&:last-child"
          ],
          [
            "only",
            "&:only-child"
          ],
          [
            "odd",
            "&:nth-child(odd)"
          ],
          [
            "even",
            "&:nth-child(even)"
          ],
          "first-of-type",
          "last-of-type",
          "only-of-type",
          [
            "visited",
            ({ container }) => {
              (0, _removeAlphaVariables.removeAlphaVariables)(container, [
                "--tw-text-opacity",
                "--tw-border-opacity",
                "--tw-bg-opacity"
              ]);
              return "&:visited";
            }
          ],
          "target",
          [
            "open",
            "&[open]"
          ],
          "default",
          "checked",
          "indeterminate",
          "placeholder-shown",
          "autofill",
          "optional",
          "required",
          "valid",
          "invalid",
          "in-range",
          "out-of-range",
          "read-only",
          "empty",
          "focus-within",
          [
            "hover",
            !(0, _featureFlags.flagEnabled)(config(), "hoverOnlyWhenSupported") ? "&:hover" : "@media (hover: hover) and (pointer: fine) { &:hover }"
          ],
          "focus",
          "focus-visible",
          "active",
          "enabled",
          "disabled"
        ].map((variant) => Array.isArray(variant) ? variant : [
          variant,
          `&:${variant}`
        ]);
        for (let [variantName, state] of pseudoVariants) {
          addVariant(variantName, (ctx) => {
            let result = typeof state === "function" ? state(ctx) : state;
            return result;
          });
        }
        let variants = {
          group: (_, { modifier }) => modifier ? [
            `:merge(.group\\/${modifier})`,
            " &"
          ] : [
            `:merge(.group)`,
            " &"
          ],
          peer: (_, { modifier }) => modifier ? [
            `:merge(.peer\\/${modifier})`,
            " ~ &"
          ] : [
            `:merge(.peer)`,
            " ~ &"
          ]
        };
        for (let [name, fn] of Object.entries(variants)) {
          matchVariant(name, (value = "", extra) => {
            let result = (0, _dataTypes.normalize)(typeof value === "function" ? value(extra) : value);
            if (!result.includes("&"))
              result = "&" + result;
            let [a, b] = fn("", extra);
            return result.replace(/&(\S+)?/g, (_, pseudo = "") => a + pseudo + b);
          }, {
            values: Object.fromEntries(pseudoVariants)
          });
        }
      },
      directionVariants: ({ addVariant }) => {
        addVariant("ltr", () => {
          _log.default.warn("rtl-experimental", [
            "The RTL features in Tailwind CSS are currently in preview.",
            "Preview features are not covered by semver, and may be improved in breaking ways at any time."
          ]);
          return '[dir="ltr"] &';
        });
        addVariant("rtl", () => {
          _log.default.warn("rtl-experimental", [
            "The RTL features in Tailwind CSS are currently in preview.",
            "Preview features are not covered by semver, and may be improved in breaking ways at any time."
          ]);
          return '[dir="rtl"] &';
        });
      },
      reducedMotionVariants: ({ addVariant }) => {
        addVariant("motion-safe", "@media (prefers-reduced-motion: no-preference)");
        addVariant("motion-reduce", "@media (prefers-reduced-motion: reduce)");
      },
      darkVariants: ({ config, addVariant }) => {
        let [mode, className = ".dark"] = [].concat(config("darkMode", "media"));
        if (mode === false) {
          mode = "media";
          _log.default.warn("darkmode-false", [
            "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
            "Change `darkMode` to `media` or remove it entirely.",
            "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
          ]);
        }
        if (mode === "class") {
          addVariant("dark", `${className} &`);
        } else if (mode === "media") {
          addVariant("dark", "@media (prefers-color-scheme: dark)");
        }
      },
      printVariant: ({ addVariant }) => {
        addVariant("print", "@media print");
      },
      screenVariants: ({ theme, addVariant, matchVariant }) => {
        var ref2;
        let rawScreens = (ref2 = theme("screens")) !== null && ref2 !== void 0 ? ref2 : {};
        let areSimpleScreens = Object.values(rawScreens).every((v) => typeof v === "string");
        let screens = (0, _normalizeScreens.normalizeScreens)(theme("screens"));
        let unitCache = /* @__PURE__ */ new Set([]);
        function units(value) {
          var ref3;
          var ref1;
          return (ref1 = (ref3 = value.match(/(\D+)$/)) === null || ref3 === void 0 ? void 0 : ref3[1]) !== null && ref1 !== void 0 ? ref1 : "(none)";
        }
        function recordUnits(value) {
          if (value !== void 0) {
            unitCache.add(units(value));
          }
        }
        function canUseUnits(value) {
          recordUnits(value);
          return unitCache.size === 1;
        }
        for (const screen of screens) {
          for (const value of screen.values) {
            recordUnits(value.min);
            recordUnits(value.max);
          }
        }
        let screensUseConsistentUnits = unitCache.size <= 1;
        function buildScreenValues(type) {
          return Object.fromEntries(screens.filter((screen) => (0, _normalizeScreens.isScreenSortable)(screen).result).map((screen) => {
            let { min, max } = screen.values[0];
            if (type === "min" && min !== void 0) {
              return screen;
            } else if (type === "min" && max !== void 0) {
              return {
                ...screen,
                not: !screen.not
              };
            } else if (type === "max" && max !== void 0) {
              return screen;
            } else if (type === "max" && min !== void 0) {
              return {
                ...screen,
                not: !screen.not
              };
            }
          }).map((screen) => [
            screen.name,
            screen
          ]));
        }
        function buildSort(type) {
          return (a, z) => (0, _normalizeScreens.compareScreens)(type, a.value, z.value);
        }
        let maxSort = buildSort("max");
        let minSort = buildSort("min");
        function buildScreenVariant(type) {
          return (value) => {
            if (!areSimpleScreens) {
              _log.default.warn("complex-screen-config", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
              ]);
              return [];
            } else if (!screensUseConsistentUnits) {
              _log.default.warn("mixed-screen-units", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
              ]);
              return [];
            } else if (typeof value === "string" && !canUseUnits(value)) {
              _log.default.warn("minmax-have-mixed-units", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
              ]);
              return [];
            }
            return [
              `@media ${(0, _buildMediaQuery.default)((0, _normalizeScreens.toScreen)(value, type))}`
            ];
          };
        }
        matchVariant("max", buildScreenVariant("max"), {
          sort: maxSort,
          values: areSimpleScreens ? buildScreenValues("max") : {}
        });
        let id = "min-screens";
        for (let screen1 of screens) {
          addVariant(screen1.name, `@media ${(0, _buildMediaQuery.default)(screen1)}`, {
            id,
            sort: areSimpleScreens && screensUseConsistentUnits ? minSort : void 0,
            value: screen1
          });
        }
        matchVariant("min", buildScreenVariant("min"), {
          id,
          sort: minSort
        });
      },
      supportsVariants: ({ matchVariant, theme }) => {
        var ref2;
        matchVariant("supports", (value = "") => {
          let check = (0, _dataTypes.normalize)(value);
          let isRaw = /^\w*\s*\(/.test(check);
          check = isRaw ? check.replace(/\b(and|or|not)\b/g, " $1 ") : check;
          if (isRaw) {
            return `@supports ${check}`;
          }
          if (!check.includes(":")) {
            check = `${check}: var(--tw)`;
          }
          if (!(check.startsWith("(") && check.endsWith(")"))) {
            check = `(${check})`;
          }
          return `@supports ${check}`;
        }, {
          values: (ref2 = theme("supports")) !== null && ref2 !== void 0 ? ref2 : {}
        });
      },
      ariaVariants: ({ matchVariant, theme }) => {
        var ref2;
        matchVariant("aria", (value) => `&[aria-${(0, _dataTypes.normalize)(value)}]`, {
          values: (ref2 = theme("aria")) !== null && ref2 !== void 0 ? ref2 : {}
        });
        var ref1;
        matchVariant("group-aria", (value, { modifier }) => modifier ? `:merge(.group\\/${modifier})[aria-${(0, _dataTypes.normalize)(value)}] &` : `:merge(.group)[aria-${(0, _dataTypes.normalize)(value)}] &`, {
          values: (ref1 = theme("aria")) !== null && ref1 !== void 0 ? ref1 : {}
        });
        var ref22;
        matchVariant("peer-aria", (value, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[aria-${(0, _dataTypes.normalize)(value)}] ~ &` : `:merge(.peer)[aria-${(0, _dataTypes.normalize)(value)}] ~ &`, {
          values: (ref22 = theme("aria")) !== null && ref22 !== void 0 ? ref22 : {}
        });
      },
      dataVariants: ({ matchVariant, theme }) => {
        var ref2;
        matchVariant("data", (value) => `&[data-${(0, _dataTypes.normalize)(value)}]`, {
          values: (ref2 = theme("data")) !== null && ref2 !== void 0 ? ref2 : {}
        });
        var ref1;
        matchVariant("group-data", (value, { modifier }) => modifier ? `:merge(.group\\/${modifier})[data-${(0, _dataTypes.normalize)(value)}] &` : `:merge(.group)[data-${(0, _dataTypes.normalize)(value)}] &`, {
          values: (ref1 = theme("data")) !== null && ref1 !== void 0 ? ref1 : {}
        });
        var ref22;
        matchVariant("peer-data", (value, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[data-${(0, _dataTypes.normalize)(value)}] ~ &` : `:merge(.peer)[data-${(0, _dataTypes.normalize)(value)}] ~ &`, {
          values: (ref22 = theme("data")) !== null && ref22 !== void 0 ? ref22 : {}
        });
      },
      orientationVariants: ({ addVariant }) => {
        addVariant("portrait", "@media (orientation: portrait)");
        addVariant("landscape", "@media (orientation: landscape)");
      },
      prefersContrastVariants: ({ addVariant }) => {
        addVariant("contrast-more", "@media (prefers-contrast: more)");
        addVariant("contrast-less", "@media (prefers-contrast: less)");
      }
    };
    var cssTransformValue = [
      "translate(var(--tw-translate-x), var(--tw-translate-y))",
      "rotate(var(--tw-rotate))",
      "skewX(var(--tw-skew-x))",
      "skewY(var(--tw-skew-y))",
      "scaleX(var(--tw-scale-x))",
      "scaleY(var(--tw-scale-y))"
    ].join(" ");
    var cssFilterValue = [
      "var(--tw-blur)",
      "var(--tw-brightness)",
      "var(--tw-contrast)",
      "var(--tw-grayscale)",
      "var(--tw-hue-rotate)",
      "var(--tw-invert)",
      "var(--tw-saturate)",
      "var(--tw-sepia)",
      "var(--tw-drop-shadow)"
    ].join(" ");
    var cssBackdropFilterValue = [
      "var(--tw-backdrop-blur)",
      "var(--tw-backdrop-brightness)",
      "var(--tw-backdrop-contrast)",
      "var(--tw-backdrop-grayscale)",
      "var(--tw-backdrop-hue-rotate)",
      "var(--tw-backdrop-invert)",
      "var(--tw-backdrop-opacity)",
      "var(--tw-backdrop-saturate)",
      "var(--tw-backdrop-sepia)"
    ].join(" ");
    var corePlugins = {
      preflight: ({ addBase }) => {
        let preflightStyles = _postcss.default.parse(_fs.default.readFileSync(_path.join(__dirname, "./css/preflight.css"), "utf8"));
        addBase([
          _postcss.default.comment({
            text: `! tailwindcss v${_packageJson.version} | MIT License | https://tailwindcss.com`
          }),
          ...preflightStyles.nodes
        ]);
      },
      container: (() => {
        function extractMinWidths(breakpoints = []) {
          return breakpoints.flatMap((breakpoint) => breakpoint.values.map((breakpoint2) => breakpoint2.min)).filter((v) => v !== void 0);
        }
        function mapMinWidthsToPadding(minWidths, screens, paddings) {
          if (typeof paddings === "undefined") {
            return [];
          }
          if (!(typeof paddings === "object" && paddings !== null)) {
            return [
              {
                screen: "DEFAULT",
                minWidth: 0,
                padding: paddings
              }
            ];
          }
          let mapping = [];
          if (paddings.DEFAULT) {
            mapping.push({
              screen: "DEFAULT",
              minWidth: 0,
              padding: paddings.DEFAULT
            });
          }
          for (let minWidth of minWidths) {
            for (let screen of screens) {
              for (let { min } of screen.values) {
                if (min === minWidth) {
                  mapping.push({
                    minWidth,
                    padding: paddings[screen.name]
                  });
                }
              }
            }
          }
          return mapping;
        }
        return function({ addComponents, theme }) {
          let screens = (0, _normalizeScreens.normalizeScreens)(theme("container.screens", theme("screens")));
          let minWidths = extractMinWidths(screens);
          let paddings = mapMinWidthsToPadding(minWidths, screens, theme("container.padding"));
          let generatePaddingFor = (minWidth) => {
            let paddingConfig = paddings.find((padding) => padding.minWidth === minWidth);
            if (!paddingConfig) {
              return {};
            }
            return {
              paddingRight: paddingConfig.padding,
              paddingLeft: paddingConfig.padding
            };
          };
          let atRules = Array.from(new Set(minWidths.slice().sort((a, z) => parseInt(a) - parseInt(z)))).map((minWidth) => ({
            [`@media (min-width: ${minWidth})`]: {
              ".container": {
                "max-width": minWidth,
                ...generatePaddingFor(minWidth)
              }
            }
          }));
          addComponents([
            {
              ".container": Object.assign({
                width: "100%"
              }, theme("container.center", false) ? {
                marginRight: "auto",
                marginLeft: "auto"
              } : {}, generatePaddingFor(0))
            },
            ...atRules
          ]);
        };
      })(),
      accessibility: ({ addUtilities }) => {
        addUtilities({
          ".sr-only": {
            position: "absolute",
            width: "1px",
            height: "1px",
            padding: "0",
            margin: "-1px",
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0"
          },
          ".not-sr-only": {
            position: "static",
            width: "auto",
            height: "auto",
            padding: "0",
            margin: "0",
            overflow: "visible",
            clip: "auto",
            whiteSpace: "normal"
          }
        });
      },
      pointerEvents: ({ addUtilities }) => {
        addUtilities({
          ".pointer-events-none": {
            "pointer-events": "none"
          },
          ".pointer-events-auto": {
            "pointer-events": "auto"
          }
        });
      },
      visibility: ({ addUtilities }) => {
        addUtilities({
          ".visible": {
            visibility: "visible"
          },
          ".invisible": {
            visibility: "hidden"
          },
          ".collapse": {
            visibility: "collapse"
          }
        });
      },
      position: ({ addUtilities }) => {
        addUtilities({
          ".static": {
            position: "static"
          },
          ".fixed": {
            position: "fixed"
          },
          ".absolute": {
            position: "absolute"
          },
          ".relative": {
            position: "relative"
          },
          ".sticky": {
            position: "sticky"
          }
        });
      },
      inset: (0, _createUtilityPlugin.default)("inset", [
        [
          "inset",
          [
            "top",
            "right",
            "bottom",
            "left"
          ]
        ],
        [
          [
            "inset-x",
            [
              "left",
              "right"
            ]
          ],
          [
            "inset-y",
            [
              "top",
              "bottom"
            ]
          ]
        ],
        [
          [
            "top",
            [
              "top"
            ]
          ],
          [
            "right",
            [
              "right"
            ]
          ],
          [
            "bottom",
            [
              "bottom"
            ]
          ],
          [
            "left",
            [
              "left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      isolation: ({ addUtilities }) => {
        addUtilities({
          ".isolate": {
            isolation: "isolate"
          },
          ".isolation-auto": {
            isolation: "auto"
          }
        });
      },
      zIndex: (0, _createUtilityPlugin.default)("zIndex", [
        [
          "z",
          [
            "zIndex"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      order: (0, _createUtilityPlugin.default)("order", void 0, {
        supportsNegativeValues: true
      }),
      gridColumn: (0, _createUtilityPlugin.default)("gridColumn", [
        [
          "col",
          [
            "gridColumn"
          ]
        ]
      ]),
      gridColumnStart: (0, _createUtilityPlugin.default)("gridColumnStart", [
        [
          "col-start",
          [
            "gridColumnStart"
          ]
        ]
      ]),
      gridColumnEnd: (0, _createUtilityPlugin.default)("gridColumnEnd", [
        [
          "col-end",
          [
            "gridColumnEnd"
          ]
        ]
      ]),
      gridRow: (0, _createUtilityPlugin.default)("gridRow", [
        [
          "row",
          [
            "gridRow"
          ]
        ]
      ]),
      gridRowStart: (0, _createUtilityPlugin.default)("gridRowStart", [
        [
          "row-start",
          [
            "gridRowStart"
          ]
        ]
      ]),
      gridRowEnd: (0, _createUtilityPlugin.default)("gridRowEnd", [
        [
          "row-end",
          [
            "gridRowEnd"
          ]
        ]
      ]),
      float: ({ addUtilities }) => {
        addUtilities({
          ".float-right": {
            float: "right"
          },
          ".float-left": {
            float: "left"
          },
          ".float-none": {
            float: "none"
          }
        });
      },
      clear: ({ addUtilities }) => {
        addUtilities({
          ".clear-left": {
            clear: "left"
          },
          ".clear-right": {
            clear: "right"
          },
          ".clear-both": {
            clear: "both"
          },
          ".clear-none": {
            clear: "none"
          }
        });
      },
      margin: (0, _createUtilityPlugin.default)("margin", [
        [
          "m",
          [
            "margin"
          ]
        ],
        [
          [
            "mx",
            [
              "margin-left",
              "margin-right"
            ]
          ],
          [
            "my",
            [
              "margin-top",
              "margin-bottom"
            ]
          ]
        ],
        [
          [
            "mt",
            [
              "margin-top"
            ]
          ],
          [
            "mr",
            [
              "margin-right"
            ]
          ],
          [
            "mb",
            [
              "margin-bottom"
            ]
          ],
          [
            "ml",
            [
              "margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      boxSizing: ({ addUtilities }) => {
        addUtilities({
          ".box-border": {
            "box-sizing": "border-box"
          },
          ".box-content": {
            "box-sizing": "content-box"
          }
        });
      },
      display: ({ addUtilities }) => {
        addUtilities({
          ".block": {
            display: "block"
          },
          ".inline-block": {
            display: "inline-block"
          },
          ".inline": {
            display: "inline"
          },
          ".flex": {
            display: "flex"
          },
          ".inline-flex": {
            display: "inline-flex"
          },
          ".table": {
            display: "table"
          },
          ".inline-table": {
            display: "inline-table"
          },
          ".table-caption": {
            display: "table-caption"
          },
          ".table-cell": {
            display: "table-cell"
          },
          ".table-column": {
            display: "table-column"
          },
          ".table-column-group": {
            display: "table-column-group"
          },
          ".table-footer-group": {
            display: "table-footer-group"
          },
          ".table-header-group": {
            display: "table-header-group"
          },
          ".table-row-group": {
            display: "table-row-group"
          },
          ".table-row": {
            display: "table-row"
          },
          ".flow-root": {
            display: "flow-root"
          },
          ".grid": {
            display: "grid"
          },
          ".inline-grid": {
            display: "inline-grid"
          },
          ".contents": {
            display: "contents"
          },
          ".list-item": {
            display: "list-item"
          },
          ".hidden": {
            display: "none"
          }
        });
      },
      aspectRatio: (0, _createUtilityPlugin.default)("aspectRatio", [
        [
          "aspect",
          [
            "aspect-ratio"
          ]
        ]
      ]),
      height: (0, _createUtilityPlugin.default)("height", [
        [
          "h",
          [
            "height"
          ]
        ]
      ]),
      maxHeight: (0, _createUtilityPlugin.default)("maxHeight", [
        [
          "max-h",
          [
            "maxHeight"
          ]
        ]
      ]),
      minHeight: (0, _createUtilityPlugin.default)("minHeight", [
        [
          "min-h",
          [
            "minHeight"
          ]
        ]
      ]),
      width: (0, _createUtilityPlugin.default)("width", [
        [
          "w",
          [
            "width"
          ]
        ]
      ]),
      minWidth: (0, _createUtilityPlugin.default)("minWidth", [
        [
          "min-w",
          [
            "minWidth"
          ]
        ]
      ]),
      maxWidth: (0, _createUtilityPlugin.default)("maxWidth", [
        [
          "max-w",
          [
            "maxWidth"
          ]
        ]
      ]),
      flex: (0, _createUtilityPlugin.default)("flex"),
      flexShrink: (0, _createUtilityPlugin.default)("flexShrink", [
        [
          "flex-shrink",
          [
            "flex-shrink"
          ]
        ],
        [
          "shrink",
          [
            "flex-shrink"
          ]
        ]
      ]),
      flexGrow: (0, _createUtilityPlugin.default)("flexGrow", [
        [
          "flex-grow",
          [
            "flex-grow"
          ]
        ],
        [
          "grow",
          [
            "flex-grow"
          ]
        ]
      ]),
      flexBasis: (0, _createUtilityPlugin.default)("flexBasis", [
        [
          "basis",
          [
            "flex-basis"
          ]
        ]
      ]),
      tableLayout: ({ addUtilities }) => {
        addUtilities({
          ".table-auto": {
            "table-layout": "auto"
          },
          ".table-fixed": {
            "table-layout": "fixed"
          }
        });
      },
      borderCollapse: ({ addUtilities }) => {
        addUtilities({
          ".border-collapse": {
            "border-collapse": "collapse"
          },
          ".border-separate": {
            "border-collapse": "separate"
          }
        });
      },
      borderSpacing: ({ addDefaults, matchUtilities, theme }) => {
        addDefaults("border-spacing", {
          "--tw-border-spacing-x": 0,
          "--tw-border-spacing-y": 0
        });
        matchUtilities({
          "border-spacing": (value) => {
            return {
              "--tw-border-spacing-x": value,
              "--tw-border-spacing-y": value,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-x": (value) => {
            return {
              "--tw-border-spacing-x": value,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-y": (value) => {
            return {
              "--tw-border-spacing-y": value,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          }
        }, {
          values: theme("borderSpacing")
        });
      },
      transformOrigin: (0, _createUtilityPlugin.default)("transformOrigin", [
        [
          "origin",
          [
            "transformOrigin"
          ]
        ]
      ]),
      translate: (0, _createUtilityPlugin.default)("translate", [
        [
          [
            "translate-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-x",
              [
                "transform",
                cssTransformValue
              ]
            ]
          ],
          [
            "translate-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-y",
              [
                "transform",
                cssTransformValue
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      rotate: (0, _createUtilityPlugin.default)("rotate", [
        [
          "rotate",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-rotate",
            [
              "transform",
              cssTransformValue
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      skew: (0, _createUtilityPlugin.default)("skew", [
        [
          [
            "skew-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-x",
              [
                "transform",
                cssTransformValue
              ]
            ]
          ],
          [
            "skew-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-y",
              [
                "transform",
                cssTransformValue
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scale: (0, _createUtilityPlugin.default)("scale", [
        [
          "scale",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-x",
            "--tw-scale-y",
            [
              "transform",
              cssTransformValue
            ]
          ]
        ],
        [
          [
            "scale-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-x",
              [
                "transform",
                cssTransformValue
              ]
            ]
          ],
          [
            "scale-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-y",
              [
                "transform",
                cssTransformValue
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      transform: ({ addDefaults, addUtilities }) => {
        addDefaults("transform", {
          "--tw-translate-x": "0",
          "--tw-translate-y": "0",
          "--tw-rotate": "0",
          "--tw-skew-x": "0",
          "--tw-skew-y": "0",
          "--tw-scale-x": "1",
          "--tw-scale-y": "1"
        });
        addUtilities({
          ".transform": {
            "@defaults transform": {},
            transform: cssTransformValue
          },
          ".transform-cpu": {
            transform: cssTransformValue
          },
          ".transform-gpu": {
            transform: cssTransformValue.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
          },
          ".transform-none": {
            transform: "none"
          }
        });
      },
      animation: ({ matchUtilities, theme, config }) => {
        let prefixName = (name) => `${config("prefix")}${(0, _escapeClassName.default)(name)}`;
        var ref2;
        let keyframes = Object.fromEntries(Object.entries((ref2 = theme("keyframes")) !== null && ref2 !== void 0 ? ref2 : {}).map(([key, value]) => {
          return [
            key,
            {
              [`@keyframes ${prefixName(key)}`]: value
            }
          ];
        }));
        matchUtilities({
          animate: (value) => {
            let animations = (0, _parseAnimationValue.default)(value);
            return [
              ...animations.flatMap((animation) => keyframes[animation.name]),
              {
                animation: animations.map(({ name, value: value2 }) => {
                  if (name === void 0 || keyframes[name] === void 0) {
                    return value2;
                  }
                  return value2.replace(name, prefixName(name));
                }).join(", ")
              }
            ];
          }
        }, {
          values: theme("animation")
        });
      },
      cursor: (0, _createUtilityPlugin.default)("cursor"),
      touchAction: ({ addDefaults, addUtilities }) => {
        addDefaults("touch-action", {
          "--tw-pan-x": " ",
          "--tw-pan-y": " ",
          "--tw-pinch-zoom": " "
        });
        let cssTouchActionValue = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
        addUtilities({
          ".touch-auto": {
            "touch-action": "auto"
          },
          ".touch-none": {
            "touch-action": "none"
          },
          ".touch-pan-x": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-x",
            "touch-action": cssTouchActionValue
          },
          ".touch-pan-left": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-left",
            "touch-action": cssTouchActionValue
          },
          ".touch-pan-right": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-right",
            "touch-action": cssTouchActionValue
          },
          ".touch-pan-y": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-y",
            "touch-action": cssTouchActionValue
          },
          ".touch-pan-up": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-up",
            "touch-action": cssTouchActionValue
          },
          ".touch-pan-down": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-down",
            "touch-action": cssTouchActionValue
          },
          ".touch-pinch-zoom": {
            "@defaults touch-action": {},
            "--tw-pinch-zoom": "pinch-zoom",
            "touch-action": cssTouchActionValue
          },
          ".touch-manipulation": {
            "touch-action": "manipulation"
          }
        });
      },
      userSelect: ({ addUtilities }) => {
        addUtilities({
          ".select-none": {
            "user-select": "none"
          },
          ".select-text": {
            "user-select": "text"
          },
          ".select-all": {
            "user-select": "all"
          },
          ".select-auto": {
            "user-select": "auto"
          }
        });
      },
      resize: ({ addUtilities }) => {
        addUtilities({
          ".resize-none": {
            resize: "none"
          },
          ".resize-y": {
            resize: "vertical"
          },
          ".resize-x": {
            resize: "horizontal"
          },
          ".resize": {
            resize: "both"
          }
        });
      },
      scrollSnapType: ({ addDefaults, addUtilities }) => {
        addDefaults("scroll-snap-type", {
          "--tw-scroll-snap-strictness": "proximity"
        });
        addUtilities({
          ".snap-none": {
            "scroll-snap-type": "none"
          },
          ".snap-x": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
          },
          ".snap-y": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
          },
          ".snap-both": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
          },
          ".snap-mandatory": {
            "--tw-scroll-snap-strictness": "mandatory"
          },
          ".snap-proximity": {
            "--tw-scroll-snap-strictness": "proximity"
          }
        });
      },
      scrollSnapAlign: ({ addUtilities }) => {
        addUtilities({
          ".snap-start": {
            "scroll-snap-align": "start"
          },
          ".snap-end": {
            "scroll-snap-align": "end"
          },
          ".snap-center": {
            "scroll-snap-align": "center"
          },
          ".snap-align-none": {
            "scroll-snap-align": "none"
          }
        });
      },
      scrollSnapStop: ({ addUtilities }) => {
        addUtilities({
          ".snap-normal": {
            "scroll-snap-stop": "normal"
          },
          ".snap-always": {
            "scroll-snap-stop": "always"
          }
        });
      },
      scrollMargin: (0, _createUtilityPlugin.default)("scrollMargin", [
        [
          "scroll-m",
          [
            "scroll-margin"
          ]
        ],
        [
          [
            "scroll-mx",
            [
              "scroll-margin-left",
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-my",
            [
              "scroll-margin-top",
              "scroll-margin-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-mt",
            [
              "scroll-margin-top"
            ]
          ],
          [
            "scroll-mr",
            [
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-mb",
            [
              "scroll-margin-bottom"
            ]
          ],
          [
            "scroll-ml",
            [
              "scroll-margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scrollPadding: (0, _createUtilityPlugin.default)("scrollPadding", [
        [
          "scroll-p",
          [
            "scroll-padding"
          ]
        ],
        [
          [
            "scroll-px",
            [
              "scroll-padding-left",
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-py",
            [
              "scroll-padding-top",
              "scroll-padding-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-pt",
            [
              "scroll-padding-top"
            ]
          ],
          [
            "scroll-pr",
            [
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-pb",
            [
              "scroll-padding-bottom"
            ]
          ],
          [
            "scroll-pl",
            [
              "scroll-padding-left"
            ]
          ]
        ]
      ]),
      listStylePosition: ({ addUtilities }) => {
        addUtilities({
          ".list-inside": {
            "list-style-position": "inside"
          },
          ".list-outside": {
            "list-style-position": "outside"
          }
        });
      },
      listStyleType: (0, _createUtilityPlugin.default)("listStyleType", [
        [
          "list",
          [
            "listStyleType"
          ]
        ]
      ]),
      appearance: ({ addUtilities }) => {
        addUtilities({
          ".appearance-none": {
            appearance: "none"
          }
        });
      },
      columns: (0, _createUtilityPlugin.default)("columns", [
        [
          "columns",
          [
            "columns"
          ]
        ]
      ]),
      breakBefore: ({ addUtilities }) => {
        addUtilities({
          ".break-before-auto": {
            "break-before": "auto"
          },
          ".break-before-avoid": {
            "break-before": "avoid"
          },
          ".break-before-all": {
            "break-before": "all"
          },
          ".break-before-avoid-page": {
            "break-before": "avoid-page"
          },
          ".break-before-page": {
            "break-before": "page"
          },
          ".break-before-left": {
            "break-before": "left"
          },
          ".break-before-right": {
            "break-before": "right"
          },
          ".break-before-column": {
            "break-before": "column"
          }
        });
      },
      breakInside: ({ addUtilities }) => {
        addUtilities({
          ".break-inside-auto": {
            "break-inside": "auto"
          },
          ".break-inside-avoid": {
            "break-inside": "avoid"
          },
          ".break-inside-avoid-page": {
            "break-inside": "avoid-page"
          },
          ".break-inside-avoid-column": {
            "break-inside": "avoid-column"
          }
        });
      },
      breakAfter: ({ addUtilities }) => {
        addUtilities({
          ".break-after-auto": {
            "break-after": "auto"
          },
          ".break-after-avoid": {
            "break-after": "avoid"
          },
          ".break-after-all": {
            "break-after": "all"
          },
          ".break-after-avoid-page": {
            "break-after": "avoid-page"
          },
          ".break-after-page": {
            "break-after": "page"
          },
          ".break-after-left": {
            "break-after": "left"
          },
          ".break-after-right": {
            "break-after": "right"
          },
          ".break-after-column": {
            "break-after": "column"
          }
        });
      },
      gridAutoColumns: (0, _createUtilityPlugin.default)("gridAutoColumns", [
        [
          "auto-cols",
          [
            "gridAutoColumns"
          ]
        ]
      ]),
      gridAutoFlow: ({ addUtilities }) => {
        addUtilities({
          ".grid-flow-row": {
            gridAutoFlow: "row"
          },
          ".grid-flow-col": {
            gridAutoFlow: "column"
          },
          ".grid-flow-dense": {
            gridAutoFlow: "dense"
          },
          ".grid-flow-row-dense": {
            gridAutoFlow: "row dense"
          },
          ".grid-flow-col-dense": {
            gridAutoFlow: "column dense"
          }
        });
      },
      gridAutoRows: (0, _createUtilityPlugin.default)("gridAutoRows", [
        [
          "auto-rows",
          [
            "gridAutoRows"
          ]
        ]
      ]),
      gridTemplateColumns: (0, _createUtilityPlugin.default)("gridTemplateColumns", [
        [
          "grid-cols",
          [
            "gridTemplateColumns"
          ]
        ]
      ]),
      gridTemplateRows: (0, _createUtilityPlugin.default)("gridTemplateRows", [
        [
          "grid-rows",
          [
            "gridTemplateRows"
          ]
        ]
      ]),
      flexDirection: ({ addUtilities }) => {
        addUtilities({
          ".flex-row": {
            "flex-direction": "row"
          },
          ".flex-row-reverse": {
            "flex-direction": "row-reverse"
          },
          ".flex-col": {
            "flex-direction": "column"
          },
          ".flex-col-reverse": {
            "flex-direction": "column-reverse"
          }
        });
      },
      flexWrap: ({ addUtilities }) => {
        addUtilities({
          ".flex-wrap": {
            "flex-wrap": "wrap"
          },
          ".flex-wrap-reverse": {
            "flex-wrap": "wrap-reverse"
          },
          ".flex-nowrap": {
            "flex-wrap": "nowrap"
          }
        });
      },
      placeContent: ({ addUtilities }) => {
        addUtilities({
          ".place-content-center": {
            "place-content": "center"
          },
          ".place-content-start": {
            "place-content": "start"
          },
          ".place-content-end": {
            "place-content": "end"
          },
          ".place-content-between": {
            "place-content": "space-between"
          },
          ".place-content-around": {
            "place-content": "space-around"
          },
          ".place-content-evenly": {
            "place-content": "space-evenly"
          },
          ".place-content-baseline": {
            "place-content": "baseline"
          },
          ".place-content-stretch": {
            "place-content": "stretch"
          }
        });
      },
      placeItems: ({ addUtilities }) => {
        addUtilities({
          ".place-items-start": {
            "place-items": "start"
          },
          ".place-items-end": {
            "place-items": "end"
          },
          ".place-items-center": {
            "place-items": "center"
          },
          ".place-items-baseline": {
            "place-items": "baseline"
          },
          ".place-items-stretch": {
            "place-items": "stretch"
          }
        });
      },
      alignContent: ({ addUtilities }) => {
        addUtilities({
          ".content-center": {
            "align-content": "center"
          },
          ".content-start": {
            "align-content": "flex-start"
          },
          ".content-end": {
            "align-content": "flex-end"
          },
          ".content-between": {
            "align-content": "space-between"
          },
          ".content-around": {
            "align-content": "space-around"
          },
          ".content-evenly": {
            "align-content": "space-evenly"
          },
          ".content-baseline": {
            "align-content": "baseline"
          }
        });
      },
      alignItems: ({ addUtilities }) => {
        addUtilities({
          ".items-start": {
            "align-items": "flex-start"
          },
          ".items-end": {
            "align-items": "flex-end"
          },
          ".items-center": {
            "align-items": "center"
          },
          ".items-baseline": {
            "align-items": "baseline"
          },
          ".items-stretch": {
            "align-items": "stretch"
          }
        });
      },
      justifyContent: ({ addUtilities }) => {
        addUtilities({
          ".justify-start": {
            "justify-content": "flex-start"
          },
          ".justify-end": {
            "justify-content": "flex-end"
          },
          ".justify-center": {
            "justify-content": "center"
          },
          ".justify-between": {
            "justify-content": "space-between"
          },
          ".justify-around": {
            "justify-content": "space-around"
          },
          ".justify-evenly": {
            "justify-content": "space-evenly"
          }
        });
      },
      justifyItems: ({ addUtilities }) => {
        addUtilities({
          ".justify-items-start": {
            "justify-items": "start"
          },
          ".justify-items-end": {
            "justify-items": "end"
          },
          ".justify-items-center": {
            "justify-items": "center"
          },
          ".justify-items-stretch": {
            "justify-items": "stretch"
          }
        });
      },
      gap: (0, _createUtilityPlugin.default)("gap", [
        [
          "gap",
          [
            "gap"
          ]
        ],
        [
          [
            "gap-x",
            [
              "columnGap"
            ]
          ],
          [
            "gap-y",
            [
              "rowGap"
            ]
          ]
        ]
      ]),
      space: ({ matchUtilities, addUtilities, theme }) => {
        matchUtilities({
          "space-x": (value) => {
            value = value === "0" ? "0px" : value;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "0",
                "margin-right": `calc(${value} * var(--tw-space-x-reverse))`,
                "margin-left": `calc(${value} * calc(1 - var(--tw-space-x-reverse)))`
              }
            };
          },
          "space-y": (value) => {
            value = value === "0" ? "0px" : value;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-y-reverse": "0",
                "margin-top": `calc(${value} * calc(1 - var(--tw-space-y-reverse)))`,
                "margin-bottom": `calc(${value} * var(--tw-space-y-reverse))`
              }
            };
          }
        }, {
          values: theme("space"),
          supportsNegativeValues: true
        });
        addUtilities({
          ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-y-reverse": "1"
          },
          ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-x-reverse": "1"
          }
        });
      },
      divideWidth: ({ matchUtilities, addUtilities, theme }) => {
        matchUtilities({
          "divide-x": (value) => {
            value = value === "0" ? "0px" : value;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "0",
                "border-right-width": `calc(${value} * var(--tw-divide-x-reverse))`,
                "border-left-width": `calc(${value} * calc(1 - var(--tw-divide-x-reverse)))`
              }
            };
          },
          "divide-y": (value) => {
            value = value === "0" ? "0px" : value;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-y-reverse": "0",
                "border-top-width": `calc(${value} * calc(1 - var(--tw-divide-y-reverse)))`,
                "border-bottom-width": `calc(${value} * var(--tw-divide-y-reverse))`
              }
            };
          }
        }, {
          values: theme("divideWidth"),
          type: [
            "line-width",
            "length",
            "any"
          ]
        });
        addUtilities({
          ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-y-reverse": "1"
          },
          ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-x-reverse": "1"
          }
        });
      },
      divideStyle: ({ addUtilities }) => {
        addUtilities({
          ".divide-solid > :not([hidden]) ~ :not([hidden])": {
            "border-style": "solid"
          },
          ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dashed"
          },
          ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dotted"
          },
          ".divide-double > :not([hidden]) ~ :not([hidden])": {
            "border-style": "double"
          },
          ".divide-none > :not([hidden]) ~ :not([hidden])": {
            "border-style": "none"
          }
        });
      },
      divideColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
        matchUtilities({
          divide: (value) => {
            if (!corePlugins2("divideOpacity")) {
              return {
                ["& > :not([hidden]) ~ :not([hidden])"]: {
                  "border-color": (0, _toColorValue.default)(value)
                }
              };
            }
            return {
              ["& > :not([hidden]) ~ :not([hidden])"]: (0, _withAlphaVariable.default)({
                color: value,
                property: "border-color",
                variable: "--tw-divide-opacity"
              })
            };
          }
        }, {
          values: (({ DEFAULT: _, ...colors }) => colors)((0, _flattenColorPalette.default)(theme("divideColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      divideOpacity: ({ matchUtilities, theme }) => {
        matchUtilities({
          "divide-opacity": (value) => {
            return {
              [`& > :not([hidden]) ~ :not([hidden])`]: {
                "--tw-divide-opacity": value
              }
            };
          }
        }, {
          values: theme("divideOpacity")
        });
      },
      placeSelf: ({ addUtilities }) => {
        addUtilities({
          ".place-self-auto": {
            "place-self": "auto"
          },
          ".place-self-start": {
            "place-self": "start"
          },
          ".place-self-end": {
            "place-self": "end"
          },
          ".place-self-center": {
            "place-self": "center"
          },
          ".place-self-stretch": {
            "place-self": "stretch"
          }
        });
      },
      alignSelf: ({ addUtilities }) => {
        addUtilities({
          ".self-auto": {
            "align-self": "auto"
          },
          ".self-start": {
            "align-self": "flex-start"
          },
          ".self-end": {
            "align-self": "flex-end"
          },
          ".self-center": {
            "align-self": "center"
          },
          ".self-stretch": {
            "align-self": "stretch"
          },
          ".self-baseline": {
            "align-self": "baseline"
          }
        });
      },
      justifySelf: ({ addUtilities }) => {
        addUtilities({
          ".justify-self-auto": {
            "justify-self": "auto"
          },
          ".justify-self-start": {
            "justify-self": "start"
          },
          ".justify-self-end": {
            "justify-self": "end"
          },
          ".justify-self-center": {
            "justify-self": "center"
          },
          ".justify-self-stretch": {
            "justify-self": "stretch"
          }
        });
      },
      overflow: ({ addUtilities }) => {
        addUtilities({
          ".overflow-auto": {
            overflow: "auto"
          },
          ".overflow-hidden": {
            overflow: "hidden"
          },
          ".overflow-clip": {
            overflow: "clip"
          },
          ".overflow-visible": {
            overflow: "visible"
          },
          ".overflow-scroll": {
            overflow: "scroll"
          },
          ".overflow-x-auto": {
            "overflow-x": "auto"
          },
          ".overflow-y-auto": {
            "overflow-y": "auto"
          },
          ".overflow-x-hidden": {
            "overflow-x": "hidden"
          },
          ".overflow-y-hidden": {
            "overflow-y": "hidden"
          },
          ".overflow-x-clip": {
            "overflow-x": "clip"
          },
          ".overflow-y-clip": {
            "overflow-y": "clip"
          },
          ".overflow-x-visible": {
            "overflow-x": "visible"
          },
          ".overflow-y-visible": {
            "overflow-y": "visible"
          },
          ".overflow-x-scroll": {
            "overflow-x": "scroll"
          },
          ".overflow-y-scroll": {
            "overflow-y": "scroll"
          }
        });
      },
      overscrollBehavior: ({ addUtilities }) => {
        addUtilities({
          ".overscroll-auto": {
            "overscroll-behavior": "auto"
          },
          ".overscroll-contain": {
            "overscroll-behavior": "contain"
          },
          ".overscroll-none": {
            "overscroll-behavior": "none"
          },
          ".overscroll-y-auto": {
            "overscroll-behavior-y": "auto"
          },
          ".overscroll-y-contain": {
            "overscroll-behavior-y": "contain"
          },
          ".overscroll-y-none": {
            "overscroll-behavior-y": "none"
          },
          ".overscroll-x-auto": {
            "overscroll-behavior-x": "auto"
          },
          ".overscroll-x-contain": {
            "overscroll-behavior-x": "contain"
          },
          ".overscroll-x-none": {
            "overscroll-behavior-x": "none"
          }
        });
      },
      scrollBehavior: ({ addUtilities }) => {
        addUtilities({
          ".scroll-auto": {
            "scroll-behavior": "auto"
          },
          ".scroll-smooth": {
            "scroll-behavior": "smooth"
          }
        });
      },
      textOverflow: ({ addUtilities }) => {
        addUtilities({
          ".truncate": {
            overflow: "hidden",
            "text-overflow": "ellipsis",
            "white-space": "nowrap"
          },
          ".overflow-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-clip": {
            "text-overflow": "clip"
          }
        });
      },
      whitespace: ({ addUtilities }) => {
        addUtilities({
          ".whitespace-normal": {
            "white-space": "normal"
          },
          ".whitespace-nowrap": {
            "white-space": "nowrap"
          },
          ".whitespace-pre": {
            "white-space": "pre"
          },
          ".whitespace-pre-line": {
            "white-space": "pre-line"
          },
          ".whitespace-pre-wrap": {
            "white-space": "pre-wrap"
          }
        });
      },
      wordBreak: ({ addUtilities }) => {
        addUtilities({
          ".break-normal": {
            "overflow-wrap": "normal",
            "word-break": "normal"
          },
          ".break-words": {
            "overflow-wrap": "break-word"
          },
          ".break-all": {
            "word-break": "break-all"
          },
          ".break-keep": {
            "word-break": "keep-all"
          }
        });
      },
      borderRadius: (0, _createUtilityPlugin.default)("borderRadius", [
        [
          "rounded",
          [
            "border-radius"
          ]
        ],
        [
          [
            "rounded-t",
            [
              "border-top-left-radius",
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-r",
            [
              "border-top-right-radius",
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-b",
            [
              "border-bottom-right-radius",
              "border-bottom-left-radius"
            ]
          ],
          [
            "rounded-l",
            [
              "border-top-left-radius",
              "border-bottom-left-radius"
            ]
          ]
        ],
        [
          [
            "rounded-tl",
            [
              "border-top-left-radius"
            ]
          ],
          [
            "rounded-tr",
            [
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-br",
            [
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-bl",
            [
              "border-bottom-left-radius"
            ]
          ]
        ]
      ]),
      borderWidth: (0, _createUtilityPlugin.default)("borderWidth", [
        [
          "border",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-width"
          ]
        ],
        [
          [
            "border-x",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width",
              "border-right-width"
            ]
          ],
          [
            "border-y",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width",
              "border-bottom-width"
            ]
          ]
        ],
        [
          [
            "border-t",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width"
            ]
          ],
          [
            "border-r",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-right-width"
            ]
          ],
          [
            "border-b",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-bottom-width"
            ]
          ],
          [
            "border-l",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width"
            ]
          ]
        ]
      ], {
        type: [
          "line-width",
          "length"
        ]
      }),
      borderStyle: ({ addUtilities }) => {
        addUtilities({
          ".border-solid": {
            "border-style": "solid"
          },
          ".border-dashed": {
            "border-style": "dashed"
          },
          ".border-dotted": {
            "border-style": "dotted"
          },
          ".border-double": {
            "border-style": "double"
          },
          ".border-hidden": {
            "border-style": "hidden"
          },
          ".border-none": {
            "border-style": "none"
          }
        });
      },
      borderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
        matchUtilities({
          border: (value) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "border-color",
              variable: "--tw-border-opacity"
            });
          }
        }, {
          values: (({ DEFAULT: _, ...colors }) => colors)((0, _flattenColorPalette.default)(theme("borderColor"))),
          type: [
            "color",
            "any"
          ]
        });
        matchUtilities({
          "border-x": (value) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": (0, _toColorValue.default)(value),
                "border-right-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: [
                "border-left-color",
                "border-right-color"
              ],
              variable: "--tw-border-opacity"
            });
          },
          "border-y": (value) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": (0, _toColorValue.default)(value),
                "border-bottom-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: [
                "border-top-color",
                "border-bottom-color"
              ],
              variable: "--tw-border-opacity"
            });
          }
        }, {
          values: (({ DEFAULT: _, ...colors }) => colors)((0, _flattenColorPalette.default)(theme("borderColor"))),
          type: [
            "color",
            "any"
          ]
        });
        matchUtilities({
          "border-t": (value) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "border-top-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-r": (value) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-right-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "border-right-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-b": (value) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-bottom-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "border-bottom-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-l": (value) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "border-left-color",
              variable: "--tw-border-opacity"
            });
          }
        }, {
          values: (({ DEFAULT: _, ...colors }) => colors)((0, _flattenColorPalette.default)(theme("borderColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      borderOpacity: (0, _createUtilityPlugin.default)("borderOpacity", [
        [
          "border-opacity",
          [
            "--tw-border-opacity"
          ]
        ]
      ]),
      backgroundColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
        matchUtilities({
          bg: (value) => {
            if (!corePlugins2("backgroundOpacity")) {
              return {
                "background-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "background-color",
              variable: "--tw-bg-opacity"
            });
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("backgroundColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      backgroundOpacity: (0, _createUtilityPlugin.default)("backgroundOpacity", [
        [
          "bg-opacity",
          [
            "--tw-bg-opacity"
          ]
        ]
      ]),
      backgroundImage: (0, _createUtilityPlugin.default)("backgroundImage", [
        [
          "bg",
          [
            "background-image"
          ]
        ]
      ], {
        type: [
          "lookup",
          "image",
          "url"
        ]
      }),
      gradientColorStops: (() => {
        function transparentTo(value) {
          return (0, _withAlphaVariable.withAlphaValue)(value, 0, "rgb(255 255 255 / 0)");
        }
        return function({ matchUtilities, theme }) {
          let options = {
            values: (0, _flattenColorPalette.default)(theme("gradientColorStops")),
            type: [
              "color",
              "any"
            ]
          };
          matchUtilities({
            from: (value) => {
              let transparentToValue = transparentTo(value);
              return {
                "--tw-gradient-from": (0, _toColorValue.default)(value, "from"),
                "--tw-gradient-to": transparentToValue,
                "--tw-gradient-stops": `var(--tw-gradient-from), var(--tw-gradient-to)`
              };
            }
          }, options);
          matchUtilities({
            via: (value) => {
              let transparentToValue = transparentTo(value);
              return {
                "--tw-gradient-to": transparentToValue,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, _toColorValue.default)(value, "via")}, var(--tw-gradient-to)`
              };
            }
          }, options);
          matchUtilities({
            to: (value) => ({
              "--tw-gradient-to": (0, _toColorValue.default)(value, "to")
            })
          }, options);
        };
      })(),
      boxDecorationBreak: ({ addUtilities }) => {
        addUtilities({
          ".decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".decoration-clone": {
            "box-decoration-break": "clone"
          },
          ".box-decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".box-decoration-clone": {
            "box-decoration-break": "clone"
          }
        });
      },
      backgroundSize: (0, _createUtilityPlugin.default)("backgroundSize", [
        [
          "bg",
          [
            "background-size"
          ]
        ]
      ], {
        type: [
          "lookup",
          "length",
          "percentage",
          "size"
        ]
      }),
      backgroundAttachment: ({ addUtilities }) => {
        addUtilities({
          ".bg-fixed": {
            "background-attachment": "fixed"
          },
          ".bg-local": {
            "background-attachment": "local"
          },
          ".bg-scroll": {
            "background-attachment": "scroll"
          }
        });
      },
      backgroundClip: ({ addUtilities }) => {
        addUtilities({
          ".bg-clip-border": {
            "background-clip": "border-box"
          },
          ".bg-clip-padding": {
            "background-clip": "padding-box"
          },
          ".bg-clip-content": {
            "background-clip": "content-box"
          },
          ".bg-clip-text": {
            "background-clip": "text"
          }
        });
      },
      backgroundPosition: (0, _createUtilityPlugin.default)("backgroundPosition", [
        [
          "bg",
          [
            "background-position"
          ]
        ]
      ], {
        type: [
          "lookup",
          [
            "position",
            {
              preferOnConflict: true
            }
          ]
        ]
      }),
      backgroundRepeat: ({ addUtilities }) => {
        addUtilities({
          ".bg-repeat": {
            "background-repeat": "repeat"
          },
          ".bg-no-repeat": {
            "background-repeat": "no-repeat"
          },
          ".bg-repeat-x": {
            "background-repeat": "repeat-x"
          },
          ".bg-repeat-y": {
            "background-repeat": "repeat-y"
          },
          ".bg-repeat-round": {
            "background-repeat": "round"
          },
          ".bg-repeat-space": {
            "background-repeat": "space"
          }
        });
      },
      backgroundOrigin: ({ addUtilities }) => {
        addUtilities({
          ".bg-origin-border": {
            "background-origin": "border-box"
          },
          ".bg-origin-padding": {
            "background-origin": "padding-box"
          },
          ".bg-origin-content": {
            "background-origin": "content-box"
          }
        });
      },
      fill: ({ matchUtilities, theme }) => {
        matchUtilities({
          fill: (value) => {
            return {
              fill: (0, _toColorValue.default)(value)
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("fill")),
          type: [
            "color",
            "any"
          ]
        });
      },
      stroke: ({ matchUtilities, theme }) => {
        matchUtilities({
          stroke: (value) => {
            return {
              stroke: (0, _toColorValue.default)(value)
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("stroke")),
          type: [
            "color",
            "url",
            "any"
          ]
        });
      },
      strokeWidth: (0, _createUtilityPlugin.default)("strokeWidth", [
        [
          "stroke",
          [
            "stroke-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      objectFit: ({ addUtilities }) => {
        addUtilities({
          ".object-contain": {
            "object-fit": "contain"
          },
          ".object-cover": {
            "object-fit": "cover"
          },
          ".object-fill": {
            "object-fit": "fill"
          },
          ".object-none": {
            "object-fit": "none"
          },
          ".object-scale-down": {
            "object-fit": "scale-down"
          }
        });
      },
      objectPosition: (0, _createUtilityPlugin.default)("objectPosition", [
        [
          "object",
          [
            "object-position"
          ]
        ]
      ]),
      padding: (0, _createUtilityPlugin.default)("padding", [
        [
          "p",
          [
            "padding"
          ]
        ],
        [
          [
            "px",
            [
              "padding-left",
              "padding-right"
            ]
          ],
          [
            "py",
            [
              "padding-top",
              "padding-bottom"
            ]
          ]
        ],
        [
          [
            "pt",
            [
              "padding-top"
            ]
          ],
          [
            "pr",
            [
              "padding-right"
            ]
          ],
          [
            "pb",
            [
              "padding-bottom"
            ]
          ],
          [
            "pl",
            [
              "padding-left"
            ]
          ]
        ]
      ]),
      textAlign: ({ addUtilities }) => {
        addUtilities({
          ".text-left": {
            "text-align": "left"
          },
          ".text-center": {
            "text-align": "center"
          },
          ".text-right": {
            "text-align": "right"
          },
          ".text-justify": {
            "text-align": "justify"
          },
          ".text-start": {
            "text-align": "start"
          },
          ".text-end": {
            "text-align": "end"
          }
        });
      },
      textIndent: (0, _createUtilityPlugin.default)("textIndent", [
        [
          "indent",
          [
            "text-indent"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      verticalAlign: ({ addUtilities, matchUtilities }) => {
        addUtilities({
          ".align-baseline": {
            "vertical-align": "baseline"
          },
          ".align-top": {
            "vertical-align": "top"
          },
          ".align-middle": {
            "vertical-align": "middle"
          },
          ".align-bottom": {
            "vertical-align": "bottom"
          },
          ".align-text-top": {
            "vertical-align": "text-top"
          },
          ".align-text-bottom": {
            "vertical-align": "text-bottom"
          },
          ".align-sub": {
            "vertical-align": "sub"
          },
          ".align-super": {
            "vertical-align": "super"
          }
        });
        matchUtilities({
          align: (value) => ({
            "vertical-align": value
          })
        });
      },
      fontFamily: ({ matchUtilities, theme }) => {
        matchUtilities({
          font: (value) => {
            let [families, options = {}] = Array.isArray(value) && (0, _isPlainObject.default)(value[1]) ? value : [
              value
            ];
            let { fontFeatureSettings } = options;
            return {
              "font-family": Array.isArray(families) ? families.join(", ") : families,
              ...fontFeatureSettings === void 0 ? {} : {
                "font-feature-settings": fontFeatureSettings
              }
            };
          }
        }, {
          values: theme("fontFamily"),
          type: [
            "lookup",
            "generic-name",
            "family-name"
          ]
        });
      },
      fontSize: ({ matchUtilities, theme }) => {
        matchUtilities({
          text: (value) => {
            let [fontSize, options] = Array.isArray(value) ? value : [
              value
            ];
            let { lineHeight, letterSpacing, fontWeight } = (0, _isPlainObject.default)(options) ? options : {
              lineHeight: options
            };
            return {
              "font-size": fontSize,
              ...lineHeight === void 0 ? {} : {
                "line-height": lineHeight
              },
              ...letterSpacing === void 0 ? {} : {
                "letter-spacing": letterSpacing
              },
              ...fontWeight === void 0 ? {} : {
                "font-weight": fontWeight
              }
            };
          }
        }, {
          values: theme("fontSize"),
          type: [
            "absolute-size",
            "relative-size",
            "length",
            "percentage"
          ]
        });
      },
      fontWeight: (0, _createUtilityPlugin.default)("fontWeight", [
        [
          "font",
          [
            "fontWeight"
          ]
        ]
      ], {
        type: [
          "lookup",
          "number",
          "any"
        ]
      }),
      textTransform: ({ addUtilities }) => {
        addUtilities({
          ".uppercase": {
            "text-transform": "uppercase"
          },
          ".lowercase": {
            "text-transform": "lowercase"
          },
          ".capitalize": {
            "text-transform": "capitalize"
          },
          ".normal-case": {
            "text-transform": "none"
          }
        });
      },
      fontStyle: ({ addUtilities }) => {
        addUtilities({
          ".italic": {
            "font-style": "italic"
          },
          ".not-italic": {
            "font-style": "normal"
          }
        });
      },
      fontVariantNumeric: ({ addDefaults, addUtilities }) => {
        let cssFontVariantNumericValue = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
        addDefaults("font-variant-numeric", {
          "--tw-ordinal": " ",
          "--tw-slashed-zero": " ",
          "--tw-numeric-figure": " ",
          "--tw-numeric-spacing": " ",
          "--tw-numeric-fraction": " "
        });
        addUtilities({
          ".normal-nums": {
            "font-variant-numeric": "normal"
          },
          ".ordinal": {
            "@defaults font-variant-numeric": {},
            "--tw-ordinal": "ordinal",
            "font-variant-numeric": cssFontVariantNumericValue
          },
          ".slashed-zero": {
            "@defaults font-variant-numeric": {},
            "--tw-slashed-zero": "slashed-zero",
            "font-variant-numeric": cssFontVariantNumericValue
          },
          ".lining-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "lining-nums",
            "font-variant-numeric": cssFontVariantNumericValue
          },
          ".oldstyle-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "oldstyle-nums",
            "font-variant-numeric": cssFontVariantNumericValue
          },
          ".proportional-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "proportional-nums",
            "font-variant-numeric": cssFontVariantNumericValue
          },
          ".tabular-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "tabular-nums",
            "font-variant-numeric": cssFontVariantNumericValue
          },
          ".diagonal-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "diagonal-fractions",
            "font-variant-numeric": cssFontVariantNumericValue
          },
          ".stacked-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "stacked-fractions",
            "font-variant-numeric": cssFontVariantNumericValue
          }
        });
      },
      lineHeight: (0, _createUtilityPlugin.default)("lineHeight", [
        [
          "leading",
          [
            "lineHeight"
          ]
        ]
      ]),
      letterSpacing: (0, _createUtilityPlugin.default)("letterSpacing", [
        [
          "tracking",
          [
            "letterSpacing"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      textColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
        matchUtilities({
          text: (value) => {
            if (!corePlugins2("textOpacity")) {
              return {
                color: (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "color",
              variable: "--tw-text-opacity"
            });
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("textColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textOpacity: (0, _createUtilityPlugin.default)("textOpacity", [
        [
          "text-opacity",
          [
            "--tw-text-opacity"
          ]
        ]
      ]),
      textDecoration: ({ addUtilities }) => {
        addUtilities({
          ".underline": {
            "text-decoration-line": "underline"
          },
          ".overline": {
            "text-decoration-line": "overline"
          },
          ".line-through": {
            "text-decoration-line": "line-through"
          },
          ".no-underline": {
            "text-decoration-line": "none"
          }
        });
      },
      textDecorationColor: ({ matchUtilities, theme }) => {
        matchUtilities({
          decoration: (value) => {
            return {
              "text-decoration-color": (0, _toColorValue.default)(value)
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("textDecorationColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textDecorationStyle: ({ addUtilities }) => {
        addUtilities({
          ".decoration-solid": {
            "text-decoration-style": "solid"
          },
          ".decoration-double": {
            "text-decoration-style": "double"
          },
          ".decoration-dotted": {
            "text-decoration-style": "dotted"
          },
          ".decoration-dashed": {
            "text-decoration-style": "dashed"
          },
          ".decoration-wavy": {
            "text-decoration-style": "wavy"
          }
        });
      },
      textDecorationThickness: (0, _createUtilityPlugin.default)("textDecorationThickness", [
        [
          "decoration",
          [
            "text-decoration-thickness"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage"
        ]
      }),
      textUnderlineOffset: (0, _createUtilityPlugin.default)("textUnderlineOffset", [
        [
          "underline-offset",
          [
            "text-underline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage",
          "any"
        ]
      }),
      fontSmoothing: ({ addUtilities }) => {
        addUtilities({
          ".antialiased": {
            "-webkit-font-smoothing": "antialiased",
            "-moz-osx-font-smoothing": "grayscale"
          },
          ".subpixel-antialiased": {
            "-webkit-font-smoothing": "auto",
            "-moz-osx-font-smoothing": "auto"
          }
        });
      },
      placeholderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
        matchUtilities({
          placeholder: (value) => {
            if (!corePlugins2("placeholderOpacity")) {
              return {
                "&::placeholder": {
                  color: (0, _toColorValue.default)(value)
                }
              };
            }
            return {
              "&::placeholder": (0, _withAlphaVariable.default)({
                color: value,
                property: "color",
                variable: "--tw-placeholder-opacity"
              })
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("placeholderColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      placeholderOpacity: ({ matchUtilities, theme }) => {
        matchUtilities({
          "placeholder-opacity": (value) => {
            return {
              ["&::placeholder"]: {
                "--tw-placeholder-opacity": value
              }
            };
          }
        }, {
          values: theme("placeholderOpacity")
        });
      },
      caretColor: ({ matchUtilities, theme }) => {
        matchUtilities({
          caret: (value) => {
            return {
              "caret-color": (0, _toColorValue.default)(value)
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("caretColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      accentColor: ({ matchUtilities, theme }) => {
        matchUtilities({
          accent: (value) => {
            return {
              "accent-color": (0, _toColorValue.default)(value)
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("accentColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      opacity: (0, _createUtilityPlugin.default)("opacity", [
        [
          "opacity",
          [
            "opacity"
          ]
        ]
      ]),
      backgroundBlendMode: ({ addUtilities }) => {
        addUtilities({
          ".bg-blend-normal": {
            "background-blend-mode": "normal"
          },
          ".bg-blend-multiply": {
            "background-blend-mode": "multiply"
          },
          ".bg-blend-screen": {
            "background-blend-mode": "screen"
          },
          ".bg-blend-overlay": {
            "background-blend-mode": "overlay"
          },
          ".bg-blend-darken": {
            "background-blend-mode": "darken"
          },
          ".bg-blend-lighten": {
            "background-blend-mode": "lighten"
          },
          ".bg-blend-color-dodge": {
            "background-blend-mode": "color-dodge"
          },
          ".bg-blend-color-burn": {
            "background-blend-mode": "color-burn"
          },
          ".bg-blend-hard-light": {
            "background-blend-mode": "hard-light"
          },
          ".bg-blend-soft-light": {
            "background-blend-mode": "soft-light"
          },
          ".bg-blend-difference": {
            "background-blend-mode": "difference"
          },
          ".bg-blend-exclusion": {
            "background-blend-mode": "exclusion"
          },
          ".bg-blend-hue": {
            "background-blend-mode": "hue"
          },
          ".bg-blend-saturation": {
            "background-blend-mode": "saturation"
          },
          ".bg-blend-color": {
            "background-blend-mode": "color"
          },
          ".bg-blend-luminosity": {
            "background-blend-mode": "luminosity"
          }
        });
      },
      mixBlendMode: ({ addUtilities }) => {
        addUtilities({
          ".mix-blend-normal": {
            "mix-blend-mode": "normal"
          },
          ".mix-blend-multiply": {
            "mix-blend-mode": "multiply"
          },
          ".mix-blend-screen": {
            "mix-blend-mode": "screen"
          },
          ".mix-blend-overlay": {
            "mix-blend-mode": "overlay"
          },
          ".mix-blend-darken": {
            "mix-blend-mode": "darken"
          },
          ".mix-blend-lighten": {
            "mix-blend-mode": "lighten"
          },
          ".mix-blend-color-dodge": {
            "mix-blend-mode": "color-dodge"
          },
          ".mix-blend-color-burn": {
            "mix-blend-mode": "color-burn"
          },
          ".mix-blend-hard-light": {
            "mix-blend-mode": "hard-light"
          },
          ".mix-blend-soft-light": {
            "mix-blend-mode": "soft-light"
          },
          ".mix-blend-difference": {
            "mix-blend-mode": "difference"
          },
          ".mix-blend-exclusion": {
            "mix-blend-mode": "exclusion"
          },
          ".mix-blend-hue": {
            "mix-blend-mode": "hue"
          },
          ".mix-blend-saturation": {
            "mix-blend-mode": "saturation"
          },
          ".mix-blend-color": {
            "mix-blend-mode": "color"
          },
          ".mix-blend-luminosity": {
            "mix-blend-mode": "luminosity"
          },
          ".mix-blend-plus-lighter": {
            "mix-blend-mode": "plus-lighter"
          }
        });
      },
      boxShadow: (() => {
        let transformValue = (0, _transformThemeValue.default)("boxShadow");
        let defaultBoxShadow = [
          `var(--tw-ring-offset-shadow, 0 0 #0000)`,
          `var(--tw-ring-shadow, 0 0 #0000)`,
          `var(--tw-shadow)`
        ].join(", ");
        return function({ matchUtilities, addDefaults, theme }) {
          addDefaults(" box-shadow", {
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
          });
          matchUtilities({
            shadow: (value) => {
              value = transformValue(value);
              let ast = (0, _parseBoxShadowValue.parseBoxShadowValue)(value);
              for (let shadow of ast) {
                if (!shadow.valid) {
                  continue;
                }
                shadow.color = "var(--tw-shadow-color)";
              }
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": value === "none" ? "0 0 #0000" : value,
                "--tw-shadow-colored": value === "none" ? "0 0 #0000" : (0, _parseBoxShadowValue.formatBoxShadowValue)(ast),
                "box-shadow": defaultBoxShadow
              };
            }
          }, {
            values: theme("boxShadow"),
            type: [
              "shadow"
            ]
          });
        };
      })(),
      boxShadowColor: ({ matchUtilities, theme }) => {
        matchUtilities({
          shadow: (value) => {
            return {
              "--tw-shadow-color": (0, _toColorValue.default)(value),
              "--tw-shadow": "var(--tw-shadow-colored)"
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("boxShadowColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      outlineStyle: ({ addUtilities }) => {
        addUtilities({
          ".outline-none": {
            outline: "2px solid transparent",
            "outline-offset": "2px"
          },
          ".outline": {
            "outline-style": "solid"
          },
          ".outline-dashed": {
            "outline-style": "dashed"
          },
          ".outline-dotted": {
            "outline-style": "dotted"
          },
          ".outline-double": {
            "outline-style": "double"
          }
        });
      },
      outlineWidth: (0, _createUtilityPlugin.default)("outlineWidth", [
        [
          "outline",
          [
            "outline-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      outlineOffset: (0, _createUtilityPlugin.default)("outlineOffset", [
        [
          "outline-offset",
          [
            "outline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage",
          "any"
        ],
        supportsNegativeValues: true
      }),
      outlineColor: ({ matchUtilities, theme }) => {
        matchUtilities({
          outline: (value) => {
            return {
              "outline-color": (0, _toColorValue.default)(value)
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("outlineColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringWidth: ({ matchUtilities, addDefaults, addUtilities, theme, config }) => {
        let ringColorDefault = (() => {
          var ref2, ref1;
          if ((0, _featureFlags.flagEnabled)(config(), "respectDefaultRingColorOpacity")) {
            return theme("ringColor.DEFAULT");
          }
          let ringOpacityDefault = theme("ringOpacity.DEFAULT", "0.5");
          if (!((ref2 = theme("ringColor")) === null || ref2 === void 0 ? void 0 : ref2.DEFAULT)) {
            return `rgb(147 197 253 / ${ringOpacityDefault})`;
          }
          return (0, _withAlphaVariable.withAlphaValue)((ref1 = theme("ringColor")) === null || ref1 === void 0 ? void 0 : ref1.DEFAULT, ringOpacityDefault, `rgb(147 197 253 / ${ringOpacityDefault})`);
        })();
        addDefaults("ring-width", {
          "--tw-ring-inset": " ",
          "--tw-ring-offset-width": theme("ringOffsetWidth.DEFAULT", "0px"),
          "--tw-ring-offset-color": theme("ringOffsetColor.DEFAULT", "#fff"),
          "--tw-ring-color": ringColorDefault,
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        });
        matchUtilities({
          ring: (value) => {
            return {
              "@defaults ring-width": {},
              "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
              "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${value} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
              "box-shadow": [
                `var(--tw-ring-offset-shadow)`,
                `var(--tw-ring-shadow)`,
                `var(--tw-shadow, 0 0 #0000)`
              ].join(", ")
            };
          }
        }, {
          values: theme("ringWidth"),
          type: "length"
        });
        addUtilities({
          ".ring-inset": {
            "@defaults ring-width": {},
            "--tw-ring-inset": "inset"
          }
        });
      },
      ringColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
        matchUtilities({
          ring: (value) => {
            if (!corePlugins2("ringOpacity")) {
              return {
                "--tw-ring-color": (0, _toColorValue.default)(value)
              };
            }
            return (0, _withAlphaVariable.default)({
              color: value,
              property: "--tw-ring-color",
              variable: "--tw-ring-opacity"
            });
          }
        }, {
          values: Object.fromEntries(Object.entries((0, _flattenColorPalette.default)(theme("ringColor"))).filter(([modifier]) => modifier !== "DEFAULT")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringOpacity: (helpers) => {
        let { config } = helpers;
        return (0, _createUtilityPlugin.default)("ringOpacity", [
          [
            "ring-opacity",
            [
              "--tw-ring-opacity"
            ]
          ]
        ], {
          filterDefault: !(0, _featureFlags.flagEnabled)(config(), "respectDefaultRingColorOpacity")
        })(helpers);
      },
      ringOffsetWidth: (0, _createUtilityPlugin.default)("ringOffsetWidth", [
        [
          "ring-offset",
          [
            "--tw-ring-offset-width"
          ]
        ]
      ], {
        type: "length"
      }),
      ringOffsetColor: ({ matchUtilities, theme }) => {
        matchUtilities({
          "ring-offset": (value) => {
            return {
              "--tw-ring-offset-color": (0, _toColorValue.default)(value)
            };
          }
        }, {
          values: (0, _flattenColorPalette.default)(theme("ringOffsetColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      blur: ({ matchUtilities, theme }) => {
        matchUtilities({
          blur: (value) => {
            return {
              "--tw-blur": `blur(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("blur")
        });
      },
      brightness: ({ matchUtilities, theme }) => {
        matchUtilities({
          brightness: (value) => {
            return {
              "--tw-brightness": `brightness(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("brightness")
        });
      },
      contrast: ({ matchUtilities, theme }) => {
        matchUtilities({
          contrast: (value) => {
            return {
              "--tw-contrast": `contrast(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("contrast")
        });
      },
      dropShadow: ({ matchUtilities, theme }) => {
        matchUtilities({
          "drop-shadow": (value) => {
            return {
              "--tw-drop-shadow": Array.isArray(value) ? value.map((v) => `drop-shadow(${v})`).join(" ") : `drop-shadow(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("dropShadow")
        });
      },
      grayscale: ({ matchUtilities, theme }) => {
        matchUtilities({
          grayscale: (value) => {
            return {
              "--tw-grayscale": `grayscale(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("grayscale")
        });
      },
      hueRotate: ({ matchUtilities, theme }) => {
        matchUtilities({
          "hue-rotate": (value) => {
            return {
              "--tw-hue-rotate": `hue-rotate(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("hueRotate"),
          supportsNegativeValues: true
        });
      },
      invert: ({ matchUtilities, theme }) => {
        matchUtilities({
          invert: (value) => {
            return {
              "--tw-invert": `invert(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("invert")
        });
      },
      saturate: ({ matchUtilities, theme }) => {
        matchUtilities({
          saturate: (value) => {
            return {
              "--tw-saturate": `saturate(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("saturate")
        });
      },
      sepia: ({ matchUtilities, theme }) => {
        matchUtilities({
          sepia: (value) => {
            return {
              "--tw-sepia": `sepia(${value})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        }, {
          values: theme("sepia")
        });
      },
      filter: ({ addDefaults, addUtilities }) => {
        addDefaults("filter", {
          "--tw-blur": " ",
          "--tw-brightness": " ",
          "--tw-contrast": " ",
          "--tw-grayscale": " ",
          "--tw-hue-rotate": " ",
          "--tw-invert": " ",
          "--tw-saturate": " ",
          "--tw-sepia": " ",
          "--tw-drop-shadow": " "
        });
        addUtilities({
          ".filter": {
            "@defaults filter": {},
            filter: cssFilterValue
          },
          ".filter-none": {
            filter: "none"
          }
        });
      },
      backdropBlur: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-blur": (value) => {
            return {
              "--tw-backdrop-blur": `blur(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropBlur")
        });
      },
      backdropBrightness: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-brightness": (value) => {
            return {
              "--tw-backdrop-brightness": `brightness(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropBrightness")
        });
      },
      backdropContrast: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-contrast": (value) => {
            return {
              "--tw-backdrop-contrast": `contrast(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropContrast")
        });
      },
      backdropGrayscale: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-grayscale": (value) => {
            return {
              "--tw-backdrop-grayscale": `grayscale(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropGrayscale")
        });
      },
      backdropHueRotate: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-hue-rotate": (value) => {
            return {
              "--tw-backdrop-hue-rotate": `hue-rotate(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropHueRotate"),
          supportsNegativeValues: true
        });
      },
      backdropInvert: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-invert": (value) => {
            return {
              "--tw-backdrop-invert": `invert(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropInvert")
        });
      },
      backdropOpacity: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-opacity": (value) => {
            return {
              "--tw-backdrop-opacity": `opacity(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropOpacity")
        });
      },
      backdropSaturate: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-saturate": (value) => {
            return {
              "--tw-backdrop-saturate": `saturate(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropSaturate")
        });
      },
      backdropSepia: ({ matchUtilities, theme }) => {
        matchUtilities({
          "backdrop-sepia": (value) => {
            return {
              "--tw-backdrop-sepia": `sepia(${value})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        }, {
          values: theme("backdropSepia")
        });
      },
      backdropFilter: ({ addDefaults, addUtilities }) => {
        addDefaults("backdrop-filter", {
          "--tw-backdrop-blur": " ",
          "--tw-backdrop-brightness": " ",
          "--tw-backdrop-contrast": " ",
          "--tw-backdrop-grayscale": " ",
          "--tw-backdrop-hue-rotate": " ",
          "--tw-backdrop-invert": " ",
          "--tw-backdrop-opacity": " ",
          "--tw-backdrop-saturate": " ",
          "--tw-backdrop-sepia": " "
        });
        addUtilities({
          ".backdrop-filter": {
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          },
          ".backdrop-filter-none": {
            "backdrop-filter": "none"
          }
        });
      },
      transitionProperty: ({ matchUtilities, theme }) => {
        let defaultTimingFunction = theme("transitionTimingFunction.DEFAULT");
        let defaultDuration = theme("transitionDuration.DEFAULT");
        matchUtilities({
          transition: (value) => {
            return {
              "transition-property": value,
              ...value === "none" ? {} : {
                "transition-timing-function": defaultTimingFunction,
                "transition-duration": defaultDuration
              }
            };
          }
        }, {
          values: theme("transitionProperty")
        });
      },
      transitionDelay: (0, _createUtilityPlugin.default)("transitionDelay", [
        [
          "delay",
          [
            "transitionDelay"
          ]
        ]
      ]),
      transitionDuration: (0, _createUtilityPlugin.default)("transitionDuration", [
        [
          "duration",
          [
            "transitionDuration"
          ]
        ]
      ], {
        filterDefault: true
      }),
      transitionTimingFunction: (0, _createUtilityPlugin.default)("transitionTimingFunction", [
        [
          "ease",
          [
            "transitionTimingFunction"
          ]
        ]
      ], {
        filterDefault: true
      }),
      willChange: (0, _createUtilityPlugin.default)("willChange", [
        [
          "will-change",
          [
            "will-change"
          ]
        ]
      ]),
      content: (0, _createUtilityPlugin.default)("content", [
        [
          "content",
          [
            "--tw-content",
            [
              "content",
              "var(--tw-content)"
            ]
          ]
        ]
      ])
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/sharedState.js
var require_sharedState = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/sharedState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      env: () => env,
      contextMap: () => contextMap,
      configContextMap: () => configContextMap,
      contextSourcesMap: () => contextSourcesMap,
      sourceHashMap: () => sourceHashMap,
      NOT_ON_DEMAND: () => NOT_ON_DEMAND,
      NONE: () => NONE,
      resolveDebug: () => resolveDebug
    });
    var env = {
      NODE_ENV: process.env.NODE_ENV,
      DEBUG: resolveDebug(process.env.DEBUG)
    };
    var contextMap = /* @__PURE__ */ new Map();
    var configContextMap = /* @__PURE__ */ new Map();
    var contextSourcesMap = /* @__PURE__ */ new Map();
    var sourceHashMap = /* @__PURE__ */ new Map();
    var NOT_ON_DEMAND = new String("*");
    var NONE = Symbol("__NONE__");
    function resolveDebug(debug) {
      if (debug === void 0) {
        return false;
      }
      if (debug === "true" || debug === "1") {
        return true;
      }
      if (debug === "false" || debug === "0") {
        return false;
      }
      if (debug === "*") {
        return true;
      }
      let debuggers = debug.split(",").map((d) => d.split(":")[0]);
      if (debuggers.includes("-tailwindcss")) {
        return false;
      }
      if (debuggers.includes("tailwindcss")) {
        return true;
      }
      return false;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/isValidArbitraryValue.js
var require_isValidArbitraryValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/isValidArbitraryValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(
      exports,
      "default",
      {
        enumerable: true,
        get: () => isValidArbitraryValue
      }
    );
    var matchingBrackets = /* @__PURE__ */ new Map([
      [
        "{",
        "}"
      ],
      [
        "[",
        "]"
      ],
      [
        "(",
        ")"
      ]
    ]);
    var inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(([k, v]) => [
      v,
      k
    ]));
    var quotes = /* @__PURE__ */ new Set([
      '"',
      "'",
      "`"
    ]);
    function isValidArbitraryValue(value) {
      let stack = [];
      let inQuotes = false;
      for (let i = 0; i < value.length; i++) {
        let char = value[i];
        if (char === ":" && !inQuotes && stack.length === 0) {
          return false;
        }
        if (quotes.has(char) && value[i - 1] !== "\\") {
          inQuotes = !inQuotes;
        }
        if (inQuotes)
          continue;
        if (value[i - 1] === "\\")
          continue;
        if (matchingBrackets.has(char)) {
          stack.push(char);
        } else if (inverseMatchingBrackets.has(char)) {
          let inverse = inverseMatchingBrackets.get(char);
          if (stack.length <= 0) {
            return false;
          }
          if (stack.pop() !== inverse) {
            return false;
          }
        }
      }
      if (stack.length > 0) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/formatVariantSelector.js
var require_formatVariantSelector = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/formatVariantSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      selectorFunctions: () => selectorFunctions,
      formatVariantSelector: () => formatVariantSelector,
      finalizeSelector: () => finalizeSelector
    });
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _unesc = /* @__PURE__ */ _interopRequireDefault(require_unesc());
    var _escapeClassName = /* @__PURE__ */ _interopRequireDefault(require_escapeClassName());
    var _prefixSelector = /* @__PURE__ */ _interopRequireDefault(require_prefixSelector());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ref2;
    var MERGE = ":merge";
    var PARENT = "&";
    var selectorFunctions = /* @__PURE__ */ new Set([
      MERGE
    ]);
    function formatVariantSelector(current2, ...others) {
      for (let other of others) {
        let incomingValue = resolveFunctionArgument(other, MERGE);
        if (incomingValue !== null) {
          let existingValue = resolveFunctionArgument(current2, MERGE, incomingValue);
          if (existingValue !== null) {
            let existingTarget = `${MERGE}(${incomingValue})`;
            let splitIdx = other.indexOf(existingTarget);
            let addition = other.slice(splitIdx + existingTarget.length).split(" ")[0];
            current2 = current2.replace(existingTarget, existingTarget + addition);
            continue;
          }
        }
        current2 = other.replace(PARENT, current2);
      }
      return current2;
    }
    function simpleSelectorForNode(node) {
      let nodes = [];
      while (node.prev() && node.prev().type !== "combinator") {
        node = node.prev();
      }
      while (node && node.type !== "combinator") {
        nodes.push(node);
        node = node.next();
      }
      return nodes;
    }
    function resortSelector(sel) {
      sel.sort((a, b) => {
        if (a.type === "tag" && b.type === "class") {
          return -1;
        } else if (a.type === "class" && b.type === "tag") {
          return 1;
        } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
          return -1;
        } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
          return 1;
        }
        return sel.index(a) - sel.index(b);
      });
      return sel;
    }
    function eliminateIrrelevantSelectors(sel, base2) {
      let hasClassesMatchingCandidate = false;
      sel.walk((child) => {
        if (child.type === "class" && child.value === base2) {
          hasClassesMatchingCandidate = true;
          return false;
        }
      });
      if (!hasClassesMatchingCandidate) {
        sel.remove();
      }
    }
    var ref1;
    function finalizeSelector(format, {
      selector,
      candidate,
      context,
      isArbitraryVariant,
      base: base2 = candidate.split(new RegExp(`\\${(ref1 = context === null || context === void 0 ? void 0 : (ref2 = context.tailwindConfig) === null || ref2 === void 0 ? void 0 : ref2.separator) !== null && ref1 !== void 0 ? ref1 : ":"}(?![^[]*\\])`)).pop()
    }) {
      var ref22;
      let ast = (0, _postcssSelectorParser.default)().astSync(selector);
      if ((context === null || context === void 0 ? void 0 : (ref22 = context.tailwindConfig) === null || ref22 === void 0 ? void 0 : ref22.prefix) && !isArbitraryVariant) {
        format = (0, _prefixSelector.default)(context.tailwindConfig.prefix, format);
      }
      format = format.replace(PARENT, `.${(0, _escapeClassName.default)(candidate)}`);
      let formatAst = (0, _postcssSelectorParser.default)().astSync(format);
      ast.each((sel) => eliminateIrrelevantSelectors(sel, base2));
      ast.walkClasses((node) => {
        if (node.raws && node.value.includes(base2)) {
          node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));
        }
      });
      let simpleStart = _postcssSelectorParser.default.comment({
        value: "/*__simple__*/"
      });
      let simpleEnd = _postcssSelectorParser.default.comment({
        value: "/*__simple__*/"
      });
      ast.walkClasses((node) => {
        if (node.value !== base2) {
          return;
        }
        let parent = node.parent;
        let formatNodes = formatAst.nodes[0].nodes;
        if (parent.nodes.length === 1) {
          node.replaceWith(...formatNodes);
          return;
        }
        let simpleSelector = simpleSelectorForNode(node);
        parent.insertBefore(simpleSelector[0], simpleStart);
        parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
        for (let child of formatNodes) {
          parent.insertBefore(simpleSelector[0], child);
        }
        node.remove();
        simpleSelector = simpleSelectorForNode(simpleStart);
        let firstNode = parent.index(simpleStart);
        parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssSelectorParser.default.selector({
          nodes: simpleSelector
        })).nodes);
        simpleStart.remove();
        simpleEnd.remove();
      });
      function collectPseudoElements(selector2) {
        let nodes = [];
        for (let node of selector2.nodes) {
          if (isPseudoElement(node)) {
            nodes.push(node);
            selector2.removeChild(node);
          }
          if (node === null || node === void 0 ? void 0 : node.nodes) {
            nodes.push(...collectPseudoElements(node));
          }
        }
        return nodes;
      }
      ast.each((selector2) => {
        selector2.walkPseudos((p) => {
          if (selectorFunctions.has(p.value)) {
            p.replaceWith(p.nodes);
          }
        });
        let pseudoElements = collectPseudoElements(selector2);
        if (pseudoElements.length > 0) {
          selector2.nodes.push(pseudoElements.sort(sortSelector));
        }
      });
      return ast.toString();
    }
    var pseudoElementsBC = [
      ":before",
      ":after",
      ":first-line",
      ":first-letter"
    ];
    var pseudoElementExceptions = [
      "::file-selector-button"
    ];
    function sortSelector(a, z) {
      if (a.type !== "pseudo" && z.type !== "pseudo") {
        return 0;
      }
      if (a.type === "combinator" ^ z.type === "combinator") {
        return 0;
      }
      if (a.type === "pseudo" ^ z.type === "pseudo") {
        return (a.type === "pseudo") - (z.type === "pseudo");
      }
      return isPseudoElement(a) - isPseudoElement(z);
    }
    function isPseudoElement(node) {
      if (node.type !== "pseudo")
        return false;
      if (pseudoElementExceptions.includes(node.value))
        return false;
      return node.value.startsWith("::") || pseudoElementsBC.includes(node.value);
    }
    function resolveFunctionArgument(haystack, needle, arg) {
      let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle);
      if (startIdx === -1)
        return null;
      startIdx += needle.length + 1;
      let target = "";
      let count = 0;
      for (let char of haystack.slice(startIdx)) {
        if (char !== "(" && char !== ")") {
          target += char;
        } else if (char === "(") {
          target += char;
          count++;
        } else if (char === ")") {
          if (--count < 0)
            break;
          target += char;
        }
      }
      return target;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/generateRules.js
var require_generateRules = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/generateRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getClassNameFromSelector: () => getClassNameFromSelector,
      resolveMatches: () => resolveMatches,
      generateRules: () => generateRules
    });
    var _postcss = /* @__PURE__ */ _interopRequireDefault(require("postcss"));
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _parseObjectStyles = /* @__PURE__ */ _interopRequireDefault(require_parseObjectStyles());
    var _isPlainObject = /* @__PURE__ */ _interopRequireDefault(require_isPlainObject());
    var _prefixSelector = /* @__PURE__ */ _interopRequireDefault(require_prefixSelector());
    var _pluginUtils = require_pluginUtils();
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    var _sharedState = /* @__PURE__ */ _interopRequireWildcard(require_sharedState());
    var _formatVariantSelector = require_formatVariantSelector();
    var _nameClass = require_nameClass();
    var _dataTypes = require_dataTypes();
    var _setupContextUtils = require_setupContextUtils();
    var _isValidArbitraryValue = /* @__PURE__ */ _interopRequireDefault(require_isValidArbitraryValue());
    var _splitAtTopLevelOnlyJs = require_splitAtTopLevelOnly();
    var _featureFlags = require_featureFlags();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var classNameParser = (0, _postcssSelectorParser.default)((selectors) => {
      return selectors.first.filter(({ type }) => type === "class").pop().value;
    });
    function getClassNameFromSelector(selector) {
      return classNameParser.transformSync(selector);
    }
    function* candidatePermutations(candidate) {
      let lastIndex = Infinity;
      while (lastIndex >= 0) {
        let dashIdx;
        let wasSlash = false;
        if (lastIndex === Infinity && candidate.endsWith("]")) {
          let bracketIdx = candidate.indexOf("[");
          if (candidate[bracketIdx - 1] === "-") {
            dashIdx = bracketIdx - 1;
          } else if (candidate[bracketIdx - 1] === "/") {
            dashIdx = bracketIdx - 1;
            wasSlash = true;
          } else {
            dashIdx = -1;
          }
        } else if (lastIndex === Infinity && candidate.includes("/")) {
          dashIdx = candidate.lastIndexOf("/");
          wasSlash = true;
        } else {
          dashIdx = candidate.lastIndexOf("-", lastIndex);
        }
        if (dashIdx < 0) {
          break;
        }
        let prefix = candidate.slice(0, dashIdx);
        let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
        lastIndex = dashIdx - 1;
        if (prefix === "" || modifier === "/") {
          continue;
        }
        yield [
          prefix,
          modifier
        ];
      }
    }
    function applyPrefix(matches, context) {
      if (matches.length === 0 || context.tailwindConfig.prefix === "") {
        return matches;
      }
      for (let match of matches) {
        let [meta] = match;
        if (meta.options.respectPrefix) {
          let container = _postcss.default.root({
            nodes: [
              match[1].clone()
            ]
          });
          let classCandidate = match[1].raws.tailwind.classCandidate;
          container.walkRules((r) => {
            let shouldPrependNegative = classCandidate.startsWith("-");
            r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);
          });
          match[1] = container.nodes[0];
        }
      }
      return matches;
    }
    function applyImportant(matches, classCandidate) {
      if (matches.length === 0) {
        return matches;
      }
      let result = [];
      for (let [meta, rule] of matches) {
        let container = _postcss.default.root({
          nodes: [
            rule.clone()
          ]
        });
        container.walkRules((r) => {
          r.selector = (0, _pluginUtils.updateAllClasses)((0, _pluginUtils.filterSelectorsForClass)(r.selector, classCandidate), (className) => {
            if (className === classCandidate) {
              return `!${className}`;
            }
            return className;
          });
          r.walkDecls((d) => d.important = true);
        });
        result.push([
          {
            ...meta,
            important: true
          },
          container.nodes[0]
        ]);
      }
      return result;
    }
    function applyVariant(variant, matches, context) {
      if (matches.length === 0) {
        return matches;
      }
      let args = {
        modifier: null,
        value: _sharedState.NONE
      };
      {
        let match = /(.*)\/(.*)$/g.exec(variant);
        if (match) {
          variant = match[1];
          args.modifier = match[2];
          if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, "generalizedModifiers")) {
            return [];
          }
        }
      }
      if (variant.endsWith("]") && !variant.startsWith("[")) {
        let match1 = /(.)(-?)\[(.*)\]/g.exec(variant);
        if (match1) {
          let [, char, seperator, value] = match1;
          if (char === "@" && seperator === "-")
            return [];
          if (char !== "@" && seperator === "")
            return [];
          variant = variant.replace(`${seperator}[${value}]`, "");
          args.value = value;
        }
      }
      if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {
        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));
        if (!(0, _setupContextUtils.isValidVariantFormatString)(selector)) {
          return [];
        }
        let fn = (0, _setupContextUtils.parseVariant)(selector);
        let sort = context.offsets.recordVariant(variant);
        context.variantMap.set(variant, [
          [
            sort,
            fn
          ]
        ]);
      }
      if (context.variantMap.has(variant)) {
        let variantFunctionTuples = context.variantMap.get(variant).slice();
        let result = [];
        for (let [meta, rule] of matches) {
          if (meta.layer === "user") {
            continue;
          }
          let container = _postcss.default.root({
            nodes: [
              rule.clone()
            ]
          });
          for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {
            let prepareBackup = function() {
              if (clone.raws.neededBackup) {
                return;
              }
              clone.raws.neededBackup = true;
              clone.walkRules((rule2) => rule2.raws.originalSelector = rule2.selector);
            }, modifySelectors = function(modifierFunction) {
              prepareBackup();
              clone.each((rule2) => {
                if (rule2.type !== "rule") {
                  return;
                }
                rule2.selectors = rule2.selectors.map((selector) => {
                  return modifierFunction({
                    get className() {
                      return getClassNameFromSelector(selector);
                    },
                    selector
                  });
                });
              });
              return clone;
            };
            let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();
            let collectedFormats = [];
            let ruleWithVariant = variantFunction({
              get container() {
                prepareBackup();
                return clone;
              },
              separator: context.tailwindConfig.separator,
              modifySelectors,
              wrap(wrapper) {
                let nodes = clone.nodes;
                clone.removeAll();
                wrapper.append(nodes);
                clone.append(wrapper);
              },
              format(selectorFormat) {
                collectedFormats.push(selectorFormat);
              },
              args
            });
            if (Array.isArray(ruleWithVariant)) {
              for (let [idx, variantFunction1] of ruleWithVariant.entries()) {
                variantFunctionTuples.push([
                  context.offsets.applyParallelOffset(variantSort, idx),
                  variantFunction1,
                  clone.clone()
                ]);
              }
              continue;
            }
            if (typeof ruleWithVariant === "string") {
              collectedFormats.push(ruleWithVariant);
            }
            if (ruleWithVariant === null) {
              continue;
            }
            if (clone.raws.neededBackup) {
              delete clone.raws.neededBackup;
              clone.walkRules((rule2) => {
                let before = rule2.raws.originalSelector;
                if (!before)
                  return;
                delete rule2.raws.originalSelector;
                if (before === rule2.selector)
                  return;
                let modified = rule2.selector;
                let rebuiltBase = (0, _postcssSelectorParser.default)((selectors) => {
                  selectors.walkClasses((classNode) => {
                    classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;
                  });
                }).processSync(before);
                collectedFormats.push(modified.replace(rebuiltBase, "&"));
                rule2.selector = before;
              });
            }
            clone.nodes[0].raws.tailwind = {
              ...clone.nodes[0].raws.tailwind,
              parentLayer: meta.layer
            };
            var _collectedFormats;
            let withOffset = [
              {
                ...meta,
                sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),
                collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats),
                isArbitraryVariant: isArbitraryValue(variant)
              },
              clone.nodes[0]
            ];
            result.push(withOffset);
          }
        }
        return result;
      }
      return [];
    }
    function parseRules(rule, cache, options = {}) {
      if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {
        return [
          [
            rule
          ],
          options
        ];
      }
      if (Array.isArray(rule)) {
        return parseRules(rule[0], cache, rule[1]);
      }
      if (!cache.has(rule)) {
        cache.set(rule, (0, _parseObjectStyles.default)(rule));
      }
      return [
        cache.get(rule),
        options
      ];
    }
    var IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
    function isValidPropName(name) {
      return IS_VALID_PROPERTY_NAME.test(name);
    }
    function looksLikeUri(declaration) {
      if (!declaration.includes("://")) {
        return false;
      }
      try {
        const url = new URL(declaration);
        return url.scheme !== "" && url.host !== "";
      } catch (err) {
        return false;
      }
    }
    function isParsableNode(node) {
      let isParsable = true;
      node.walkDecls((decl) => {
        if (!isParsableCssValue(decl.name, decl.value)) {
          isParsable = false;
          return false;
        }
      });
      return isParsable;
    }
    function isParsableCssValue(property, value) {
      if (looksLikeUri(`${property}:${value}`)) {
        return false;
      }
      try {
        _postcss.default.parse(`a{${property}:${value}}`).toResult();
        return true;
      } catch (err) {
        return false;
      }
    }
    function extractArbitraryProperty(classCandidate, context) {
      var ref2;
      let [, property, value] = (ref2 = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && ref2 !== void 0 ? ref2 : [];
      if (value === void 0) {
        return null;
      }
      if (!isValidPropName(property)) {
        return null;
      }
      if (!(0, _isValidArbitraryValue.default)(value)) {
        return null;
      }
      let normalized = (0, _dataTypes.normalize)(value);
      if (!isParsableCssValue(property, normalized)) {
        return null;
      }
      let sort = context.offsets.arbitraryProperty();
      return [
        [
          {
            sort,
            layer: "utilities"
          },
          () => ({
            [(0, _nameClass.asClass)(classCandidate)]: {
              [property]: normalized
            }
          })
        ]
      ];
    }
    function* resolveMatchedPlugins(classCandidate, context) {
      if (context.candidateRuleMap.has(classCandidate)) {
        yield [
          context.candidateRuleMap.get(classCandidate),
          "DEFAULT"
        ];
      }
      yield* function* (arbitraryPropertyRule) {
        if (arbitraryPropertyRule !== null) {
          yield [
            arbitraryPropertyRule,
            "DEFAULT"
          ];
        }
      }(extractArbitraryProperty(classCandidate, context));
      let candidatePrefix = classCandidate;
      let negative = false;
      const twConfigPrefix = context.tailwindConfig.prefix;
      const twConfigPrefixLen = twConfigPrefix.length;
      const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);
      if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
        negative = true;
        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
      }
      if (negative && context.candidateRuleMap.has(candidatePrefix)) {
        yield [
          context.candidateRuleMap.get(candidatePrefix),
          "-DEFAULT"
        ];
      }
      for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {
        if (context.candidateRuleMap.has(prefix)) {
          yield [
            context.candidateRuleMap.get(prefix),
            negative ? `-${modifier}` : modifier
          ];
        }
      }
    }
    function splitWithSeparator(input, separator) {
      if (input === _sharedState.NOT_ON_DEMAND) {
        return [
          _sharedState.NOT_ON_DEMAND
        ];
      }
      return (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(input, separator);
    }
    function* recordCandidates(matches, classCandidate) {
      for (const match of matches) {
        var ref2;
        var ref1;
        match[1].raws.tailwind = {
          ...match[1].raws.tailwind,
          classCandidate,
          preserveSource: (ref1 = (ref2 = match[0].options) === null || ref2 === void 0 ? void 0 : ref2.preserveSource) !== null && ref1 !== void 0 ? ref1 : false
        };
        yield match;
      }
    }
    function* resolveMatches(candidate, context, original = candidate) {
      let separator = context.tailwindConfig.separator;
      let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
      let important = false;
      if (classCandidate.startsWith("!")) {
        important = true;
        classCandidate = classCandidate.slice(1);
      }
      if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, "variantGrouping")) {
        if (classCandidate.startsWith("(") && classCandidate.endsWith(")")) {
          let base2 = variants.slice().reverse().join(separator);
          for (let part of (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(classCandidate.slice(1, -1), ",")) {
            yield* resolveMatches(base2 + separator + part, context, original);
          }
        }
      }
      for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {
        let matches = [];
        let typesByMatches = /* @__PURE__ */ new Map();
        let [plugins, modifier] = matchedPlugins;
        let isOnlyPlugin = plugins.length === 1;
        for (let [sort, plugin] of plugins) {
          let matchesPerPlugin = [];
          if (typeof plugin === "function") {
            for (let ruleSet of [].concat(plugin(modifier, {
              isOnlyPlugin
            }))) {
              let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
              for (let rule of rules) {
                matchesPerPlugin.push([
                  {
                    ...sort,
                    options: {
                      ...sort.options,
                      ...options
                    }
                  },
                  rule
                ]);
              }
            }
          } else if (modifier === "DEFAULT" || modifier === "-DEFAULT") {
            let ruleSet1 = plugin;
            let [rules1, options1] = parseRules(ruleSet1, context.postCssNodeCache);
            for (let rule1 of rules1) {
              matchesPerPlugin.push([
                {
                  ...sort,
                  options: {
                    ...sort.options,
                    ...options1
                  }
                },
                rule1
              ]);
            }
          }
          if (matchesPerPlugin.length > 0) {
            var ref2;
            var ref1, _options;
            let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((ref1 = (ref2 = sort.options) === null || ref2 === void 0 ? void 0 : ref2.types) !== null && ref1 !== void 0 ? ref1 : [], modifier, (_options = sort.options) !== null && _options !== void 0 ? _options : {}, context.tailwindConfig)).map(([_, type]) => type);
            if (matchingTypes.length > 0) {
              typesByMatches.set(matchesPerPlugin, matchingTypes);
            }
            matches.push(matchesPerPlugin);
          }
        }
        if (isArbitraryValue(modifier)) {
          if (matches.length > 1) {
            let findFallback = function(matches2) {
              if (matches2.length === 1) {
                return matches2[0];
              }
              return matches2.find((rules) => {
                let matchingTypes = typesByMatches.get(rules);
                return rules.some(([{ options }, rule]) => {
                  if (!isParsableNode(rule)) {
                    return false;
                  }
                  return options.types.some(({ type, preferOnConflict }) => matchingTypes.includes(type) && preferOnConflict);
                });
              });
            };
            let [withAny, withoutAny] = matches.reduce((group, plugin) => {
              let hasAnyType = plugin.some(([{ options }]) => options.types.some(({ type }) => type === "any"));
              if (hasAnyType) {
                group[0].push(plugin);
              } else {
                group[1].push(plugin);
              }
              return group;
            }, [
              [],
              []
            ]);
            var ref22;
            let fallback = (ref22 = findFallback(withoutAny)) !== null && ref22 !== void 0 ? ref22 : findFallback(withAny);
            if (fallback) {
              matches = [
                fallback
              ];
            } else {
              var ref3;
              let typesPerPlugin = matches.map((match) => /* @__PURE__ */ new Set([
                ...(ref3 = typesByMatches.get(match)) !== null && ref3 !== void 0 ? ref3 : []
              ]));
              for (let pluginTypes of typesPerPlugin) {
                for (let type of pluginTypes) {
                  let removeFromOwnGroup = false;
                  for (let otherGroup of typesPerPlugin) {
                    if (pluginTypes === otherGroup)
                      continue;
                    if (otherGroup.has(type)) {
                      otherGroup.delete(type);
                      removeFromOwnGroup = true;
                    }
                  }
                  if (removeFromOwnGroup)
                    pluginTypes.delete(type);
                }
              }
              let messages = [];
              for (let [idx, group] of typesPerPlugin.entries()) {
                for (let type1 of group) {
                  let rules2 = matches[idx].map(([, rule]) => rule).flat().map((rule) => rule.toString().split("\n").slice(1, -1).map((line) => line.trim()).map((x) => `      ${x}`).join("\n")).join("\n\n");
                  messages.push(`  Use \`${candidate.replace("[", `[${type1}:`)}\` for \`${rules2.trim()}\``);
                  break;
                }
              }
              _log.default.warn([
                `The class \`${candidate}\` is ambiguous and matches multiple utilities.`,
                ...messages,
                `If this is content and not a class, replace it with \`${candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
              ]);
              continue;
            }
          }
          matches = matches.map((list) => list.filter((match) => isParsableNode(match[1])));
        }
        matches = matches.flat();
        matches = Array.from(recordCandidates(matches, classCandidate));
        matches = applyPrefix(matches, context);
        if (important) {
          matches = applyImportant(matches, classCandidate);
        }
        for (let variant of variants) {
          matches = applyVariant(variant, matches, context);
        }
        for (let match of matches) {
          match[1].raws.tailwind = {
            ...match[1].raws.tailwind,
            candidate
          };
          if (match[0].collectedFormats) {
            let finalFormat = (0, _formatVariantSelector.formatVariantSelector)("&", ...match[0].collectedFormats);
            let container = _postcss.default.root({
              nodes: [
                match[1].clone()
              ]
            });
            container.walkRules((rule) => {
              var ref4;
              if (inKeyframes(rule))
                return;
              var ref12;
              rule.selector = (0, _formatVariantSelector.finalizeSelector)(finalFormat, {
                selector: rule.selector,
                candidate: original,
                base: candidate.split(new RegExp(`\\${(ref12 = context === null || context === void 0 ? void 0 : (ref4 = context.tailwindConfig) === null || ref4 === void 0 ? void 0 : ref4.separator) !== null && ref12 !== void 0 ? ref12 : ":"}(?![^[]*\\])`)).pop(),
                isArbitraryVariant: match[0].isArbitraryVariant,
                context
              });
            });
            match[1] = container.nodes[0];
          }
          yield match;
        }
      }
    }
    function inKeyframes(rule) {
      return rule.parent && rule.parent.type === "atrule" && rule.parent.name === "keyframes";
    }
    function getImportantStrategy(important) {
      if (important === true) {
        return (rule) => {
          if (inKeyframes(rule)) {
            return;
          }
          rule.walkDecls((d) => {
            if (d.parent.type === "rule" && !inKeyframes(d.parent)) {
              d.important = true;
            }
          });
        };
      }
      if (typeof important === "string") {
        return (rule) => {
          if (inKeyframes(rule)) {
            return;
          }
          rule.selectors = rule.selectors.map((selector) => {
            return `${important} ${selector}`;
          });
        };
      }
    }
    function generateRules(candidates, context) {
      let allRules = [];
      let strategy = getImportantStrategy(context.tailwindConfig.important);
      for (let candidate of candidates) {
        if (context.notClassCache.has(candidate)) {
          continue;
        }
        if (context.candidateRuleCache.has(candidate)) {
          allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
          continue;
        }
        let matches = Array.from(resolveMatches(candidate, context));
        if (matches.length === 0) {
          context.notClassCache.add(candidate);
          continue;
        }
        context.classCache.set(candidate, matches);
        var ref2;
        let rules = (ref2 = context.candidateRuleCache.get(candidate)) !== null && ref2 !== void 0 ? ref2 : /* @__PURE__ */ new Set();
        context.candidateRuleCache.set(candidate, rules);
        for (const match of matches) {
          let [{ sort, options }, rule] = match;
          if (options.respectImportant && strategy) {
            let container = _postcss.default.root({
              nodes: [
                rule.clone()
              ]
            });
            container.walkRules(strategy);
            rule = container.nodes[0];
          }
          let newEntry = [
            sort,
            rule
          ];
          rules.add(newEntry);
          context.ruleCache.add(newEntry);
          allRules.push(newEntry);
        }
      }
      return allRules;
    }
    function isArbitraryValue(input) {
      return input.startsWith("[") && input.endsWith("]");
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/cacheInvalidation.js
var require_cacheInvalidation = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/cacheInvalidation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "hasContentChanged", {
      enumerable: true,
      get: () => hasContentChanged
    });
    var _crypto = /* @__PURE__ */ _interopRequireDefault(require("crypto"));
    var _sharedState = /* @__PURE__ */ _interopRequireWildcard(require_sharedState());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function getHash(str) {
      try {
        return _crypto.default.createHash("md5").update(str, "utf-8").digest("binary");
      } catch (err) {
        return "";
      }
    }
    function hasContentChanged(sourcePath, root) {
      let css = root.toString();
      if (!css.includes("@tailwind")) {
        return false;
      }
      let existingHash = _sharedState.sourceHashMap.get(sourcePath);
      let rootHash = getHash(css);
      let didChange = existingHash !== rootHash;
      _sharedState.sourceHashMap.set(sourcePath, rootHash);
      return didChange;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/bigSign.js
var require_bigSign = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/bigSign.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => bigSign
    });
    function bigSign(bigIntValue) {
      return (bigIntValue > 0n) - (bigIntValue < 0n);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/offsets.js
var require_offsets = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/offsets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Offsets", {
      enumerable: true,
      get: () => Offsets
    });
    var _bigSign = /* @__PURE__ */ _interopRequireDefault(require_bigSign());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Offsets = class {
      constructor() {
        this.offsets = {
          defaults: 0n,
          base: 0n,
          components: 0n,
          utilities: 0n,
          variants: 0n,
          user: 0n
        };
        this.layerPositions = {
          defaults: 0n,
          base: 1n,
          components: 2n,
          utilities: 3n,
          user: 4n,
          variants: 5n
        };
        this.reservedVariantBits = 0n;
        this.variantOffsets = /* @__PURE__ */ new Map();
      }
      create(layer) {
        return {
          layer,
          parentLayer: layer,
          arbitrary: 0n,
          variants: 0n,
          parallelIndex: 0n,
          index: this.offsets[layer]++,
          options: []
        };
      }
      arbitraryProperty() {
        return {
          ...this.create("utilities"),
          arbitrary: 1n
        };
      }
      forVariant(variant, index = 0) {
        let offset2 = this.variantOffsets.get(variant);
        if (offset2 === void 0) {
          throw new Error(`Cannot find offset for unknown variant ${variant}`);
        }
        return {
          ...this.create("variants"),
          variants: offset2 << BigInt(index)
        };
      }
      applyVariantOffset(rule, variant, options) {
        return {
          ...rule,
          layer: "variants",
          parentLayer: rule.layer === "variants" ? rule.parentLayer : rule.layer,
          variants: rule.variants | variant.variants,
          options: options.sort ? [].concat(options, rule.options) : rule.options,
          parallelIndex: max([
            rule.parallelIndex,
            variant.parallelIndex
          ])
        };
      }
      applyParallelOffset(offset2, parallelIndex) {
        return {
          ...offset2,
          parallelIndex: BigInt(parallelIndex)
        };
      }
      recordVariants(variants, getLength) {
        for (let variant of variants) {
          this.recordVariant(variant, getLength(variant));
        }
      }
      recordVariant(variant, fnCount = 1) {
        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
        this.reservedVariantBits += BigInt(fnCount);
        return {
          ...this.create("variants"),
          variants: 1n << this.reservedVariantBits
        };
      }
      compare(a, b) {
        if (a.layer !== b.layer) {
          return this.layerPositions[a.layer] - this.layerPositions[b.layer];
        }
        for (let aOptions of a.options) {
          for (let bOptions of b.options) {
            if (aOptions.id !== bOptions.id)
              continue;
            if (!aOptions.sort || !bOptions.sort)
              continue;
            let result = aOptions.sort({
              value: aOptions.value,
              modifier: aOptions.modifier
            }, {
              value: bOptions.value,
              modifier: bOptions.modifier
            });
            if (result !== 0)
              return result;
          }
        }
        if (a.variants !== b.variants) {
          return a.variants - b.variants;
        }
        if (a.parallelIndex !== b.parallelIndex) {
          return a.parallelIndex - b.parallelIndex;
        }
        if (a.arbitrary !== b.arbitrary) {
          return a.arbitrary - b.arbitrary;
        }
        return a.index - b.index;
      }
      sort(list) {
        return list.sort(([a], [b]) => (0, _bigSign.default)(this.compare(a, b)));
      }
    };
    function max(nums) {
      let max2 = null;
      for (const num of nums) {
        max2 = max2 !== null && max2 !== void 0 ? max2 : num;
        max2 = max2 > num ? max2 : num;
      }
      return max2;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/setupContextUtils.js
var require_setupContextUtils = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/setupContextUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      isValidVariantFormatString: () => isValidVariantFormatString,
      parseVariant: () => parseVariant,
      getFileModifiedMap: () => getFileModifiedMap,
      createContext: () => createContext,
      getContext: () => getContext
    });
    var _fs = /* @__PURE__ */ _interopRequireDefault(require("fs"));
    var _url = /* @__PURE__ */ _interopRequireDefault(require("url"));
    var _postcss = /* @__PURE__ */ _interopRequireDefault(require("postcss"));
    var _dlv = /* @__PURE__ */ _interopRequireDefault((init_dlv_es(), __toCommonJS(dlv_es_exports)));
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _transformThemeValue = /* @__PURE__ */ _interopRequireDefault(require_transformThemeValue());
    var _parseObjectStyles = /* @__PURE__ */ _interopRequireDefault(require_parseObjectStyles());
    var _prefixSelector = /* @__PURE__ */ _interopRequireDefault(require_prefixSelector());
    var _isPlainObject = /* @__PURE__ */ _interopRequireDefault(require_isPlainObject());
    var _escapeClassName = /* @__PURE__ */ _interopRequireDefault(require_escapeClassName());
    var _nameClass = /* @__PURE__ */ _interopRequireWildcard(require_nameClass());
    var _pluginUtils = require_pluginUtils();
    var _corePlugins = require_corePlugins();
    var _sharedState = /* @__PURE__ */ _interopRequireWildcard(require_sharedState());
    var _toPath = require_toPath();
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    var _negateValue = /* @__PURE__ */ _interopRequireDefault(require_negateValue());
    var _isValidArbitraryValue = /* @__PURE__ */ _interopRequireDefault(require_isValidArbitraryValue());
    var _generateRules = require_generateRules();
    var _cacheInvalidationJs = require_cacheInvalidation();
    var _offsetsJs = require_offsets();
    var _featureFlagsJs = require_featureFlags();
    var _formatVariantSelector = require_formatVariantSelector();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var VARIANT_TYPES = {
      AddVariant: Symbol.for("ADD_VARIANT"),
      MatchVariant: Symbol.for("MATCH_VARIANT")
    };
    var VARIANT_INFO = {
      Base: 1 << 0,
      Dynamic: 1 << 1
    };
    function prefix(context, selector) {
      let prefix2 = context.tailwindConfig.prefix;
      return typeof prefix2 === "function" ? prefix2(selector) : prefix2 + selector;
    }
    function normalizeOptionTypes({ type = "any", ...options }) {
      let types2 = [].concat(type);
      return {
        ...options,
        types: types2.map((type2) => {
          if (Array.isArray(type2)) {
            return {
              type: type2[0],
              ...type2[1]
            };
          }
          return {
            type: type2,
            preferOnConflict: false
          };
        })
      };
    }
    function parseVariantFormatString(input) {
      if (input.includes("{")) {
        if (!isBalanced(input))
          throw new Error(`Your { and } are unbalanced.`);
        return input.split(/{(.*)}/gim).flatMap((line) => parseVariantFormatString(line)).filter(Boolean);
      }
      return [
        input.trim()
      ];
    }
    function isBalanced(input) {
      let count = 0;
      for (let char of input) {
        if (char === "{") {
          count++;
        } else if (char === "}") {
          if (--count < 0) {
            return false;
          }
        }
      }
      return count === 0;
    }
    function insertInto(list, value, { before = [] } = {}) {
      before = [].concat(before);
      if (before.length <= 0) {
        list.push(value);
        return;
      }
      let idx = list.length - 1;
      for (let other of before) {
        let iidx = list.indexOf(other);
        if (iidx === -1)
          continue;
        idx = Math.min(idx, iidx);
      }
      list.splice(idx, 0, value);
    }
    function parseStyles(styles) {
      if (!Array.isArray(styles)) {
        return parseStyles([
          styles
        ]);
      }
      return styles.flatMap((style) => {
        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);
        return isNode ? style : (0, _parseObjectStyles.default)(style);
      });
    }
    function getClasses(selector, mutate) {
      let parser = (0, _postcssSelectorParser.default)((selectors) => {
        let allClasses = [];
        if (mutate) {
          mutate(selectors);
        }
        selectors.walkClasses((classNode) => {
          allClasses.push(classNode.value);
        });
        return allClasses;
      });
      return parser.transformSync(selector);
    }
    function extractCandidates(node, state = {
      containsNonOnDemandable: false
    }, depth = 0) {
      let classes = [];
      if (node.type === "rule") {
        let ignoreNot = function(selectors) {
          selectors.walkPseudos((pseudo) => {
            if (pseudo.value === ":not") {
              pseudo.remove();
            }
          });
        };
        for (let selector of node.selectors) {
          let classCandidates = getClasses(selector, ignoreNot);
          if (classCandidates.length === 0) {
            state.containsNonOnDemandable = true;
          }
          for (let classCandidate of classCandidates) {
            classes.push(classCandidate);
          }
        }
      } else if (node.type === "atrule") {
        node.walkRules((rule) => {
          for (let classCandidate of rule.selectors.flatMap((selector) => getClasses(selector))) {
            classes.push(classCandidate);
          }
        });
      }
      if (depth === 0) {
        return [
          state.containsNonOnDemandable || classes.length === 0,
          classes
        ];
      }
      return classes;
    }
    function withIdentifiers(styles) {
      return parseStyles(styles).flatMap((node) => {
        let nodeMap = /* @__PURE__ */ new Map();
        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
        if (containsNonOnDemandableSelectors) {
          candidates.unshift(_sharedState.NOT_ON_DEMAND);
        }
        return candidates.map((c) => {
          if (!nodeMap.has(node)) {
            nodeMap.set(node, node);
          }
          return [
            c,
            nodeMap.get(node)
          ];
        });
      });
    }
    function isValidVariantFormatString(format) {
      return format.startsWith("@") || format.includes("&");
    }
    function parseVariant(variant) {
      variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let fns = parseVariantFormatString(variant).map((str) => {
        if (!str.startsWith("@")) {
          return ({ format }) => format(str);
        }
        let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);
        return ({ wrap }) => wrap(_postcss.default.atRule({
          name,
          params: params.trim()
        }));
      }).reverse();
      return (api) => {
        for (let fn of fns) {
          fn(api);
        }
      };
    }
    function buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets, classList }) {
      function getConfigValue(path3, defaultValue) {
        return path3 ? (0, _dlv.default)(tailwindConfig, path3, defaultValue) : tailwindConfig;
      }
      function applyConfiguredPrefix(selector) {
        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);
      }
      function prefixIdentifier(identifier, options) {
        if (identifier === _sharedState.NOT_ON_DEMAND) {
          return _sharedState.NOT_ON_DEMAND;
        }
        if (!options.respectPrefix) {
          return identifier;
        }
        return context.tailwindConfig.prefix + identifier;
      }
      function resolveThemeValue(path3, defaultValue, opts = {}) {
        const [pathRoot, ...subPaths] = (0, _toPath.toPath)(path3);
        const value = getConfigValue([
          "theme",
          pathRoot,
          ...subPaths
        ], defaultValue);
        return (0, _transformThemeValue.default)(pathRoot)(value, opts);
      }
      const theme = Object.assign((path3, defaultValue = void 0) => resolveThemeValue(path3, defaultValue), {
        withAlpha: (path3, opacityValue) => resolveThemeValue(path3, void 0, {
          opacityValue
        })
      });
      let variantIdentifier = 0;
      let api = {
        postcss: _postcss.default,
        prefix: applyConfiguredPrefix,
        e: _escapeClassName.default,
        config: getConfigValue,
        theme,
        corePlugins: (path3) => {
          if (Array.isArray(tailwindConfig.corePlugins)) {
            return tailwindConfig.corePlugins.includes(path3);
          }
          return getConfigValue([
            "corePlugins",
            path3
          ], true);
        },
        variants: () => {
          return [];
        },
        addBase(base2) {
          for (let [identifier, rule] of withIdentifiers(base2)) {
            let prefixedIdentifier = prefixIdentifier(identifier, {});
            let offset2 = offsets.create("base");
            if (!context.candidateRuleMap.has(prefixedIdentifier)) {
              context.candidateRuleMap.set(prefixedIdentifier, []);
            }
            context.candidateRuleMap.get(prefixedIdentifier).push([
              {
                sort: offset2,
                layer: "base"
              },
              rule
            ]);
          }
        },
        addDefaults(group, declarations) {
          const groups = {
            [`@defaults ${group}`]: declarations
          };
          for (let [identifier, rule] of withIdentifiers(groups)) {
            let prefixedIdentifier = prefixIdentifier(identifier, {});
            if (!context.candidateRuleMap.has(prefixedIdentifier)) {
              context.candidateRuleMap.set(prefixedIdentifier, []);
            }
            context.candidateRuleMap.get(prefixedIdentifier).push([
              {
                sort: offsets.create("defaults"),
                layer: "defaults"
              },
              rule
            ]);
          }
        },
        addComponents(components, options) {
          let defaultOptions2 = {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: false
          };
          options = Object.assign({}, defaultOptions2, Array.isArray(options) ? {} : options);
          for (let [identifier, rule] of withIdentifiers(components)) {
            let prefixedIdentifier = prefixIdentifier(identifier, options);
            classList.add(prefixedIdentifier);
            if (!context.candidateRuleMap.has(prefixedIdentifier)) {
              context.candidateRuleMap.set(prefixedIdentifier, []);
            }
            context.candidateRuleMap.get(prefixedIdentifier).push([
              {
                sort: offsets.create("components"),
                layer: "components",
                options
              },
              rule
            ]);
          }
        },
        addUtilities(utilities, options) {
          let defaultOptions2 = {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: true
          };
          options = Object.assign({}, defaultOptions2, Array.isArray(options) ? {} : options);
          for (let [identifier, rule] of withIdentifiers(utilities)) {
            let prefixedIdentifier = prefixIdentifier(identifier, options);
            classList.add(prefixedIdentifier);
            if (!context.candidateRuleMap.has(prefixedIdentifier)) {
              context.candidateRuleMap.set(prefixedIdentifier, []);
            }
            context.candidateRuleMap.get(prefixedIdentifier).push([
              {
                sort: offsets.create("utilities"),
                layer: "utilities",
                options
              },
              rule
            ]);
          }
        },
        matchUtilities: function(utilities, options) {
          let defaultOptions2 = {
            respectPrefix: true,
            respectImportant: true,
            modifiers: false
          };
          options = normalizeOptionTypes({
            ...defaultOptions2,
            ...options
          });
          let offset2 = offsets.create("utilities");
          for (let identifier in utilities) {
            let wrapped = function(modifier, { isOnlyPlugin }) {
              let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);
              if (value === void 0) {
                return [];
              }
              if (!options.types.some(({ type }) => type === coercedType)) {
                if (isOnlyPlugin) {
                  _log.default.warn([
                    `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                    `You can safely update it to \`${identifier}-${modifier.replace(coercedType + ":", "")}\`.`
                  ]);
                } else {
                  return [];
                }
              }
              if (!(0, _isValidArbitraryValue.default)(value)) {
                return [];
              }
              let extras = {
                get modifier() {
                  if (!options.modifiers) {
                    _log.default.warn(`modifier-used-without-options-for-${identifier}`, [
                      "Your plugin must set `modifiers: true` in its options to support modifiers."
                    ]);
                  }
                  return utilityModifier;
                }
              };
              let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
              let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration) => ({
                [(0, _nameClass.default)(identifier, modifier)]: declaration
              }));
              return ruleSets;
            };
            let prefixedIdentifier = prefixIdentifier(identifier, options);
            let rule = utilities[identifier];
            classList.add([
              prefixedIdentifier,
              options
            ]);
            let withOffsets = [
              {
                sort: offset2,
                layer: "utilities",
                options
              },
              wrapped
            ];
            if (!context.candidateRuleMap.has(prefixedIdentifier)) {
              context.candidateRuleMap.set(prefixedIdentifier, []);
            }
            context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
          }
        },
        matchComponents: function(components, options) {
          let defaultOptions2 = {
            respectPrefix: true,
            respectImportant: false,
            modifiers: false
          };
          options = normalizeOptionTypes({
            ...defaultOptions2,
            ...options
          });
          let offset2 = offsets.create("components");
          for (let identifier in components) {
            let wrapped = function(modifier, { isOnlyPlugin }) {
              let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);
              if (value === void 0) {
                return [];
              }
              if (!options.types.some(({ type }) => type === coercedType)) {
                if (isOnlyPlugin) {
                  _log.default.warn([
                    `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                    `You can safely update it to \`${identifier}-${modifier.replace(coercedType + ":", "")}\`.`
                  ]);
                } else {
                  return [];
                }
              }
              if (!(0, _isValidArbitraryValue.default)(value)) {
                return [];
              }
              let extras = {
                get modifier() {
                  if (!options.modifiers) {
                    _log.default.warn(`modifier-used-without-options-for-${identifier}`, [
                      "Your plugin must set `modifiers: true` in its options to support modifiers."
                    ]);
                  }
                  return utilityModifier;
                }
              };
              let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
              let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration) => ({
                [(0, _nameClass.default)(identifier, modifier)]: declaration
              }));
              return ruleSets;
            };
            let prefixedIdentifier = prefixIdentifier(identifier, options);
            let rule = components[identifier];
            classList.add([
              prefixedIdentifier,
              options
            ]);
            let withOffsets = [
              {
                sort: offset2,
                layer: "components",
                options
              },
              wrapped
            ];
            if (!context.candidateRuleMap.has(prefixedIdentifier)) {
              context.candidateRuleMap.set(prefixedIdentifier, []);
            }
            context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
          }
        },
        addVariant(variantName, variantFunctions, options = {}) {
          variantFunctions = [].concat(variantFunctions).map((variantFunction) => {
            if (typeof variantFunction !== "string") {
              return (api2 = {}) => {
                let { args, modifySelectors, container, separator, wrap, format } = api2;
                let result = variantFunction(Object.assign({
                  modifySelectors,
                  container,
                  separator
                }, options.type === VARIANT_TYPES.MatchVariant && {
                  args,
                  wrap,
                  format
                }));
                if (typeof result === "string" && !isValidVariantFormatString(result)) {
                  throw new Error(`Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                }
                if (Array.isArray(result)) {
                  return result.filter((variant) => typeof variant === "string").map((variant) => parseVariant(variant));
                }
                return result && typeof result === "string" && parseVariant(result)(api2);
              };
            }
            if (!isValidVariantFormatString(variantFunction)) {
              throw new Error(`Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            }
            return parseVariant(variantFunction);
          });
          insertInto(variantList, variantName, options);
          variantMap.set(variantName, variantFunctions);
          context.variantOptions.set(variantName, options);
        },
        matchVariant(variant, variantFn, options) {
          var ref2;
          let id = (ref2 = options === null || options === void 0 ? void 0 : options.id) !== null && ref2 !== void 0 ? ref2 : ++variantIdentifier;
          let isSpecial = variant === "@";
          let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
          var ref1;
          for (let [key, value] of Object.entries((ref1 = options === null || options === void 0 ? void 0 : options.values) !== null && ref1 !== void 0 ? ref1 : {})) {
            if (key === "DEFAULT")
              continue;
            api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args, container }) => {
              return variantFn(value, modifiersEnabled ? {
                modifier: args === null || args === void 0 ? void 0 : args.modifier,
                container
              } : {
                container
              });
            }, {
              ...options,
              value,
              id,
              type: VARIANT_TYPES.MatchVariant,
              variantInfo: VARIANT_INFO.Base
            });
          }
          var ref22;
          let hasDefault = "DEFAULT" in ((ref22 = options === null || options === void 0 ? void 0 : options.values) !== null && ref22 !== void 0 ? ref22 : {});
          api.addVariant(variant, ({ args, container }) => {
            if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {
              return null;
            }
            var ref3;
            return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (ref3 = args === null || args === void 0 ? void 0 : args.value) !== null && ref3 !== void 0 ? ref3 : typeof args === "string" ? args : "", modifiersEnabled ? {
              modifier: args === null || args === void 0 ? void 0 : args.modifier,
              container
            } : {
              container
            });
          }, {
            ...options,
            id,
            type: VARIANT_TYPES.MatchVariant,
            variantInfo: VARIANT_INFO.Dynamic
          });
        }
      };
      return api;
    }
    var fileModifiedMapCache = /* @__PURE__ */ new WeakMap();
    function getFileModifiedMap(context) {
      if (!fileModifiedMapCache.has(context)) {
        fileModifiedMapCache.set(context, /* @__PURE__ */ new Map());
      }
      return fileModifiedMapCache.get(context);
    }
    function trackModified(files, fileModifiedMap) {
      let changed = false;
      for (let file of files) {
        var ref2;
        if (!file)
          continue;
        let parsed = _url.default.parse(file);
        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, "") : parsed.href;
        pathname = parsed.search ? pathname.replace(parsed.search, "") : pathname;
        let newModified = (ref2 = _fs.default.statSync(decodeURIComponent(pathname), {
          throwIfNoEntry: false
        })) === null || ref2 === void 0 ? void 0 : ref2.mtimeMs;
        if (!newModified) {
          continue;
        }
        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {
          changed = true;
        }
        fileModifiedMap.set(file, newModified);
      }
      return changed;
    }
    function extractVariantAtRules(node) {
      node.walkAtRules((atRule) => {
        if ([
          "responsive",
          "variants"
        ].includes(atRule.name)) {
          extractVariantAtRules(atRule);
          atRule.before(atRule.nodes);
          atRule.remove();
        }
      });
    }
    function collectLayerPlugins(root) {
      let layerPlugins = [];
      root.each((node) => {
        if (node.type === "atrule" && [
          "responsive",
          "variants"
        ].includes(node.name)) {
          node.name = "layer";
          node.params = "utilities";
        }
      });
      root.walkAtRules("layer", (layerRule) => {
        extractVariantAtRules(layerRule);
        if (layerRule.params === "base") {
          for (let node of layerRule.nodes) {
            layerPlugins.push(function({ addBase }) {
              addBase(node, {
                respectPrefix: false
              });
            });
          }
          layerRule.remove();
        } else if (layerRule.params === "components") {
          for (let node1 of layerRule.nodes) {
            layerPlugins.push(function({ addComponents }) {
              addComponents(node1, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          }
          layerRule.remove();
        } else if (layerRule.params === "utilities") {
          for (let node2 of layerRule.nodes) {
            layerPlugins.push(function({ addUtilities }) {
              addUtilities(node2, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          }
          layerRule.remove();
        }
      });
      return layerPlugins;
    }
    function resolvePlugins(context, root) {
      let corePluginList = Object.entries({
        ..._corePlugins.variantPlugins,
        ..._corePlugins.corePlugins
      }).map(([name, plugin]) => {
        if (!context.tailwindConfig.corePlugins.includes(name)) {
          return null;
        }
        return plugin;
      }).filter(Boolean);
      let userPlugins = context.tailwindConfig.plugins.map((plugin) => {
        if (plugin.__isOptionsFunction) {
          plugin = plugin();
        }
        return typeof plugin === "function" ? plugin : plugin.handler;
      });
      let layerPlugins = collectLayerPlugins(root);
      let beforeVariants = [
        _corePlugins.variantPlugins["pseudoElementVariants"],
        _corePlugins.variantPlugins["pseudoClassVariants"],
        _corePlugins.variantPlugins["ariaVariants"],
        _corePlugins.variantPlugins["dataVariants"]
      ];
      let afterVariants = [
        _corePlugins.variantPlugins["supportsVariants"],
        _corePlugins.variantPlugins["directionVariants"],
        _corePlugins.variantPlugins["reducedMotionVariants"],
        _corePlugins.variantPlugins["prefersContrastVariants"],
        _corePlugins.variantPlugins["darkVariants"],
        _corePlugins.variantPlugins["printVariant"],
        _corePlugins.variantPlugins["screenVariants"],
        _corePlugins.variantPlugins["orientationVariants"]
      ];
      return [
        ...corePluginList,
        ...beforeVariants,
        ...userPlugins,
        ...afterVariants,
        ...layerPlugins
      ];
    }
    function registerPlugins(plugins, context) {
      let variantList = [];
      let variantMap = /* @__PURE__ */ new Map();
      context.variantMap = variantMap;
      let offsets = new _offsetsJs.Offsets();
      context.offsets = offsets;
      let classList = /* @__PURE__ */ new Set();
      let pluginApi = buildPluginApi(context.tailwindConfig, context, {
        variantList,
        variantMap,
        offsets,
        classList
      });
      for (let plugin of plugins) {
        if (Array.isArray(plugin)) {
          for (let pluginItem of plugin) {
            pluginItem(pluginApi);
          }
        } else {
          plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);
        }
      }
      offsets.recordVariants(variantList, (variant) => variantMap.get(variant).length);
      for (let [variantName, variantFunctions] of variantMap.entries()) {
        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [
          offsets.forVariant(variantName, idx),
          variantFunction
        ]));
      }
      var _safelist;
      let safelist = ((_safelist = context.tailwindConfig.safelist) !== null && _safelist !== void 0 ? _safelist : []).filter(Boolean);
      if (safelist.length > 0) {
        let checks = [];
        for (let value of safelist) {
          if (typeof value === "string") {
            context.changedContent.push({
              content: value,
              extension: "html"
            });
            continue;
          }
          if (value instanceof RegExp) {
            _log.default.warn("root-regex", [
              "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
              "Update your `safelist` configuration to eliminate this warning.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
            continue;
          }
          checks.push(value);
        }
        if (checks.length > 0) {
          let patternMatchingCount = /* @__PURE__ */ new Map();
          let prefixLength = context.tailwindConfig.prefix.length;
          let checkImportantUtils = checks.some((check) => check.pattern.source.includes("!"));
          for (let util of classList) {
            let utils = Array.isArray(util) ? (() => {
              let [utilName, options] = util;
              var ref3;
              let values = Object.keys((ref3 = options === null || options === void 0 ? void 0 : options.values) !== null && ref3 !== void 0 ? ref3 : {});
              let classes = values.map((value) => (0, _nameClass.formatClass)(utilName, value));
              if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {
                classes = [
                  ...classes,
                  ...classes.map((cls) => "-" + cls)
                ];
                classes = [
                  ...classes,
                  ...classes.map((cls) => cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength))
                ];
              }
              if (options.types.some(({ type }) => type === "color")) {
                classes = [
                  ...classes,
                  ...classes.flatMap((cls) => Object.keys(context.tailwindConfig.theme.opacity).map((opacity) => `${cls}/${opacity}`))
                ];
              }
              if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {
                classes = [
                  ...classes,
                  ...classes.map((cls) => "!" + cls)
                ];
              }
              return classes;
            })() : [
              util
            ];
            for (let util1 of utils) {
              for (let { pattern, variants = [] } of checks) {
                pattern.lastIndex = 0;
                if (!patternMatchingCount.has(pattern)) {
                  patternMatchingCount.set(pattern, 0);
                }
                if (!pattern.test(util1))
                  continue;
                patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);
                context.changedContent.push({
                  content: util1,
                  extension: "html"
                });
                for (let variant of variants) {
                  context.changedContent.push({
                    content: variant + context.tailwindConfig.separator + util1,
                    extension: "html"
                  });
                }
              }
            }
          }
          for (let [regex, count] of patternMatchingCount.entries()) {
            if (count !== 0)
              continue;
            _log.default.warn([
              `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
              "Fix this pattern or remove it from your `safelist` configuration.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
          }
        }
      }
      var _darkMode, ref2;
      let darkClassName = (ref2 = [].concat((_darkMode = context.tailwindConfig.darkMode) !== null && _darkMode !== void 0 ? _darkMode : "media")[1]) !== null && ref2 !== void 0 ? ref2 : "dark";
      let parasiteUtilities = [
        prefix(context, darkClassName),
        prefix(context, "group"),
        prefix(context, "peer")
      ];
      context.getClassOrder = function getClassOrder(classes) {
        let sortedClassNames = new Map(classes.map((className) => [
          className,
          null
        ]));
        let rules = (0, _generateRules.generateRules)(new Set(classes), context);
        rules = context.offsets.sort(rules);
        let idx = BigInt(parasiteUtilities.length);
        for (const [, rule] of rules) {
          sortedClassNames.set(rule.raws.tailwind.candidate, idx++);
        }
        return classes.map((className) => {
          var ref3;
          let order = (ref3 = sortedClassNames.get(className)) !== null && ref3 !== void 0 ? ref3 : null;
          let parasiteIndex = parasiteUtilities.indexOf(className);
          if (order === null && parasiteIndex !== -1) {
            order = BigInt(parasiteIndex);
          }
          return [
            className,
            order
          ];
        });
      };
      context.getClassList = function getClassList() {
        let output = [];
        for (let util of classList) {
          if (Array.isArray(util)) {
            let [utilName, options] = util;
            let negativeClasses = [];
            var ref3;
            for (let [key, value] of Object.entries((ref3 = options === null || options === void 0 ? void 0 : options.values) !== null && ref3 !== void 0 ? ref3 : {})) {
              if (value == null) {
                continue;
              }
              output.push((0, _nameClass.formatClass)(utilName, key));
              if ((options === null || options === void 0 ? void 0 : options.supportsNegativeValues) && (0, _negateValue.default)(value)) {
                negativeClasses.push((0, _nameClass.formatClass)(utilName, `-${key}`));
              }
            }
            output.push(...negativeClasses);
          } else {
            output.push(util);
          }
        }
        return output;
      };
      context.getVariants = function getVariants() {
        let result = [];
        for (let [name, options] of context.variantOptions.entries()) {
          if (options.variantInfo === VARIANT_INFO.Base)
            continue;
          var _values;
          result.push({
            name,
            isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
            values: Object.keys((_values = options.values) !== null && _values !== void 0 ? _values : {}),
            hasDash: name !== "@",
            selectors({ modifier, value } = {}) {
              let candidate = "__TAILWIND_PLACEHOLDER__";
              let rule = _postcss.default.rule({
                selector: `.${candidate}`
              });
              let container = _postcss.default.root({
                nodes: [
                  rule.clone()
                ]
              });
              let before = container.toString();
              var ref3;
              let fns = ((ref3 = context.variantMap.get(name)) !== null && ref3 !== void 0 ? ref3 : []).flatMap(([_, fn]) => fn);
              let formatStrings = [];
              for (let fn of fns) {
                var ref1;
                let localFormatStrings = [];
                var ref22;
                let api = {
                  args: {
                    modifier,
                    value: (ref22 = (ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[value]) !== null && ref22 !== void 0 ? ref22 : value
                  },
                  separator: context.tailwindConfig.separator,
                  modifySelectors(modifierFunction) {
                    container.each((rule2) => {
                      if (rule2.type !== "rule") {
                        return;
                      }
                      rule2.selectors = rule2.selectors.map((selector) => {
                        return modifierFunction({
                          get className() {
                            return (0, _generateRules.getClassNameFromSelector)(selector);
                          },
                          selector
                        });
                      });
                    });
                    return container;
                  },
                  format(str) {
                    localFormatStrings.push(str);
                  },
                  wrap(wrapper) {
                    localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
                  },
                  container
                };
                let ruleWithVariant = fn(api);
                if (localFormatStrings.length > 0) {
                  formatStrings.push(localFormatStrings);
                }
                if (Array.isArray(ruleWithVariant)) {
                  for (let variantFunction of ruleWithVariant) {
                    localFormatStrings = [];
                    variantFunction(api);
                    formatStrings.push(localFormatStrings);
                  }
                }
              }
              let manualFormatStrings = [];
              let after = container.toString();
              if (before !== after) {
                container.walkRules((rule2) => {
                  let modified = rule2.selector;
                  let rebuiltBase = (0, _postcssSelectorParser.default)((selectors) => {
                    selectors.walkClasses((classNode) => {
                      classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                    });
                  }).processSync(modified);
                  manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
                });
                container.walkAtRules((atrule) => {
                  manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
                });
              }
              var _values2;
              let result2 = formatStrings.map((formatString) => (0, _formatVariantSelector.finalizeSelector)((0, _formatVariantSelector.formatVariantSelector)("&", ...formatString), {
                selector: `.${candidate}`,
                candidate,
                context,
                isArbitraryVariant: !(value in ((_values2 = options.values) !== null && _values2 !== void 0 ? _values2 : {}))
              }).replace(`.${candidate}`, "&").replace("{ & }", "").trim());
              if (manualFormatStrings.length > 0) {
                result2.push((0, _formatVariantSelector.formatVariantSelector)("&", ...manualFormatStrings));
              }
              return result2;
            }
          });
        }
        return result;
      };
    }
    function markInvalidUtilityCandidate(context, candidate) {
      if (!context.classCache.has(candidate)) {
        return;
      }
      context.notClassCache.add(candidate);
      context.classCache.delete(candidate);
      context.applyClassCache.delete(candidate);
      context.candidateRuleMap.delete(candidate);
      context.candidateRuleCache.delete(candidate);
      context.stylesheetCache = null;
    }
    function markInvalidUtilityNode(context, node) {
      let candidate = node.raws.tailwind.candidate;
      if (!candidate) {
        return;
      }
      for (const entry of context.ruleCache) {
        if (entry[1].raws.tailwind.candidate === candidate) {
          context.ruleCache.delete(entry);
        }
      }
      markInvalidUtilityCandidate(context, candidate);
    }
    function createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {
      var _blocklist;
      let context = {
        disposables: [],
        ruleCache: /* @__PURE__ */ new Set(),
        candidateRuleCache: /* @__PURE__ */ new Map(),
        classCache: /* @__PURE__ */ new Map(),
        applyClassCache: /* @__PURE__ */ new Map(),
        notClassCache: new Set((_blocklist = tailwindConfig.blocklist) !== null && _blocklist !== void 0 ? _blocklist : []),
        postCssNodeCache: /* @__PURE__ */ new Map(),
        candidateRuleMap: /* @__PURE__ */ new Map(),
        tailwindConfig,
        changedContent,
        variantMap: /* @__PURE__ */ new Map(),
        stylesheetCache: null,
        variantOptions: /* @__PURE__ */ new Map(),
        markInvalidUtilityCandidate: (candidate) => markInvalidUtilityCandidate(context, candidate),
        markInvalidUtilityNode: (node) => markInvalidUtilityNode(context, node)
      };
      let resolvedPlugins = resolvePlugins(context, root);
      registerPlugins(resolvedPlugins, context);
      return context;
    }
    var contextMap = _sharedState.contextMap;
    var configContextMap = _sharedState.configContextMap;
    var contextSourcesMap = _sharedState.contextSourcesMap;
    function getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {
      let sourcePath = result.opts.from;
      let isConfigFile = userConfigPath !== null;
      _sharedState.env.DEBUG && console.log("Source path:", sourcePath);
      let existingContext;
      if (isConfigFile && contextMap.has(sourcePath)) {
        existingContext = contextMap.get(sourcePath);
      } else if (configContextMap.has(tailwindConfigHash)) {
        let context = configContextMap.get(tailwindConfigHash);
        contextSourcesMap.get(context).add(sourcePath);
        contextMap.set(sourcePath, context);
        existingContext = context;
      }
      let cssDidChange = (0, _cacheInvalidationJs.hasContentChanged)(sourcePath, root);
      if (existingContext) {
        let contextDependenciesChanged = trackModified([
          ...contextDependencies
        ], getFileModifiedMap(existingContext));
        if (!contextDependenciesChanged && !cssDidChange) {
          return [
            existingContext,
            false
          ];
        }
      }
      if (contextMap.has(sourcePath)) {
        let oldContext = contextMap.get(sourcePath);
        if (contextSourcesMap.has(oldContext)) {
          contextSourcesMap.get(oldContext).delete(sourcePath);
          if (contextSourcesMap.get(oldContext).size === 0) {
            contextSourcesMap.delete(oldContext);
            for (let [tailwindConfigHash1, context1] of configContextMap) {
              if (context1 === oldContext) {
                configContextMap.delete(tailwindConfigHash1);
              }
            }
            for (let disposable of oldContext.disposables.splice(0)) {
              disposable(oldContext);
            }
          }
        }
      }
      _sharedState.env.DEBUG && console.log("Setting up new context...");
      let context2 = createContext(tailwindConfig, [], root);
      Object.assign(context2, {
        userConfigPath
      });
      trackModified([
        ...contextDependencies
      ], getFileModifiedMap(context2));
      configContextMap.set(tailwindConfigHash, context2);
      contextMap.set(sourcePath, context2);
      if (!contextSourcesMap.has(context2)) {
        contextSourcesMap.set(context2, /* @__PURE__ */ new Set());
      }
      contextSourcesMap.get(context2).add(sourcePath);
      return [
        context2,
        true
      ];
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseDependency.js
var require_parseDependency = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseDependency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => parseDependency
    });
    function parseDependency(contentPath) {
      if (contentPath.ignore) {
        return [];
      }
      if (!contentPath.glob) {
        return [
          {
            type: "dependency",
            file: contentPath.base
          }
        ];
      }
      if (process.env.ROLLUP_WATCH === "true") {
        return [
          {
            type: "dependency",
            file: contentPath.base
          }
        ];
      }
      return [
        {
          type: "dir-dependency",
          dir: contentPath.base,
          glob: contentPath.glob
        }
      ];
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/validateConfig.js
var require_validateConfig = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/validateConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "validateConfig", {
      enumerable: true,
      get: () => validateConfig
    });
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function validateConfig(config) {
      if (config.content.files.length === 0) {
        _log.default.warn("content-problems", [
          "The `content` option in your Tailwind CSS configuration is missing or empty.",
          "Configure your content sources or your generated CSS will be missing styles.",
          "https://tailwindcss.com/docs/content-configuration"
        ]);
      }
      return config;
    }
  }
});

// node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js"(exports, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js"(exports, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitWhen = exports.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports.splitWhen = splitWhen;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/errno.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;
    var path3 = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path3.resolve(cwd, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});

// node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js"(exports, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse4 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance2 = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance2();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance2() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance2())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance2();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance2())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance2();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse4;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse4 = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse4(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path3 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path3.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path3 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path3.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance2 = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance2();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance2();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance2())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance2()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance2())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance2();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance2())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance2())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance2();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base2 = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base2 && isGlob === true && lastIndex > 0) {
        base2 = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base2 = "";
        glob = str;
      } else {
        base2 = str;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
        if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base2 && backslashes === true) {
          base2 = utils.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base2,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse4 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance2 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance2();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance2(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse4(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance2();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance2();
          } else {
            value += advance2();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance2();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance2());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance2());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse4.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create2 = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create2(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create2(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse4;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path3 = require("path");
    var scan = require_scan();
    var parse4 = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path3.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse4(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse4.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse4(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    var path3 = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path3.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports.matchAny = matchAny;
  }
});

// node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/string.js
var require_string2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports.isEmpty = isEmpty;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    var array = require_array();
    exports.array = array;
    var errno = require_errno();
    exports.errno = errno;
    var fs = require_fs();
    exports.fs = fs;
    var path3 = require_path();
    exports.path = path3;
    var pattern = require_pattern();
    exports.pattern = pattern;
    var stream = require_stream();
    exports.stream = stream;
    var string = require_string2();
    exports.string = string;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/tasks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    var utils = require_utils3();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore2) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore2);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base2 = utils.pattern.getBaseDirectory(pattern);
        if (base2 in collection) {
          collection[base2].push(pattern);
        } else {
          collection[base2] = [pattern];
        }
        return collection;
      }, group);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base2) => {
        return convertPatternGroupToTask(base2, positive[base2], negative, dynamic);
      });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base2, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base: base2,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/patterns.js
var require_patterns = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/patterns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeDuplicateSlashes = exports.transform = void 0;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function transform(patterns) {
      return patterns.map((pattern) => removeDuplicateSlashes(pattern));
    }
    exports.transform = transform;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path3, settings, callback) {
      settings.fs.lstat(path3, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path3, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path3, settings) {
      const lstat = settings.fs.lstatSync(path3);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path3);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports.read = read;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async3();
    var sync = require_sync3();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat(path3, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path3, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path3, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat;
    function statSync(path3, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path3, settings);
    }
    exports.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js"(exports, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js"(exports, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs = require_fs3();
    exports.fs = fs;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path3 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path3, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path: path3,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path3 = require("path");
    var fsStat = require_out();
    var fs = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path3.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async4();
    var sync = require_sync4();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path3, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path3, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path3, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path3, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path3, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js"(exports, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current2 = head;
        if (current2.next) {
          head = current2.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current2.next = null;
        return current2;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// node_modules/.pnpm/fastq@1.15.0/node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/.pnpm/fastq@1.15.0/node_modules/fastq/queue.js"(exports, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = true;
      }
      function length() {
        var current2 = queueHead;
        var counter = 0;
        while (current2) {
          current2 = current2.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current2 = queueHead;
        var tasks = [];
        while (current2) {
          tasks.push(current2.value);
          current2 = current2.next;
        }
        return tasks;
      }
      function resume() {
        if (!self.paused)
          return;
        self.paused = false;
        for (var i = 0; i < self.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push(value, done) {
        var current2 = cache.get();
        current2.context = context;
        current2.release = release;
        current2.value = value;
        current2.callback = done || noop;
        current2.errorHandler = errorHandler;
        if (_running === self.concurrency || self.paused) {
          if (queueTail) {
            queueTail.next = current2;
            queueTail = current2;
          } else {
            queueHead = current2;
            queueTail = current2;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current2.value, current2.worked);
        }
      }
      function unshift(value, done) {
        var current2 = cache.get();
        current2.context = context;
        current2.release = release;
        current2.value = value;
        current2.callback = done || noop;
        if (_running === self.concurrency || self.paused) {
          if (queueHead) {
            current2.next = queueHead;
            queueHead = current2;
          } else {
            queueHead = current2;
            queueTail = current2;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current2.value, current2.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self.drain();
        self.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self = this;
      this.worked = function worked(err, result) {
        var callback = self.callback;
        var errorHandler = self.errorHandler;
        var val = self.value;
        self.value = null;
        self.callback = noop;
        if (self.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self.context, err, result);
        self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base2) {
        const queueItem = { directory, base: base2 };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base2) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base2 !== void 0) {
          entry.path = common.joinPathSegments(base2, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async5();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async5();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base2) {
        this._queue.add({ directory, base: base2 });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base2) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base2);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base2) {
        const fullpath = entry.path;
        if (base2 !== void 0) {
          entry.path = common.joinPathSegments(base2, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path3 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path3.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async6();
    var stream_1 = require_stream2();
    var sync_1 = require_sync6();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path3 = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path3.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports.default = Reader;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports.default = ReaderStream;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/async.js
var require_async7 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            if (error === null) {
              resolve(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve(entries));
        });
      }
    };
    exports.default = ReaderAsync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports.default = Matcher;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/partial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports.default = PartialMatcher;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/deep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports.default = DeepFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe, isDirectory) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports.default = EntryFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports.default = ErrorFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/transformers/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports.default = EntryTransformer;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path3 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path3.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports.default = Provider;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/async.js
var require_async8 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async7();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderAsync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderStream;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/sync.js
var require_sync7 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports.default = ReaderSync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/sync.js
var require_sync8 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync7();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderSync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      lstatSync: fs.lstatSync,
      stat: fs.stat,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/index.js"(exports, module2) {
    "use strict";
    var taskManager = require_tasks();
    var patternManager = require_patterns();
    var async_1 = require_async8();
    var stream_1 = require_stream4();
    var sync_1 = require_sync8();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = patternManager.transform([].concat(source));
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js"(exports, module2) {
    module2.exports = function(path3, stripTrailing) {
      if (typeof path3 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path3 === "\\" || path3 === "/")
        return "/";
      var len = path3.length;
      if (len <= 1)
        return path3;
      var prefix = "";
      if (len > 4 && path3[3] === "\\") {
        var ch = path3[2];
        if ((ch === "?" || ch === ".") && path3.slice(0, 2) === "\\\\") {
          path3 = path3.slice(2);
          prefix = "//";
        }
      }
      var segs = path3.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/.pnpm/glob-parent@6.0.2/node_modules/glob-parent/index.js
var require_glob_parent2 = __commonJS({
  "node_modules/.pnpm/glob-parent@6.0.2/node_modules/glob-parent/index.js"(exports, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var escaped = /\\([!*?|[\](){}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (isEnclosure(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlobby(str));
      return str.replace(escaped, "$1");
    };
    function isEnclosure(str) {
      var lastChar = str.slice(-1);
      var enclosureStart;
      switch (lastChar) {
        case "}":
          enclosureStart = "{";
          break;
        case "]":
          enclosureStart = "[";
          break;
        default:
          return false;
      }
      var foundIndex = str.indexOf(enclosureStart);
      if (foundIndex < 0) {
        return false;
      }
      return str.slice(foundIndex + 1, -1).includes(slash);
    }
    function isGlobby(str) {
      if (/\([^()]+$/.test(str)) {
        return true;
      }
      if (str[0] === "{" || str[0] === "[") {
        return true;
      }
      if (/[^\\][{[]/.test(str)) {
        return true;
      }
      return isGlob(str);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseGlob.js
var require_parseGlob = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/parseGlob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parseGlob", {
      enumerable: true,
      get: () => parseGlob
    });
    var _globParent = /* @__PURE__ */ _interopRequireDefault(require_glob_parent2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function parseGlob(pattern) {
      let glob = pattern;
      let base2 = (0, _globParent.default)(pattern);
      if (base2 !== ".") {
        glob = pattern.substr(base2.length);
        if (glob.charAt(0) === "/") {
          glob = glob.substr(1);
        }
      }
      if (glob.substr(0, 2) === "./") {
        glob = glob.substr(2);
      }
      if (glob.charAt(0) === "/") {
        glob = glob.substr(1);
      }
      return {
        base: base2,
        glob
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/content.js
var require_content = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/content.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      parseCandidateFiles: () => parseCandidateFiles,
      resolvedChangedContent: () => resolvedChangedContent
    });
    var _fs = /* @__PURE__ */ _interopRequireDefault(require("fs"));
    var _path = /* @__PURE__ */ _interopRequireDefault(require("path"));
    var _isGlob = /* @__PURE__ */ _interopRequireDefault(require_is_glob());
    var _fastGlob = /* @__PURE__ */ _interopRequireDefault(require_out4());
    var _normalizePath = /* @__PURE__ */ _interopRequireDefault(require_normalize_path());
    var _parseGlob = require_parseGlob();
    var _sharedState = require_sharedState();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function parseCandidateFiles(context, tailwindConfig) {
      let files = tailwindConfig.content.files;
      files = files.filter((filePath) => typeof filePath === "string");
      files = files.map(_normalizePath.default);
      let tasks = _fastGlob.default.generateTasks(files);
      let included = [];
      let excluded = [];
      for (const task of tasks) {
        included.push(...task.positive.map((filePath) => parseFilePath(filePath, false)));
        excluded.push(...task.negative.map((filePath) => parseFilePath(filePath, true)));
      }
      let paths = [
        ...included,
        ...excluded
      ];
      paths = resolveRelativePaths(context, paths);
      paths = paths.flatMap(resolvePathSymlinks);
      paths = paths.map(resolveGlobPattern);
      return paths;
    }
    function parseFilePath(filePath, ignore2) {
      let contentPath = {
        original: filePath,
        base: filePath,
        ignore: ignore2,
        pattern: filePath,
        glob: null
      };
      if ((0, _isGlob.default)(filePath)) {
        Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));
      }
      return contentPath;
    }
    function resolveGlobPattern(contentPath) {
      let base2 = (0, _normalizePath.default)(contentPath.base);
      base2 = _fastGlob.default.escapePath(base2);
      contentPath.pattern = contentPath.glob ? `${base2}/${contentPath.glob}` : base2;
      contentPath.pattern = contentPath.ignore ? `!${contentPath.pattern}` : contentPath.pattern;
      return contentPath;
    }
    function resolveRelativePaths(context, contentPaths) {
      let resolveFrom = [];
      if (context.userConfigPath && context.tailwindConfig.content.relative) {
        resolveFrom = [
          _path.default.dirname(context.userConfigPath)
        ];
      }
      return contentPaths.map((contentPath) => {
        contentPath.base = _path.default.resolve(...resolveFrom, contentPath.base);
        return contentPath;
      });
    }
    function resolvePathSymlinks(contentPath) {
      let paths = [
        contentPath
      ];
      try {
        let resolvedPath = _fs.default.realpathSync(contentPath.base);
        if (resolvedPath !== contentPath.base) {
          paths.push({
            ...contentPath,
            base: resolvedPath
          });
        }
      } catch {
      }
      return paths;
    }
    function resolvedChangedContent(context, candidateFiles, fileModifiedMap) {
      let changedContent = context.tailwindConfig.content.files.filter((item) => typeof item.raw === "string").map(({ raw, extension = "html" }) => ({
        content: raw,
        extension
      }));
      for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)) {
        let content = _fs.default.readFileSync(changedFile, "utf8");
        let extension = _path.default.extname(changedFile).slice(1);
        changedContent.push({
          content,
          extension
        });
      }
      return changedContent;
    }
    function resolveChangedFiles(candidateFiles, fileModifiedMap) {
      let paths = candidateFiles.map((contentPath) => contentPath.pattern);
      let changedFiles = /* @__PURE__ */ new Set();
      _sharedState.env.DEBUG && console.time("Finding changed files");
      let files = _fastGlob.default.sync(paths, {
        absolute: true
      });
      for (let file of files) {
        let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;
        let modified = _fs.default.statSync(file).mtimeMs;
        if (modified >= prevModified) {
          changedFiles.add(file);
          fileModifiedMap.set(file, modified);
        }
      }
      _sharedState.env.DEBUG && console.timeEnd("Finding changed files");
      return changedFiles;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/setupTrackingContext.js
var require_setupTrackingContext = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/setupTrackingContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(
      exports,
      "default",
      {
        enumerable: true,
        get: () => setupTrackingContext
      }
    );
    var _fs = /* @__PURE__ */ _interopRequireDefault(require("fs"));
    var _quickLru = /* @__PURE__ */ _interopRequireDefault(require_quick_lru());
    var _hashConfig = /* @__PURE__ */ _interopRequireDefault(require_hashConfig());
    var _getModuleDependencies = /* @__PURE__ */ _interopRequireDefault(require_getModuleDependencies());
    var _resolveConfig = /* @__PURE__ */ _interopRequireDefault(require_resolve_config());
    var _resolveConfigPath = /* @__PURE__ */ _interopRequireDefault(require_resolveConfigPath());
    var _setupContextUtils = require_setupContextUtils();
    var _parseDependency = /* @__PURE__ */ _interopRequireDefault(require_parseDependency());
    var _validateConfigJs = require_validateConfig();
    var _contentJs = require_content();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var configPathCache = new _quickLru.default({
      maxSize: 100
    });
    var candidateFilesCache = /* @__PURE__ */ new WeakMap();
    function getCandidateFiles(context, tailwindConfig) {
      if (candidateFilesCache.has(context)) {
        return candidateFilesCache.get(context);
      }
      let candidateFiles = (0, _contentJs.parseCandidateFiles)(context, tailwindConfig);
      return candidateFilesCache.set(context, candidateFiles).get(context);
    }
    function getTailwindConfig(configOrPath) {
      let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);
      if (userConfigPath !== null) {
        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];
        let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map((dep) => dep.file);
        let modified = false;
        let newModified = /* @__PURE__ */ new Map();
        for (let file of newDeps) {
          let time = _fs.default.statSync(file).mtimeMs;
          newModified.set(file, time);
          if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {
            modified = true;
          }
        }
        if (!modified) {
          return [
            prevConfig,
            userConfigPath,
            prevConfigHash,
            prevDeps
          ];
        }
        for (let file1 of newDeps) {
          delete require.cache[file1];
        }
        let newConfig = (0, _resolveConfig.default)(require(userConfigPath));
        newConfig = (0, _validateConfigJs.validateConfig)(newConfig);
        let newHash = (0, _hashConfig.default)(newConfig);
        configPathCache.set(userConfigPath, [
          newConfig,
          newHash,
          newDeps,
          newModified
        ]);
        return [
          newConfig,
          userConfigPath,
          newHash,
          newDeps
        ];
      }
      let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === void 0 ? configOrPath : configOrPath.config);
      newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);
      return [
        newConfig1,
        null,
        (0, _hashConfig.default)(newConfig1),
        []
      ];
    }
    function setupTrackingContext(configOrPath) {
      return ({ tailwindDirectives, registerDependency }) => {
        return (root, result) => {
          let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);
          let contextDependencies = new Set(configDependencies);
          if (tailwindDirectives.size > 0) {
            contextDependencies.add(result.opts.from);
            for (let message of result.messages) {
              if (message.type === "dependency") {
                contextDependencies.add(message.file);
              }
            }
          }
          let [context] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);
          let candidateFiles = getCandidateFiles(context, tailwindConfig);
          if (tailwindDirectives.size > 0) {
            let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);
            for (let contentPath of candidateFiles) {
              for (let dependency of (0, _parseDependency.default)(contentPath)) {
                registerDependency(dependency);
              }
            }
            for (let changedContent of (0, _contentJs.resolvedChangedContent)(context, candidateFiles, fileModifiedMap)) {
              context.changedContent.push(changedContent);
            }
          }
          for (let file of configDependencies) {
            registerDependency({
              type: "dependency",
              file
            });
          }
          return context;
        };
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/normalizeTailwindDirectives.js
var require_normalizeTailwindDirectives = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/normalizeTailwindDirectives.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => normalizeTailwindDirectives
    });
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function normalizeTailwindDirectives(root) {
      let tailwindDirectives = /* @__PURE__ */ new Set();
      let layerDirectives = /* @__PURE__ */ new Set();
      let applyDirectives = /* @__PURE__ */ new Set();
      root.walkAtRules((atRule) => {
        if (atRule.name === "apply") {
          applyDirectives.add(atRule);
        }
        if (atRule.name === "import") {
          if (atRule.params === '"tailwindcss/base"' || atRule.params === "'tailwindcss/base'") {
            atRule.name = "tailwind";
            atRule.params = "base";
          } else if (atRule.params === '"tailwindcss/components"' || atRule.params === "'tailwindcss/components'") {
            atRule.name = "tailwind";
            atRule.params = "components";
          } else if (atRule.params === '"tailwindcss/utilities"' || atRule.params === "'tailwindcss/utilities'") {
            atRule.name = "tailwind";
            atRule.params = "utilities";
          } else if (atRule.params === '"tailwindcss/screens"' || atRule.params === "'tailwindcss/screens'" || atRule.params === '"tailwindcss/variants"' || atRule.params === "'tailwindcss/variants'") {
            atRule.name = "tailwind";
            atRule.params = "variants";
          }
        }
        if (atRule.name === "tailwind") {
          if (atRule.params === "screens") {
            atRule.params = "variants";
          }
          tailwindDirectives.add(atRule.params);
        }
        if ([
          "layer",
          "responsive",
          "variants"
        ].includes(atRule.name)) {
          if ([
            "responsive",
            "variants"
          ].includes(atRule.name)) {
            _log.default.warn(`${atRule.name}-at-rule-deprecated`, [
              `The \`@${atRule.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
              `Use \`@layer utilities\` or \`@layer components\` instead.`,
              "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
            ]);
          }
          layerDirectives.add(atRule);
        }
      });
      if (!tailwindDirectives.has("base") || !tailwindDirectives.has("components") || !tailwindDirectives.has("utilities")) {
        for (let rule of layerDirectives) {
          if (rule.name === "layer" && [
            "base",
            "components",
            "utilities"
          ].includes(rule.params)) {
            if (!tailwindDirectives.has(rule.params)) {
              throw rule.error(`\`@layer ${rule.params}\` is used but no matching \`@tailwind ${rule.params}\` directive is present.`);
            }
          } else if (rule.name === "responsive") {
            if (!tailwindDirectives.has("utilities")) {
              throw rule.error("`@responsive` is used but `@tailwind utilities` is missing.");
            }
          } else if (rule.name === "variants") {
            if (!tailwindDirectives.has("utilities")) {
              throw rule.error("`@variants` is used but `@tailwind utilities` is missing.");
            }
          }
        }
      }
      return {
        tailwindDirectives,
        applyDirectives
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/cloneNodes.js
var require_cloneNodes = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/util/cloneNodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => cloneNodes
    });
    function cloneNodes(nodes, source = void 0, raws = void 0) {
      return nodes.map((node) => {
        var ref2;
        let cloned = node.clone();
        let shouldOverwriteSource = ((ref2 = node.raws.tailwind) === null || ref2 === void 0 ? void 0 : ref2.preserveSource) !== true || !cloned.source;
        if (source !== void 0 && shouldOverwriteSource) {
          cloned.source = source;
          if ("walk" in cloned) {
            cloned.walk((child) => {
              child.source = source;
            });
          }
        }
        if (raws !== void 0) {
          cloned.raws.tailwind = {
            ...cloned.raws.tailwind,
            ...raws
          };
        }
        return cloned;
      });
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      pattern: () => pattern,
      withoutCapturing: () => withoutCapturing,
      any: () => any,
      optional: () => optional,
      zeroOrMore: () => zeroOrMore,
      nestedBrackets: () => nestedBrackets,
      escape: () => escape
    });
    var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
    var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
    function toSource(source) {
      source = Array.isArray(source) ? source : [
        source
      ];
      source = source.map((item) => item instanceof RegExp ? item.source : item);
      return source.join("");
    }
    function pattern(source) {
      return new RegExp(toSource(source), "g");
    }
    function withoutCapturing(source) {
      return new RegExp(`(?:${toSource(source)})`, "g");
    }
    function any(sources) {
      return `(?:${sources.map(toSource).join("|")})`;
    }
    function optional(source) {
      return `(?:${toSource(source)})?`;
    }
    function zeroOrMore(source) {
      return `(?:${toSource(source)})*`;
    }
    function nestedBrackets(open, close, depth = 1) {
      return withoutCapturing([
        escape(open),
        /[^\s]*/,
        depth === 1 ? `[^${escape(open)}${escape(close)}s]*` : any([
          `[^${escape(open)}${escape(close)}s]*`,
          nestedBrackets(open, close, depth - 1)
        ]),
        /[^\s]*/,
        escape(close)
      ]);
    }
    function escape(string) {
      return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/defaultExtractor.js
var require_defaultExtractor = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/defaultExtractor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "defaultExtractor", {
      enumerable: true,
      get: () => defaultExtractor
    });
    var _featureFlags = require_featureFlags();
    var _regex = /* @__PURE__ */ _interopRequireWildcard(require_regex());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function defaultExtractor(context) {
      let patterns = Array.from(buildRegExps(context));
      return (content) => {
        let results = [];
        for (let pattern of patterns) {
          var ref2;
          results = [
            ...results,
            ...(ref2 = content.match(pattern)) !== null && ref2 !== void 0 ? ref2 : []
          ];
        }
        return results.filter((v) => v !== void 0).map(clipAtBalancedParens);
      };
    }
    function* buildRegExps(context) {
      let separator = context.tailwindConfig.separator;
      let variantGroupingEnabled = (0, _featureFlags.flagEnabled)(context.tailwindConfig, "variantGrouping");
      let prefix = context.tailwindConfig.prefix !== "" ? _regex.optional(_regex.pattern([
        /-?/,
        _regex.escape(context.tailwindConfig.prefix)
      ])) : "";
      let utility = _regex.any([
        /\[[^\s:'"`]+:[^\s]+\]/,
        _regex.pattern([
          /-?(?:\w+)/,
          _regex.optional(_regex.any([
            _regex.pattern([
              /-(?:\w+-)*\[[^\s:]+\]/,
              /(?![{([]])/,
              /(?:\/[^\s'"`\\><$]*)?/
            ]),
            _regex.pattern([
              /-(?:\w+-)*\[[^\s]+\]/,
              /(?![{([]])/,
              /(?:\/[^\s'"`\\$]*)?/
            ]),
            /[-\/][^\s'"`\\$={><]*/
          ]))
        ])
      ]);
      let variantPatterns = [
        _regex.any([
          _regex.pattern([
            /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
            separator
          ]),
          _regex.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
            separator
          ]),
          _regex.pattern([
            /[^\s"'`\[\\]+/,
            separator
          ])
        ]),
        _regex.any([
          _regex.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
            separator
          ]),
          _regex.pattern([
            /[^\s`\[\\]+/,
            separator
          ])
        ])
      ];
      for (const variantPattern of variantPatterns) {
        yield _regex.pattern([
          "((?=((",
          variantPattern,
          ")+))\\2)?",
          /!?/,
          prefix,
          variantGroupingEnabled ? _regex.any([
            _regex.pattern([
              /\(/,
              utility,
              _regex.zeroOrMore([
                /,/,
                utility
              ]),
              /\)/
            ]),
            utility
          ]) : utility
        ]);
      }
      yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
    }
    var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
    var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
    function clipAtBalancedParens(input) {
      if (!input.includes("-[")) {
        return input;
      }
      let depth = 0;
      let openStringTypes = [];
      let matches = input.matchAll(SPECIALS);
      matches = Array.from(matches).flatMap((match) => {
        const [, ...groups] = match;
        return groups.map((group, idx) => Object.assign([], match, {
          index: match.index + idx,
          0: group
        }));
      });
      for (let match of matches) {
        let char = match[0];
        let inStringType = openStringTypes[openStringTypes.length - 1];
        if (char === inStringType) {
          openStringTypes.pop();
        } else if (char === "'" || char === '"' || char === "`") {
          openStringTypes.push(char);
        }
        if (inStringType) {
          continue;
        } else if (char === "[") {
          depth++;
          continue;
        } else if (char === "]") {
          depth--;
          continue;
        }
        if (depth < 0) {
          return input.substring(0, match.index);
        }
        if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {
          return input.substring(0, match.index);
        }
      }
      return input;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js
var require_expandTailwindAtRules = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => expandTailwindAtRules
    });
    var _quickLru = /* @__PURE__ */ _interopRequireDefault(require_quick_lru());
    var _sharedState = /* @__PURE__ */ _interopRequireWildcard(require_sharedState());
    var _generateRules = require_generateRules();
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    var _cloneNodes = /* @__PURE__ */ _interopRequireDefault(require_cloneNodes());
    var _defaultExtractor = require_defaultExtractor();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var env = _sharedState.env;
    var builtInExtractors = {
      DEFAULT: _defaultExtractor.defaultExtractor
    };
    var builtInTransformers = {
      DEFAULT: (content) => content,
      svelte: (content) => content.replace(/(?:^|\s)class:/g, " ")
    };
    function getExtractor(context, fileExtension) {
      let extractors = context.tailwindConfig.content.extract;
      return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
    }
    function getTransformer(tailwindConfig, fileExtension) {
      let transformers = tailwindConfig.content.transform;
      return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
    }
    var extractorCache = /* @__PURE__ */ new WeakMap();
    function getClassCandidates(content, extractor, candidates, seen) {
      if (!extractorCache.has(extractor)) {
        extractorCache.set(extractor, new _quickLru.default({
          maxSize: 25e3
        }));
      }
      for (let line of content.split("\n")) {
        line = line.trim();
        if (seen.has(line)) {
          continue;
        }
        seen.add(line);
        if (extractorCache.get(extractor).has(line)) {
          for (let match of extractorCache.get(extractor).get(line)) {
            candidates.add(match);
          }
        } else {
          let extractorMatches = extractor(line).filter((s) => s !== "!*");
          let lineMatchesSet = new Set(extractorMatches);
          for (let match1 of lineMatchesSet) {
            candidates.add(match1);
          }
          extractorCache.get(extractor).set(line, lineMatchesSet);
        }
      }
    }
    function buildStylesheet(rules, context) {
      let sortedRules = context.offsets.sort(rules);
      let returnValue = {
        base: /* @__PURE__ */ new Set(),
        defaults: /* @__PURE__ */ new Set(),
        components: /* @__PURE__ */ new Set(),
        utilities: /* @__PURE__ */ new Set(),
        variants: /* @__PURE__ */ new Set()
      };
      for (let [sort, rule] of sortedRules) {
        returnValue[sort.layer].add(rule);
      }
      return returnValue;
    }
    function expandTailwindAtRules(context) {
      return (root) => {
        let layerNodes = {
          base: null,
          components: null,
          utilities: null,
          variants: null
        };
        root.walkAtRules((rule) => {
          if (rule.name === "tailwind") {
            if (Object.keys(layerNodes).includes(rule.params)) {
              layerNodes[rule.params] = rule;
            }
          }
        });
        if (Object.values(layerNodes).every((n) => n === null)) {
          return root;
        }
        let candidates = /* @__PURE__ */ new Set([
          _sharedState.NOT_ON_DEMAND
        ]);
        let seen = /* @__PURE__ */ new Set();
        env.DEBUG && console.time("Reading changed files");
        for (let { content, extension } of context.changedContent) {
          let transformer = getTransformer(context.tailwindConfig, extension);
          let extractor = getExtractor(context, extension);
          getClassCandidates(transformer(content), extractor, candidates, seen);
        }
        env.DEBUG && console.timeEnd("Reading changed files");
        let classCacheCount = context.classCache.size;
        env.DEBUG && console.time("Generate rules");
        (0, _generateRules.generateRules)(candidates, context);
        env.DEBUG && console.timeEnd("Generate rules");
        env.DEBUG && console.time("Build stylesheet");
        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
          context.stylesheetCache = buildStylesheet([
            ...context.ruleCache
          ], context);
        }
        env.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: defaultNodes, base: baseNodes, components: componentNodes, utilities: utilityNodes, variants: screenNodes } = context.stylesheetCache;
        if (layerNodes.base) {
          layerNodes.base.before((0, _cloneNodes.default)([
            ...baseNodes,
            ...defaultNodes
          ], layerNodes.base.source, {
            layer: "base"
          }));
          layerNodes.base.remove();
        }
        if (layerNodes.components) {
          layerNodes.components.before((0, _cloneNodes.default)([
            ...componentNodes
          ], layerNodes.components.source, {
            layer: "components"
          }));
          layerNodes.components.remove();
        }
        if (layerNodes.utilities) {
          layerNodes.utilities.before((0, _cloneNodes.default)([
            ...utilityNodes
          ], layerNodes.utilities.source, {
            layer: "utilities"
          }));
          layerNodes.utilities.remove();
        }
        const variantNodes = Array.from(screenNodes).filter((node) => {
          var ref2;
          const parentLayer = (ref2 = node.raws.tailwind) === null || ref2 === void 0 ? void 0 : ref2.parentLayer;
          if (parentLayer === "components") {
            return layerNodes.components !== null;
          }
          if (parentLayer === "utilities") {
            return layerNodes.utilities !== null;
          }
          return true;
        });
        if (layerNodes.variants) {
          layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {
            layer: "variants"
          }));
          layerNodes.variants.remove();
        } else if (variantNodes.length > 0) {
          root.append((0, _cloneNodes.default)(variantNodes, root.source, {
            layer: "variants"
          }));
        }
        const hasUtilityVariants = variantNodes.some((node) => {
          var ref2;
          return ((ref2 = node.raws.tailwind) === null || ref2 === void 0 ? void 0 : ref2.parentLayer) === "utilities";
        });
        if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
          _log.default.warn("content-problems", [
            "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
            "https://tailwindcss.com/docs/content-configuration"
          ]);
        }
        if (env.DEBUG) {
          console.log("Potential classes: ", candidates.size);
          console.log("Active contexts: ", _sharedState.contextSourcesMap.size);
        }
        context.changedContent = [];
        root.walkAtRules("layer", (rule) => {
          if (Object.keys(layerNodes).includes(rule.params)) {
            rule.remove();
          }
        });
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/expandApplyAtRules.js
var require_expandApplyAtRules = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/expandApplyAtRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => expandApplyAtRules
    });
    var _postcss = /* @__PURE__ */ _interopRequireDefault(require("postcss"));
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _generateRules = require_generateRules();
    var _escapeClassName = /* @__PURE__ */ _interopRequireDefault(require_escapeClassName());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function extractClasses(node) {
      let groups = /* @__PURE__ */ new Map();
      let container = _postcss.default.root({
        nodes: [
          node.clone()
        ]
      });
      container.walkRules((rule) => {
        (0, _postcssSelectorParser.default)((selectors) => {
          selectors.walkClasses((classSelector) => {
            let parentSelector = classSelector.parent.toString();
            let classes2 = groups.get(parentSelector);
            if (!classes2) {
              groups.set(parentSelector, classes2 = /* @__PURE__ */ new Set());
            }
            classes2.add(classSelector.value);
          });
        }).processSync(rule.selector);
      });
      let normalizedGroups = Array.from(groups.values(), (classes2) => Array.from(classes2));
      let classes = normalizedGroups.flat();
      return Object.assign(classes, {
        groups: normalizedGroups
      });
    }
    var selectorExtractor = (0, _postcssSelectorParser.default)();
    function extractSelectors(ruleSelectors) {
      return selectorExtractor.astSync(ruleSelectors);
    }
    function extractBaseCandidates(candidates, separator) {
      let baseClasses = /* @__PURE__ */ new Set();
      for (let candidate of candidates) {
        baseClasses.add(candidate.split(separator).pop());
      }
      return Array.from(baseClasses);
    }
    function prefix(context, selector) {
      let prefix2 = context.tailwindConfig.prefix;
      return typeof prefix2 === "function" ? prefix2(selector) : prefix2 + selector;
    }
    function* pathToRoot(node) {
      yield node;
      while (node.parent) {
        yield node.parent;
        node = node.parent;
      }
    }
    function shallowClone(node, overrides = {}) {
      let children = node.nodes;
      node.nodes = [];
      let tmp = node.clone(overrides);
      node.nodes = children;
      return tmp;
    }
    function nestedClone(node) {
      for (let parent of pathToRoot(node)) {
        if (node === parent) {
          continue;
        }
        if (parent.type === "root") {
          break;
        }
        node = shallowClone(parent, {
          nodes: [
            node
          ]
        });
      }
      return node;
    }
    function buildLocalApplyCache(root, context) {
      let cache = /* @__PURE__ */ new Map();
      root.walkRules((rule) => {
        for (let node of pathToRoot(rule)) {
          var ref2;
          if (((ref2 = node.raws.tailwind) === null || ref2 === void 0 ? void 0 : ref2.layer) !== void 0) {
            return;
          }
        }
        let container = nestedClone(rule);
        let sort = context.offsets.create("user");
        for (let className of extractClasses(rule)) {
          let list = cache.get(className) || [];
          cache.set(className, list);
          list.push([
            {
              layer: "user",
              sort,
              important: false
            },
            container
          ]);
        }
      });
      return cache;
    }
    function buildApplyCache(applyCandidates, context) {
      for (let candidate of applyCandidates) {
        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
          continue;
        }
        if (context.classCache.has(candidate)) {
          context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule]) => [
            meta,
            rule.clone()
          ]));
          continue;
        }
        let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));
        if (matches.length === 0) {
          context.notClassCache.add(candidate);
          continue;
        }
        context.applyClassCache.set(candidate, matches);
      }
      return context.applyClassCache;
    }
    function lazyCache(buildCacheFn) {
      let cache = null;
      return {
        get: (name) => {
          cache = cache || buildCacheFn();
          return cache.get(name);
        },
        has: (name) => {
          cache = cache || buildCacheFn();
          return cache.has(name);
        }
      };
    }
    function combineCaches(caches) {
      return {
        get: (name) => caches.flatMap((cache) => cache.get(name) || []),
        has: (name) => caches.some((cache) => cache.has(name))
      };
    }
    function extractApplyCandidates(params) {
      let candidates = params.split(/[\s\t\n]+/g);
      if (candidates[candidates.length - 1] === "!important") {
        return [
          candidates.slice(0, -1),
          true
        ];
      }
      return [
        candidates,
        false
      ];
    }
    function processApply(root, context, localCache) {
      let applyCandidates = /* @__PURE__ */ new Set();
      let applies = [];
      root.walkAtRules("apply", (rule) => {
        let [candidates] = extractApplyCandidates(rule.params);
        for (let util of candidates) {
          applyCandidates.add(util);
        }
        applies.push(rule);
      });
      if (applies.length === 0) {
        return;
      }
      let applyClassCache = combineCaches([
        localCache,
        buildApplyCache(applyCandidates, context)
      ]);
      function replaceSelector(selector, utilitySelectors, candidate) {
        let selectorList = extractSelectors(selector);
        let utilitySelectorsList = extractSelectors(utilitySelectors);
        let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);
        let candidateClass = candidateList.nodes[0].nodes[0];
        selectorList.each((sel) => {
          let replaced = /* @__PURE__ */ new Set();
          utilitySelectorsList.each((utilitySelector) => {
            let hasReplaced = false;
            utilitySelector = utilitySelector.clone();
            utilitySelector.walkClasses((node) => {
              if (node.value !== candidateClass.value) {
                return;
              }
              if (hasReplaced) {
                return;
              }
              node.replaceWith(...sel.nodes.map((node2) => node2.clone()));
              replaced.add(utilitySelector);
              hasReplaced = true;
            });
          });
          for (let sel1 of replaced) {
            let groups = [
              []
            ];
            for (let node of sel1.nodes) {
              if (node.type === "combinator") {
                groups.push(node);
                groups.push([]);
              } else {
                let last = groups[groups.length - 1];
                last.push(node);
              }
            }
            sel1.nodes = [];
            for (let group of groups) {
              if (Array.isArray(group)) {
                group.sort((a, b) => {
                  if (a.type === "tag" && b.type === "class") {
                    return -1;
                  } else if (a.type === "class" && b.type === "tag") {
                    return 1;
                  } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
                    return -1;
                  } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
                    return 1;
                  }
                  return 0;
                });
              }
              sel1.nodes = sel1.nodes.concat(group);
            }
          }
          sel.replaceWith(...replaced);
        });
        return selectorList.toString();
      }
      let perParentApplies = /* @__PURE__ */ new Map();
      for (let apply of applies) {
        let [candidates] = perParentApplies.get(apply.parent) || [
          [],
          apply.source
        ];
        perParentApplies.set(apply.parent, [
          candidates,
          apply.source
        ]);
        let [applyCandidates1, important] = extractApplyCandidates(apply.params);
        if (apply.parent.type === "atrule") {
          if (apply.parent.name === "screen") {
            let screenType = apply.parent.params;
            throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates1.map((c) => `${screenType}:${c}`).join(" ")} instead.`);
          }
          throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);
        }
        for (let applyCandidate of applyCandidates1) {
          if ([
            prefix(context, "group"),
            prefix(context, "peer")
          ].includes(applyCandidate)) {
            throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
          }
          if (!applyClassCache.has(applyCandidate)) {
            throw apply.error(`The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
          }
          let rules = applyClassCache.get(applyCandidate);
          candidates.push([
            applyCandidate,
            important,
            rules
          ]);
        }
      }
      for (let [parent, [candidates1, atApplySource]] of perParentApplies) {
        let siblings = [];
        for (let [applyCandidate1, important1, rules1] of candidates1) {
          let potentialApplyCandidates = [
            applyCandidate1,
            ...extractBaseCandidates([
              applyCandidate1
            ], context.tailwindConfig.separator)
          ];
          for (let [meta, node] of rules1) {
            let parentClasses = extractClasses(parent);
            let nodeClasses = extractClasses(node);
            nodeClasses = nodeClasses.groups.filter((classList) => classList.some((className) => potentialApplyCandidates.includes(className))).flat();
            nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));
            let intersects = parentClasses.some((selector) => nodeClasses.includes(selector));
            if (intersects) {
              throw node.error(`You cannot \`@apply\` the \`${applyCandidate1}\` utility here because it creates a circular dependency.`);
            }
            let root1 = _postcss.default.root({
              nodes: [
                node.clone()
              ]
            });
            root1.walk((node2) => {
              node2.source = atApplySource;
            });
            let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
            if (canRewriteSelector) {
              root1.walkRules((rule) => {
                if (!extractClasses(rule).some((candidate) => candidate === applyCandidate1)) {
                  rule.remove();
                  return;
                }
                let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
                let isGenerated = parent.raws.tailwind !== void 0;
                let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
                rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate1);
                if (importantSelector && parentSelector !== parent.selector) {
                  rule.selector = `${importantSelector} ${rule.selector}`;
                }
                rule.walkDecls((d) => {
                  d.important = meta.important || important1;
                });
              });
            }
            if (!root1.nodes[0]) {
              continue;
            }
            siblings.push([
              meta.sort,
              root1.nodes[0]
            ]);
          }
        }
        let nodes = context.offsets.sort(siblings).map((s) => s[1]);
        parent.after(nodes);
      }
      for (let apply1 of applies) {
        if (apply1.parent.nodes.length > 1) {
          apply1.remove();
        } else {
          apply1.parent.remove();
        }
      }
      processApply(root, context, localCache);
    }
    function expandApplyAtRules(context) {
      return (root) => {
        let localCache = lazyCache(() => buildLocalApplyCache(root, context));
        processApply(root, context, localCache);
      };
    }
  }
});

// node_modules/.pnpm/didyoumean@1.2.2/node_modules/didyoumean/didYouMean-1.2.1.js
var require_didYouMean_1_2_1 = __commonJS({
  "node_modules/.pnpm/didyoumean@1.2.2/node_modules/didyoumean/didYouMean-1.2.1.js"(exports, module2) {
    (function() {
      "use strict";
      function didYouMean(str, list, key) {
        if (!str)
          return null;
        if (!didYouMean.caseSensitive) {
          str = str.toLowerCase();
        }
        var thresholdRelative = didYouMean.threshold === null ? null : didYouMean.threshold * str.length, thresholdAbsolute = didYouMean.thresholdAbsolute, winningVal;
        if (thresholdRelative !== null && thresholdAbsolute !== null)
          winningVal = Math.min(thresholdRelative, thresholdAbsolute);
        else if (thresholdRelative !== null)
          winningVal = thresholdRelative;
        else if (thresholdAbsolute !== null)
          winningVal = thresholdAbsolute;
        else
          winningVal = null;
        var winner, candidate, testCandidate, val, i, len = list.length;
        for (i = 0; i < len; i++) {
          candidate = list[i];
          if (key) {
            candidate = candidate[key];
          }
          if (!candidate) {
            continue;
          }
          if (!didYouMean.caseSensitive) {
            testCandidate = candidate.toLowerCase();
          } else {
            testCandidate = candidate;
          }
          val = getEditDistance(str, testCandidate, winningVal);
          if (winningVal === null || val < winningVal) {
            winningVal = val;
            if (key && didYouMean.returnWinningObject)
              winner = list[i];
            else
              winner = candidate;
            if (didYouMean.returnFirstMatch)
              return winner;
          }
        }
        return winner || didYouMean.nullResultValue;
      }
      didYouMean.threshold = 0.4;
      didYouMean.thresholdAbsolute = 20;
      didYouMean.caseSensitive = false;
      didYouMean.nullResultValue = null;
      didYouMean.returnWinningObject = null;
      didYouMean.returnFirstMatch = false;
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = didYouMean;
      } else {
        window.didYouMean = didYouMean;
      }
      var MAX_INT = Math.pow(2, 32) - 1;
      function getEditDistance(a, b, max) {
        max = max || max === 0 ? max : MAX_INT;
        var lena = a.length;
        var lenb = b.length;
        if (lena === 0)
          return Math.min(max + 1, lenb);
        if (lenb === 0)
          return Math.min(max + 1, lena);
        if (Math.abs(lena - lenb) > max)
          return max + 1;
        var matrix = [], i, j, colMin, minJ, maxJ;
        for (i = 0; i <= lenb; i++) {
          matrix[i] = [i];
        }
        for (j = 0; j <= lena; j++) {
          matrix[0][j] = j;
        }
        for (i = 1; i <= lenb; i++) {
          colMin = MAX_INT;
          minJ = 1;
          if (i > max)
            minJ = i - max;
          maxJ = lenb + 1;
          if (maxJ > max + i)
            maxJ = max + i;
          for (j = 1; j <= lena; j++) {
            if (j < minJ || j > maxJ) {
              matrix[i][j] = max + 1;
            } else {
              if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
              } else {
                matrix[i][j] = Math.min(
                  matrix[i - 1][j - 1] + 1,
                  Math.min(
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                  )
                );
              }
            }
            if (matrix[i][j] < colMin)
              colMin = matrix[i][j];
          }
          if (colMin > max)
            return max + 1;
        }
        return matrix[lenb][lena];
      }
    })();
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js"(exports, module2) {
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module2.exports = function(input) {
      var tokens = [];
      var value = input;
      var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value.charCodeAt(pos);
      var max = value.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          token = value.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape = false;
            next = value.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape = !escape;
              }
            } else {
              value += quote;
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape);
          token.value = value.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value.charCodeAt(pos);
        } else if (code === slash && value.charCodeAt(pos + 1) === star) {
          next = value.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value.length;
            token.sourceEndIndex = next;
          }
          token.value = value.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape = false;
              next = value.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape = !escape;
                }
              } else {
                value += ")";
                next = value.length - 1;
                token.unclosed = true;
              }
            } while (escape);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value.charCodeAt(next);
          } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token = value.slice(pos, next);
          if (openParentheses === code) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value.length;
      }
      return stack[0].nodes;
    };
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js
var require_walk2 = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js"(exports, module2) {
    module2.exports = function walk(nodes, cb, bubble) {
      var i, max, node, result;
      for (i = 0, max = nodes.length; i < max; i += 1) {
        node = nodes[i];
        if (!bubble) {
          result = cb(node, i, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
          walk(node.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node, i, nodes);
        }
      }
    };
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js"(exports, module2) {
    function stringifyNode(node, custom) {
      var type = node.type;
      var value = node.value;
      var buf;
      var customResult;
      if (custom && (customResult = custom(node)) !== void 0) {
        return customResult;
      } else if (type === "word" || type === "space") {
        return value;
      } else if (type === "string") {
        buf = node.quote || "";
        return buf + value + (node.unclosed ? "" : buf);
      } else if (type === "comment") {
        return "/*" + value + (node.unclosed ? "" : "*/");
      } else if (type === "div") {
        return (node.before || "") + value + (node.after || "");
      } else if (Array.isArray(node.nodes)) {
        buf = stringify(node.nodes, custom);
        if (type !== "function") {
          return buf;
        }
        return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
      }
      return value;
    }
    function stringify(nodes, custom) {
      var result, i;
      if (Array.isArray(nodes)) {
        result = "";
        for (i = nodes.length - 1; ~i; i -= 1) {
          result = stringifyNode(nodes[i], custom) + result;
        }
        return result;
      }
      return stringifyNode(nodes, custom);
    }
    module2.exports = stringify;
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js"(exports, module2) {
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value) {
      var code = value.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module2.exports = function(value) {
      var pos = 0;
      var length = value.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length === 0 || !likeNumber(value)) {
        return false;
      }
      code = value.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value.charCodeAt(pos);
      nextCode = value.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length) {
          code = value.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value.charCodeAt(pos);
      nextCode = value.charCodeAt(pos + 1);
      nextNextCode = value.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length) {
          code = value.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
      };
    };
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js"(exports, module2) {
    var parse4 = require_parse3();
    var walk = require_walk2();
    var stringify = require_stringify2();
    function ValueParser(value) {
      if (this instanceof ValueParser) {
        this.nodes = parse4(value);
        return this;
      }
      return new ValueParser(value);
    }
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = require_unit();
    ValueParser.walk = walk;
    ValueParser.stringify = stringify;
    module2.exports = ValueParser;
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/evaluateTailwindFunctions.js
var require_evaluateTailwindFunctions = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/evaluateTailwindFunctions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var _dlv = /* @__PURE__ */ _interopRequireDefault((init_dlv_es(), __toCommonJS(dlv_es_exports)));
    var _didyoumean = /* @__PURE__ */ _interopRequireDefault(require_didYouMean_1_2_1());
    var _transformThemeValue = /* @__PURE__ */ _interopRequireDefault(require_transformThemeValue());
    var _postcssValueParser = /* @__PURE__ */ _interopRequireDefault(require_lib());
    var _normalizeScreens = require_normalizeScreens();
    var _buildMediaQuery = /* @__PURE__ */ _interopRequireDefault(require_buildMediaQuery());
    var _toPath = require_toPath();
    var _withAlphaVariable = require_withAlphaVariable();
    var _pluginUtils = require_pluginUtils();
    var _log = /* @__PURE__ */ _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function isObject(input) {
      return typeof input === "object" && input !== null;
    }
    function findClosestExistingPath(theme, path3) {
      let parts = (0, _toPath.toPath)(path3);
      do {
        parts.pop();
        if ((0, _dlv.default)(theme, parts) !== void 0)
          break;
      } while (parts.length);
      return parts.length ? parts : void 0;
    }
    function pathToString(path3) {
      if (typeof path3 === "string")
        return path3;
      return path3.reduce((acc, cur, i) => {
        if (cur.includes("."))
          return `${acc}[${cur}]`;
        return i === 0 ? cur : `${acc}.${cur}`;
      }, "");
    }
    function list(items) {
      return items.map((key) => `'${key}'`).join(", ");
    }
    function listKeys(obj) {
      return list(Object.keys(obj));
    }
    function validatePath(config, path3, defaultValue, themeOpts = {}) {
      const pathString = Array.isArray(path3) ? pathToString(path3) : path3.replace(/^['"]+|['"]+$/g, "");
      const pathSegments = Array.isArray(path3) ? path3 : (0, _toPath.toPath)(pathString);
      const value = (0, _dlv.default)(config.theme, pathSegments, defaultValue);
      if (value === void 0) {
        let error = `'${pathString}' does not exist in your theme config.`;
        const parentSegments = pathSegments.slice(0, -1);
        const parentValue = (0, _dlv.default)(config.theme, parentSegments);
        if (isObject(parentValue)) {
          const validKeys = Object.keys(parentValue).filter((key) => validatePath(config, [
            ...parentSegments,
            key
          ]).isValid);
          const suggestion = (0, _didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
          if (suggestion) {
            error += ` Did you mean '${pathToString([
              ...parentSegments,
              suggestion
            ])}'?`;
          } else if (validKeys.length > 0) {
            error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list(validKeys)}`;
          }
        } else {
          const closestPath = findClosestExistingPath(config.theme, pathString);
          if (closestPath) {
            const closestValue = (0, _dlv.default)(config.theme, closestPath);
            if (isObject(closestValue)) {
              error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(closestValue)}`;
            } else {
              error += ` '${pathToString(closestPath)}' is not an object.`;
            }
          } else {
            error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;
          }
        }
        return {
          isValid: false,
          error
        };
      }
      if (!(typeof value === "string" || typeof value === "number" || typeof value === "function" || value instanceof String || value instanceof Number || Array.isArray(value))) {
        let error1 = `'${pathString}' was found but does not resolve to a string.`;
        if (isObject(value)) {
          let validKeys1 = Object.keys(value).filter((key) => validatePath(config, [
            ...pathSegments,
            key
          ]).isValid);
          if (validKeys1.length) {
            error1 += ` Did you mean something like '${pathToString([
              ...pathSegments,
              validKeys1[0]
            ])}'?`;
          }
        }
        return {
          isValid: false,
          error: error1
        };
      }
      const [themeSection] = pathSegments;
      return {
        isValid: true,
        value: (0, _transformThemeValue.default)(themeSection)(value, themeOpts)
      };
    }
    function extractArgs(node, vNodes, functions) {
      vNodes = vNodes.map((vNode) => resolveVNode(node, vNode, functions));
      let args = [
        ""
      ];
      for (let vNode of vNodes) {
        if (vNode.type === "div" && vNode.value === ",") {
          args.push("");
        } else {
          args[args.length - 1] += _postcssValueParser.default.stringify(vNode);
        }
      }
      return args;
    }
    function resolveVNode(node, vNode, functions) {
      if (vNode.type === "function" && functions[vNode.value] !== void 0) {
        let args = extractArgs(node, vNode.nodes, functions);
        vNode.type = "word";
        vNode.value = functions[vNode.value](node, ...args);
      }
      return vNode;
    }
    function resolveFunctions(node, input, functions) {
      return (0, _postcssValueParser.default)(input).walk((vNode) => {
        resolveVNode(node, vNode, functions);
      }).toString();
    }
    var nodeTypePropertyMap = {
      atrule: "params",
      decl: "value"
    };
    function* toPaths(path3) {
      path3 = path3.replace(/^['"]+|['"]+$/g, "");
      let matches = path3.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
      let alpha = void 0;
      yield [
        path3,
        void 0
      ];
      if (matches) {
        path3 = matches[1];
        alpha = matches[2];
        yield [
          path3,
          alpha
        ];
      }
    }
    function resolvePath(config, path3, defaultValue) {
      const results = Array.from(toPaths(path3)).map(([path4, alpha]) => {
        return Object.assign(validatePath(config, path4, defaultValue, {
          opacityValue: alpha
        }), {
          resolvedPath: path4,
          alpha
        });
      });
      var ref2;
      return (ref2 = results.find((result) => result.isValid)) !== null && ref2 !== void 0 ? ref2 : results[0];
    }
    function _default(context) {
      let config = context.tailwindConfig;
      let functions = {
        theme: (node, path3, ...defaultValue) => {
          let { isValid, value, error, alpha } = resolvePath(config, path3, defaultValue.length ? defaultValue : void 0);
          if (!isValid) {
            var ref2;
            let parentNode = node.parent;
            let candidate = (ref2 = parentNode === null || parentNode === void 0 ? void 0 : parentNode.raws.tailwind) === null || ref2 === void 0 ? void 0 : ref2.candidate;
            if (parentNode && candidate !== void 0) {
              context.markInvalidUtilityNode(parentNode);
              parentNode.remove();
              _log.default.warn("invalid-theme-key-in-class", [
                `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
              ]);
              return;
            }
            throw node.error(error);
          }
          let maybeColor = (0, _pluginUtils.parseColorFormat)(value);
          let isColorFunction = maybeColor !== void 0 && typeof maybeColor === "function";
          if (alpha !== void 0 || isColorFunction) {
            if (alpha === void 0) {
              alpha = 1;
            }
            value = (0, _withAlphaVariable.withAlphaValue)(maybeColor, alpha, maybeColor);
          }
          return value;
        },
        screen: (node, screen) => {
          screen = screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
          let screens = (0, _normalizeScreens.normalizeScreens)(config.theme.screens);
          let screenDefinition = screens.find(({ name }) => name === screen);
          if (!screenDefinition) {
            throw node.error(`The '${screen}' screen does not exist in your theme.`);
          }
          return (0, _buildMediaQuery.default)(screenDefinition);
        }
      };
      return (root) => {
        root.walk((node) => {
          let property = nodeTypePropertyMap[node.type];
          if (property === void 0) {
            return;
          }
          node[property] = resolveFunctions(node, node[property], functions);
        });
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/substituteScreenAtRules.js
var require_substituteScreenAtRules = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/substituteScreenAtRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var _normalizeScreens = require_normalizeScreens();
    var _buildMediaQuery = /* @__PURE__ */ _interopRequireDefault(require_buildMediaQuery());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _default({ tailwindConfig: { theme } }) {
      return function(css) {
        css.walkAtRules("screen", (atRule) => {
          let screen = atRule.params;
          let screens = (0, _normalizeScreens.normalizeScreens)(theme.screens);
          let screenDefinition = screens.find(({ name }) => name === screen);
          if (!screenDefinition) {
            throw atRule.error(`No \`${screen}\` screen found.`);
          }
          atRule.name = "media";
          atRule.params = (0, _buildMediaQuery.default)(screenDefinition);
        });
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js
var require_resolveDefaultsAtRules = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      elementSelectorParser: () => elementSelectorParser,
      default: () => resolveDefaultsAtRules
    });
    var _postcss = /* @__PURE__ */ _interopRequireDefault(require("postcss"));
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _featureFlags = require_featureFlags();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getNode = {
      id(node) {
        return _postcssSelectorParser.default.attribute({
          attribute: "id",
          operator: "=",
          value: node.value,
          quoteMark: '"'
        });
      }
    };
    function minimumImpactSelector(nodes) {
      let rest = nodes.filter((node2) => {
        if (node2.type !== "pseudo")
          return true;
        if (node2.nodes.length > 0)
          return true;
        return node2.value.startsWith("::") || [
          ":before",
          ":after",
          ":first-line",
          ":first-letter"
        ].includes(node2.value);
      }).reverse();
      let searchFor = /* @__PURE__ */ new Set([
        "tag",
        "class",
        "id",
        "attribute"
      ]);
      let splitPointIdx = rest.findIndex((n) => searchFor.has(n.type));
      if (splitPointIdx === -1)
        return rest.reverse().join("").trim();
      let node = rest[splitPointIdx];
      let bestNode = getNode[node.type] ? getNode[node.type](node) : node;
      rest = rest.slice(0, splitPointIdx);
      let combinatorIdx = rest.findIndex((n) => n.type === "combinator" && n.value === ">");
      if (combinatorIdx !== -1) {
        rest.splice(0, combinatorIdx);
        rest.unshift(_postcssSelectorParser.default.universal());
      }
      return [
        bestNode,
        ...rest.reverse()
      ].join("").trim();
    }
    var elementSelectorParser = (0, _postcssSelectorParser.default)((selectors) => {
      return selectors.map((s) => {
        let nodes = s.split((n) => n.type === "combinator" && n.value === " ").pop();
        return minimumImpactSelector(nodes);
      });
    });
    var cache = /* @__PURE__ */ new Map();
    function extractElementSelector(selector) {
      if (!cache.has(selector)) {
        cache.set(selector, elementSelectorParser.transformSync(selector));
      }
      return cache.get(selector);
    }
    function resolveDefaultsAtRules({ tailwindConfig }) {
      return (root) => {
        let variableNodeMap = /* @__PURE__ */ new Map();
        let universals = /* @__PURE__ */ new Set();
        root.walkAtRules("defaults", (rule) => {
          if (rule.nodes && rule.nodes.length > 0) {
            universals.add(rule);
            return;
          }
          let variable = rule.params;
          if (!variableNodeMap.has(variable)) {
            variableNodeMap.set(variable, /* @__PURE__ */ new Set());
          }
          variableNodeMap.get(variable).add(rule.parent);
          rule.remove();
        });
        if ((0, _featureFlags.flagEnabled)(tailwindConfig, "optimizeUniversalDefaults")) {
          for (let universal of universals) {
            let selectorGroups = /* @__PURE__ */ new Map();
            var ref2;
            let rules = (ref2 = variableNodeMap.get(universal.params)) !== null && ref2 !== void 0 ? ref2 : [];
            for (let rule of rules) {
              for (let selector of extractElementSelector(rule.selector)) {
                let selectorGroupName = selector.includes(":-") || selector.includes("::-") ? selector : "__DEFAULT__";
                var ref1;
                let selectors = (ref1 = selectorGroups.get(selectorGroupName)) !== null && ref1 !== void 0 ? ref1 : /* @__PURE__ */ new Set();
                selectorGroups.set(selectorGroupName, selectors);
                selectors.add(selector);
              }
            }
            if ((0, _featureFlags.flagEnabled)(tailwindConfig, "optimizeUniversalDefaults")) {
              if (selectorGroups.size === 0) {
                universal.remove();
                continue;
              }
              for (let [, selectors1] of selectorGroups) {
                let universalRule = _postcss.default.rule({
                  source: universal.source
                });
                universalRule.selectors = [
                  ...selectors1
                ];
                universalRule.append(universal.nodes.map((node) => node.clone()));
                universal.before(universalRule);
              }
            }
            universal.remove();
          }
        } else if (universals.size) {
          let universalRule1 = _postcss.default.rule({
            selectors: [
              "*",
              "::before",
              "::after"
            ]
          });
          for (let universal1 of universals) {
            universalRule1.append(universal1.nodes);
            if (!universalRule1.parent) {
              universal1.before(universalRule1);
            }
            if (!universalRule1.source) {
              universalRule1.source = universal1.source;
            }
            universal1.remove();
          }
          let backdropRule = universalRule1.clone({
            selectors: [
              "::backdrop"
            ]
          });
          universalRule1.after(backdropRule);
        }
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js
var require_collapseAdjacentRules = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => collapseAdjacentRules
    });
    var comparisonMap = {
      atrule: [
        "name",
        "params"
      ],
      rule: [
        "selector"
      ]
    };
    var types2 = new Set(Object.keys(comparisonMap));
    function collapseAdjacentRules() {
      function collapseRulesIn(root) {
        let currentRule = null;
        root.each((node) => {
          if (!types2.has(node.type)) {
            currentRule = null;
            return;
          }
          if (currentRule === null) {
            currentRule = node;
            return;
          }
          let properties = comparisonMap[node.type];
          var _property, _property1;
          if (node.type === "atrule" && node.name === "font-face") {
            currentRule = node;
          } else if (properties.every((property) => ((_property = node[property]) !== null && _property !== void 0 ? _property : "").replace(/\s+/g, " ") === ((_property1 = currentRule[property]) !== null && _property1 !== void 0 ? _property1 : "").replace(/\s+/g, " "))) {
            if (node.nodes) {
              currentRule.append(node.nodes);
            }
            node.remove();
          } else {
            currentRule = node;
          }
        });
        root.each((node) => {
          if (node.type === "atrule") {
            collapseRulesIn(node);
          }
        });
      }
      return (root) => {
        collapseRulesIn(root);
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js
var require_collapseDuplicateDeclarations = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => collapseDuplicateDeclarations
    });
    function collapseDuplicateDeclarations() {
      return (root) => {
        root.walkRules((node) => {
          let seen = /* @__PURE__ */ new Map();
          let droppable = /* @__PURE__ */ new Set([]);
          let byProperty = /* @__PURE__ */ new Map();
          node.walkDecls((decl) => {
            if (decl.parent !== node) {
              return;
            }
            if (seen.has(decl.prop)) {
              if (seen.get(decl.prop).value === decl.value) {
                droppable.add(seen.get(decl.prop));
                seen.set(decl.prop, decl);
                return;
              }
              if (!byProperty.has(decl.prop)) {
                byProperty.set(decl.prop, /* @__PURE__ */ new Set());
              }
              byProperty.get(decl.prop).add(seen.get(decl.prop));
              byProperty.get(decl.prop).add(decl);
            }
            seen.set(decl.prop, decl);
          });
          for (let decl of droppable) {
            decl.remove();
          }
          for (let declarations of byProperty.values()) {
            let byUnit = /* @__PURE__ */ new Map();
            for (let decl1 of declarations) {
              let unit = resolveUnit(decl1.value);
              if (unit === null) {
                continue;
              }
              if (!byUnit.has(unit)) {
                byUnit.set(unit, /* @__PURE__ */ new Set());
              }
              byUnit.get(unit).add(decl1);
            }
            for (let declarations1 of byUnit.values()) {
              let removableDeclarations = Array.from(declarations1).slice(0, -1);
              for (let decl2 of removableDeclarations) {
                decl2.remove();
              }
            }
          }
        });
      };
    }
    var UNITLESS_NUMBER = Symbol("unitless-number");
    function resolveUnit(input) {
      let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
      if (result) {
        var ref2;
        return (ref2 = result[1]) !== null && ref2 !== void 0 ? ref2 : UNITLESS_NUMBER;
      }
      return null;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/partitionApplyAtRules.js
var require_partitionApplyAtRules = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/partitionApplyAtRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => expandApplyAtRules
    });
    function partitionRules(root) {
      if (!root.walkAtRules)
        return;
      let applyParents = /* @__PURE__ */ new Set();
      root.walkAtRules("apply", (rule) => {
        applyParents.add(rule.parent);
      });
      if (applyParents.size === 0) {
        return;
      }
      for (let rule of applyParents) {
        let nodeGroups = [];
        let lastGroup = [];
        for (let node of rule.nodes) {
          if (node.type === "atrule" && node.name === "apply") {
            if (lastGroup.length > 0) {
              nodeGroups.push(lastGroup);
              lastGroup = [];
            }
            nodeGroups.push([
              node
            ]);
          } else {
            lastGroup.push(node);
          }
        }
        if (lastGroup.length > 0) {
          nodeGroups.push(lastGroup);
        }
        if (nodeGroups.length === 1) {
          continue;
        }
        for (let group of [
          ...nodeGroups
        ].reverse()) {
          let clone = rule.clone({
            nodes: []
          });
          clone.append(group);
          rule.after(clone);
        }
        rule.remove();
      }
    }
    function expandApplyAtRules() {
      return (root) => {
        partitionRules(root);
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/detectNesting.js
var require_detectNesting = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/detectNesting.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    function _default(_context) {
      return (root, result) => {
        let found = false;
        root.walkAtRules("tailwind", (node) => {
          if (found)
            return false;
          if (node.parent && node.parent.type !== "root") {
            found = true;
            node.warn(result, [
              "Nested @tailwind rules were detected, but are not supported.",
              "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
              "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
            ].join("\n"));
            return false;
          }
        });
        root.walkRules((rule) => {
          if (found)
            return false;
          rule.walkRules((nestedRule) => {
            found = true;
            nestedRule.warn(result, [
              "Nested CSS was detected, but CSS nesting has not been configured correctly.",
              "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
              "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
            ].join("\n"));
            return false;
          });
        });
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/processTailwindFeatures.js
var require_processTailwindFeatures = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/processTailwindFeatures.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => processTailwindFeatures
    });
    var _normalizeTailwindDirectives = /* @__PURE__ */ _interopRequireDefault(require_normalizeTailwindDirectives());
    var _expandTailwindAtRules = /* @__PURE__ */ _interopRequireDefault(require_expandTailwindAtRules());
    var _expandApplyAtRules = /* @__PURE__ */ _interopRequireDefault(require_expandApplyAtRules());
    var _evaluateTailwindFunctions = /* @__PURE__ */ _interopRequireDefault(require_evaluateTailwindFunctions());
    var _substituteScreenAtRules = /* @__PURE__ */ _interopRequireDefault(require_substituteScreenAtRules());
    var _resolveDefaultsAtRules = /* @__PURE__ */ _interopRequireDefault(require_resolveDefaultsAtRules());
    var _collapseAdjacentRules = /* @__PURE__ */ _interopRequireDefault(require_collapseAdjacentRules());
    var _collapseDuplicateDeclarations = /* @__PURE__ */ _interopRequireDefault(require_collapseDuplicateDeclarations());
    var _partitionApplyAtRules = /* @__PURE__ */ _interopRequireDefault(require_partitionApplyAtRules());
    var _detectNesting = /* @__PURE__ */ _interopRequireDefault(require_detectNesting());
    var _setupContextUtils = require_setupContextUtils();
    var _featureFlags = require_featureFlags();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function processTailwindFeatures(setupContext) {
      return function(root, result) {
        let { tailwindDirectives, applyDirectives } = (0, _normalizeTailwindDirectives.default)(root);
        (0, _detectNesting.default)()(root, result);
        (0, _partitionApplyAtRules.default)()(root, result);
        let context = setupContext({
          tailwindDirectives,
          applyDirectives,
          registerDependency(dependency) {
            result.messages.push({
              plugin: "tailwindcss",
              parent: result.opts.from,
              ...dependency
            });
          },
          createContext(tailwindConfig, changedContent) {
            return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
          }
        })(root, result);
        if (context.tailwindConfig.separator === "-") {
          throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
        }
        (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
        (0, _expandTailwindAtRules.default)(context)(root, result);
        (0, _partitionApplyAtRules.default)()(root, result);
        (0, _expandApplyAtRules.default)(context)(root, result);
        (0, _evaluateTailwindFunctions.default)(context)(root, result);
        (0, _substituteScreenAtRules.default)(context)(root, result);
        (0, _resolveDefaultsAtRules.default)(context)(root, result);
        (0, _collapseAdjacentRules.default)(context)(root, result);
        (0, _collapseDuplicateDeclarations.default)(context)(root, result);
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/findAtConfigPath.js
var require_findAtConfigPath = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/lib/findAtConfigPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "findAtConfigPath", {
      enumerable: true,
      get: () => findAtConfigPath
    });
    var _fs = /* @__PURE__ */ _interopRequireDefault(require("fs"));
    var _path = /* @__PURE__ */ _interopRequireDefault(require("path"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function findAtConfigPath(root, result) {
      let configPath = null;
      let relativeTo = null;
      root.walkAtRules("config", (rule) => {
        var ref2;
        var _file, ref1;
        relativeTo = (ref1 = (_file = (ref2 = rule.source) === null || ref2 === void 0 ? void 0 : ref2.input.file) !== null && _file !== void 0 ? _file : result.opts.from) !== null && ref1 !== void 0 ? ref1 : null;
        if (relativeTo === null) {
          throw rule.error("The `@config` directive cannot be used without setting `from` in your PostCSS config.");
        }
        if (configPath) {
          throw rule.error("Only one `@config` directive is allowed per file.");
        }
        let matches = rule.params.match(/(['"])(.*?)\1/);
        if (!matches) {
          throw rule.error("A path is required when using the `@config` directive.");
        }
        let inputPath = matches[2];
        if (_path.default.isAbsolute(inputPath)) {
          throw rule.error("The `@config` directive cannot be used with an absolute path.");
        }
        configPath = _path.default.resolve(_path.default.dirname(relativeTo), inputPath);
        if (!_fs.default.existsSync(configPath)) {
          throw rule.error(`The config file at "${inputPath}" does not exist. Make sure the path is correct and the file exists.`);
        }
        rule.remove();
      });
      return configPath ? configPath : null;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.2.4_postcss@8.4.21/node_modules/tailwindcss/lib/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _setupTrackingContext = /* @__PURE__ */ _interopRequireDefault(require_setupTrackingContext());
    var _processTailwindFeatures = /* @__PURE__ */ _interopRequireDefault(require_processTailwindFeatures());
    var _sharedState = require_sharedState();
    var _findAtConfigPath = require_findAtConfigPath();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    module2.exports = function tailwindcss(configOrPath) {
      return {
        postcssPlugin: "tailwindcss",
        plugins: [
          _sharedState.env.DEBUG && function(root) {
            console.log("\n");
            console.time("JIT TOTAL");
            return root;
          },
          function(root, result) {
            var ref2;
            configOrPath = (ref2 = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && ref2 !== void 0 ? ref2 : configOrPath;
            let context = (0, _setupTrackingContext.default)(configOrPath);
            if (root.type === "document") {
              let roots = root.nodes.filter((node) => node.type === "root");
              for (const root1 of roots) {
                if (root1.type === "root") {
                  (0, _processTailwindFeatures.default)(context)(root1, result);
                }
              }
              return;
            }
            (0, _processTailwindFeatures.default)(context)(root, result);
          },
          _sharedState.env.DEBUG && function(root) {
            console.timeEnd("JIT TOTAL");
            console.log("\n");
            return root;
          }
        ].filter(Boolean)
      };
    };
    module2.exports.postcss = true;
  }
});

// src/plugin/index.ts
var plugin_exports = {};
__export(plugin_exports, {
  default: () => plugin_default
});
module.exports = __toCommonJS(plugin_exports);

// src/factory/tailwind.ts
function removeWhiteSpaceInClasses(classes) {
  const whitespace = /(\r|\t)/g;
  const lineBreak2 = /(\n| )/g;
  let formattedClasses = classes;
  if (whitespace.test(formattedClasses)) {
    formattedClasses = formattedClasses.replace(whitespace, "");
  }
  if (lineBreak2.test(formattedClasses)) {
    const allFormattedClasses = formattedClasses.split(lineBreak2);
    try {
      return allFormattedClasses.filter((rawClass) => {
        rawClass = rawClass.trim();
        return !!rawClass && rawClass !== "\n";
      }).map((rawClass) => {
        return rawClass.trim();
      }).join(" ");
    } catch {
      return "";
    }
  }
  return formattedClasses;
}

// src/plugin/emitter.ts
var import_node_events = require("events");
var import_node_fs = require("fs");

// src/utils/generateId.ts
var import_node_crypto = require("crypto");
function generateId() {
  return (0, import_node_crypto.randomBytes)(6).toString("hex");
}

// src/plugin/emitter.ts
var import_postcss = __toESM(require("postcss"));
var import_tailwindcss = __toESM(require_lib2());
var import_node_path = __toESM(require("path"));

// src/plugin/logs.ts
var import_kleur = __toESM(require("kleur"));
var Logs = class {
  static info(message, ...rest) {
    const runningInSSR = this.preset === "next";
    const alreadyPrinted = this.printedMessages.includes(message);
    const isSpecialMessage = this.specialMessages.includes(message);
    if (!runningInSSR || !alreadyPrinted) {
      console.log(`${import_kleur.default.blue("style")} - ${message}`, ...rest);
      this.printedMessages.push(message);
    } else if (isSpecialMessage) {
      this.printedMessages = this.printedMessages.filter((printedMessage) => {
        return printedMessage !== message;
      });
    }
  }
  static error(message, ...rest) {
    if (!this.printedMessages.includes(message)) {
      console.log(`${import_kleur.default.red("style")} - ${message}`, ...rest);
      this.printedMessages.push(message);
    }
  }
  static warning(message, ...rest) {
    if (!this.printedMessages.includes(message)) {
      console.log(`${import_kleur.default.yellow("style ")} - ${message}`, ...rest);
      this.printedMessages.push(message);
    }
  }
  static changePreset(preset) {
    this.preset = preset;
  }
};
Logs.preset = "react";
Logs.printedMessages = [];
Logs.specialMessages = ["styles updated"];

// src/plugin/emitter.ts
var cacheFolderPath = import_node_path.default.resolve(__dirname, "cache");
var cachePath = import_node_path.default.resolve(__dirname, "cache", "styles.json");
var StyleEmitter = class extends import_node_events.EventEmitter {
  constructor() {
    super();
    this._on = super.on;
    this._emit = super.emit;
    this.files = [];
    this.styles = [];
    this.getCache();
  }
  on(eventName, listener) {
    return this._on(eventName, listener);
  }
  emit(eventName, options) {
    return this._emit(eventName, options);
  }
  getCache() {
    try {
      const rawCachedStyles = (0, import_node_fs.readFileSync)(cachePath).toString();
      const cachedStyles = JSON.parse(rawCachedStyles) ?? [];
      if (Array.isArray(cachedStyles)) {
        this.styles = cachedStyles.map((cachedStyle) => {
          this.registerFile(cachedStyle.filename);
          return {
            ...cachedStyle,
            state: "cached"
          };
        });
      }
    } catch (_) {
      this.styles = [];
    }
  }
  getStyle(classes) {
    return this.styles.find((style) => {
      return style.classes === classes;
    });
  }
  getStyleIndexByReference(filename, reference) {
    return this.styles.findIndex((style) => {
      return style.filename === filename && style.reference === reference;
    });
  }
  getStyleByFile(filename) {
    return this.styles.filter((style) => {
      return style.filename === filename;
    });
  }
  registerStyle({ reference, classes, filename }) {
    this.styles.push({
      reference,
      classes,
      filename,
      css: "",
      state: "loading"
    });
  }
  updateStyle({ reference, filename, css }, stylePath) {
    const index = this.getStyleIndexByReference(filename, reference);
    if (index !== -1) {
      this.styles[index] = {
        ...this.styles[index],
        css,
        state: "updated"
      };
      this.checkStyles(stylePath);
    }
  }
  forceUpdateState(filename, reference) {
    const index = this.getStyleIndexByReference(filename, reference);
    if (index !== -1) {
      this.styles[index] = {
        ...this.styles[index],
        state: "updated"
      };
    }
  }
  getFile(filename) {
    return this.files.find((file) => {
      return file === filename;
    });
  }
  registerFile(filename) {
    const file = this.getFile(filename);
    if (!file) {
      this.files.push(filename);
    }
  }
  register(filename, classes) {
    const style = this.getStyle(classes);
    if (style) {
      const wasCached = style.state === "cached";
      if (wasCached) {
        this.forceUpdateState(filename, style.reference);
      }
      return {
        reference: style.reference,
        state: "updated"
      };
    } else {
      const id = generateId();
      const reference = `factory__${id}`;
      this.registerFile(filename);
      this.registerStyle({
        reference,
        classes,
        filename
      });
      return {
        reference,
        state: "loading"
      };
    }
  }
  stylesWereUpdated() {
    const allStylesInFilesWereLoaded = this.files.every((file) => {
      const styles = this.getStyleByFile(file);
      const allStylesWereLoaded = styles.every((style) => {
        const state = style.state;
        return state !== "loading";
      });
      return allStylesWereLoaded;
    });
    return allStylesInFilesWereLoaded;
  }
  deleteUnnecessaryCachedStyles() {
    this.styles = this.styles.filter((style) => {
      return style.state !== "cached";
    });
  }
  getFormattedFinalStyles() {
    return this.styles.map((style) => {
      return style.css;
    }).join(" ");
  }
  checkStyles(stylesPath = "") {
    const stylesWereUpdated = this.stylesWereUpdated();
    if (stylesWereUpdated) {
      this.deleteUnnecessaryCachedStyles();
      const finalStyles = this.getFormattedFinalStyles();
      this.putStyles(finalStyles, stylesPath);
    }
  }
  putStyles(finalStyle, path3) {
    if (path3 && finalStyle) {
      (0, import_node_fs.writeFile)(path3, finalStyle, (err) => {
        if (err) {
          Logs.error("Unable to update styles");
        }
        Logs.info("styles updated");
        this.emit("createCache", JSON.stringify(this.styles, null, 2));
      });
    } else if (path3) {
      Logs.warning("No deep classes detected, skipping loading.");
    } else {
      Logs.error("Styles path not defined");
    }
  }
  writeCache(cache) {
    (0, import_node_fs.writeFile)(cachePath, cache, (err) => {
      if (err) {
        Logs.error("Unable to create cache");
      }
      this.getCache();
    });
  }
};
var emitter = new StyleEmitter();
emitter.on("createCache", async function(cache) {
  const cachePathAlreadyExists = (0, import_node_fs.existsSync)(cacheFolderPath);
  if (!cachePathAlreadyExists) {
    (0, import_node_fs.mkdir)(cacheFolderPath, {}, (err) => {
      if (err) {
        Logs.error("Unable to create cache folder");
      } else {
        this.writeCache(cache);
      }
    });
  }
  this.writeCache(cache);
});
emitter.on("process", async function({ classes, stylePath, filename, reference }) {
  const res = await (0, import_postcss.default)((0, import_tailwindcss.default)({
    corePlugins: {
      preflight: false
    },
    content: [
      {
        raw: classes
      }
    ]
  })).process("@tailwind utilities;", {
    from: void 0
  });
  const css = res.css;
  this.updateStyle({ reference, filename, css }, stylePath);
});

// src/plugin/index.ts
var import_node_path2 = __toESM(require("path"));
var defaultStylesPath = import_node_path2.default.resolve(__dirname, "styles.css");
function plugin_default({ types: t }) {
  let imported = false;
  return {
    name: "tailwind-factory",
    visitor: {
      ImportDeclaration(path3) {
        const source = path3.node.source.value;
        if (!imported && source === "tailwind-factory") {
          imported = true;
        }
      },
      CallExpression(path3, state) {
        const callee = path3.node.callee;
        const methodArguments = path3.node.arguments;
        if (imported && (callee.type === "Identifier" || callee.type === "V8IntrinsicIdentifier") && callee.name === "tf") {
          if (methodArguments.length >= 2 && t.isTemplateLiteral(methodArguments[1])) {
            const quasis = methodArguments[1].quasis[0];
            const classes = removeWhiteSpaceInClasses(quasis.value.raw);
            if (classes) {
              const config = state.opts;
              const stylePath = config?.styles?.path ?? defaultStylesPath;
              const preset = config?.preset ?? "react";
              Logs.changePreset(preset);
              const filename = state.filename ?? "";
              const { reference, state: styleState } = emitter.register(filename, classes);
              const wasUpdated = styleState === "updated";
              if (!wasUpdated) {
                emitter.emit("process", {
                  classes,
                  filename,
                  reference,
                  stylePath
                });
              } else {
                emitter.checkStyles(stylePath);
              }
              quasis.value.raw = reference;
            }
          }
        }
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
